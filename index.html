<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anoma Academy - Learn, Play, Master</title>
    <style>
        :root {
            --bg: #0a0a0a;
            --surface: #1a1a1a;
            --text: #ffffff;
            --muted: #888888;
            --accent: #00d4ff;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #333333;
            
            /* Anoma Brand Colors */
            --anoma-primary: #00d4ff;
            --anoma-secondary: #10b981;
            --anoma-accent: #6366f1;
            --anoma-gradient: linear-gradient(135deg, #00d4ff 0%, #10b981 50%, #6366f1 100%);
            --anoma-glow: 0 0 30px rgba(0, 212, 255, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .anoma-logo-container {
            margin-bottom: 30px;
        }

        .anoma-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }


        .logo-text {
            text-align: center;
        }

        .anoma-tagline {
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 12px;
            padding: 20px 30px;
            margin: 25px auto;
            max-width: 700px;
            backdrop-filter: blur(8px);
        }

        .anoma-tagline p {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            color: var(--accent);
            font-weight: 500;
        }

        .anoma-badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .badge {
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
            padding: 6px 14px;
            border-radius: 16px;
            font-size: 0.85rem;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.2);
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .badge:hover {
            transform: translateY(-1px);
            background: rgba(0, 212, 255, 0.15);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }

        .main-title {
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d4ff 0%, #10b981 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
            letter-spacing: -0.02em;
            line-height: 1.1;
        }

        .main-subtitle {
            font-size: 1.1rem;
            color: var(--muted);
            margin-bottom: 25px;
            font-weight: 400;
            line-height: 1.4;
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .card h3 {
            color: var(--accent);
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent), var(--success));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            color: var(--muted);
            font-size: 0.9rem;
        }

        .learning-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .lesson-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lesson-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .lesson-card.unlocked {
            border-color: var(--success);
        }

        .lesson-card h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .cost {
            color: var(--success);
            font-weight: bold;
            margin-top: 10px;
        }

        .game-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .game-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .game-card:hover::before {
            left: 100%;
        }

        .game-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
        }

        .game-card h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .social-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .social-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .social-btn:hover {
            background: var(--accent);
            color: white;
        }

        .anoma-resources {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 20px;
        }

        .resource-category h4 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .social-btn.official {
            background: var(--anoma-gradient);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .social-btn.official:hover {
            background: var(--anoma-gradient);
            transform: translateY(-2px);
            box-shadow: var(--anoma-glow);
        }

        .social-btn.dev {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .social-btn.dev:hover {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
        }

        .anoma-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.05), rgba(16, 185, 129, 0.05));
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .feature-item:hover {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(16, 185, 129, 0.1));
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .feature-icon {
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent), var(--success));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .feature-text h4 {
            margin: 0 0 5px 0;
            color: var(--accent);
            font-size: 1.1rem;
        }

        .feature-text p {
            margin: 0;
            color: var(--muted);
            font-size: 0.9rem;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background: var(--surface);
            margin: 5% auto;
            padding: 20px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            position: relative;
        }

        .close-btn {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--muted);
            z-index: 1002;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            color: var(--text);
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .toast.show {
            opacity: 1;
        }

        .toast.success { background: var(--success); }
        .toast.error { background: var(--danger); }
        .toast.info { background: var(--accent); }
        .toast.warning { background: var(--warning); }

        /* 炫酷动画效果 */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px var(--accent); }
            50% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
            100% { box-shadow: 0 0 5px var(--accent); }
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-20px); }
            60% { transform: translateY(-10px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes rainbow {
            0% { color: #ff0000; }
            16% { color: #ff8000; }
            33% { color: #ffff00; }
            50% { color: #00ff00; }
            66% { color: #0080ff; }
            83% { color: #8000ff; }
            100% { color: #ff0000; }
        }

        .animated-pulse { animation: pulse 2s infinite; }
        .animated-glow { animation: glow 2s infinite; }
        .animated-float { animation: float 3s ease-in-out infinite; }
        .animated-spin { animation: spin 1s linear infinite; }
        .animated-bounce { animation: bounce 1s infinite; }
        .animated-shake { animation: shake 0.5s ease-in-out; }
        .animated-rainbow { animation: rainbow 3s linear infinite; }

        .game-card:hover {
            animation: pulse 0.6s ease-in-out;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }

        .lesson-card:hover {
            animation: glow 1s ease-in-out;
        }

        .stat-value {
            animation: float 4s ease-in-out infinite;
        }

        .main-title {
            animation: glow 3s ease-in-out infinite;
        }

        .mascot-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .mascot-shrimp {
            font-size: 2rem;
            cursor: pointer;
            transition: transform 0.3s ease;
            user-select: none;
        }

        .mascot-shrimp:hover {
            transform: scale(1.2) rotate(10deg);
        }

        .mascot-shrimp:active {
            transform: scale(0.9) rotate(-10deg);
        }

        .mascot-shrimp.clicked {
            animation: bounce 0.6s ease-in-out;
        }

        /* Game Categories */
        .game-category {
            margin-bottom: 30px;
        }

        .category-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            padding: 10px 20px;
            border-radius: 10px;
            border-left: 4px solid;
        }

        .category-knowledge {
            color: var(--success);
            background: rgba(16, 185, 129, 0.1);
            border-left-color: var(--success);
        }

        .category-intent {
            color: var(--accent);
            background: rgba(0, 212, 255, 0.1);
            border-left-color: var(--accent);
        }

        .category-puzzle {
            color: var(--warning);
            background: rgba(245, 158, 11, 0.1);
            border-left-color: var(--warning);
        }


        .category-action {
            color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
            border-left-color: var(--danger);
        }

        .category-speed {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            border-left-color: #00ff88;
        }

        @media (max-width: 768px) {
            .main-title { font-size: 2rem; }
            .learning-section, .game-section { grid-template-columns: 1fr; }
            .social-links { grid-template-columns: 1fr; }
            
            .modal-content {
                width: 95% !important;
                height: 95vh !important;
                margin: 2.5vh auto !important;
            }
            
            .tower-btn {
                min-width: 150px !important;
                padding: 12px !important;
            }
            
            .tower-btn div:first-child {
                font-size: 1.5rem !important;
            }
            
            .tower-btn div:nth-child(2) {
                font-size: 1rem !important;
            }
            
            .tower-btn div:last-child {
                font-size: 0.8rem !important;
            }
        }
        .author-info {
            text-align: center;
            margin: 40px 0 20px 0;
            padding: 20px;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 12px;
        }

        .author-info h3 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .author-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .author-btn {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(0, 212, 255, 0.1);
            color: var(--accent);
            text-decoration: none;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .author-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }

        .game-card.coming-soon {
            opacity: 0.7;
            border-style: dashed;
        }

        .game-card.coming-soon:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="anoma-logo-container">
                <div class="anoma-logo">
                    <div class="logo-text">
                        <h1 class="main-title">Anoma Academy</h1>
                        <p class="main-subtitle">Learn Anoma Concepts → Earn Points → Play Games → Master Web3</p>
                    </div>
                </div>
                <div class="anoma-tagline">
                    <p>🌐 The Intent-Centric Blockchain for Privacy-Preserving Cross-Chain Operations</p>
                    <div class="anoma-badges">
                        <span class="badge">⚡ Intent-First</span>
                        <span class="badge">🔐 Privacy by Design</span>
                        <span class="badge">🌐 Cross-Chain Native</span>
                    </div>
                </div>
            </div>
            <div class="mascot-container">
                <div class="mascot-shrimp animated-float">🦐</div>
                <div class="mascot-shrimp animated-float" style="animation-delay: 0.5s;">🦐</div>
                <div class="mascot-shrimp animated-float" style="animation-delay: 1s;">🦐</div>
            <div class="mascot-shrimp animated-float" style="animation-delay: 1.5s;">🦐</div>
            </div>
        </div>

        <!-- Player Stats -->
        <div class="card">
            <h3>📊 Your Progress</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div id="points" class="stat-value">1000</div>
                    <div class="stat-label">Points</div>
                </div>
                <div class="stat-item">
                    <div id="level" class="stat-value">1</div>
                    <div class="stat-label">Level</div>
                </div>
                <div class="stat-item">
                    <div id="lessons-completed" class="stat-value">0/6</div>
                    <div class="stat-label">Lessons</div>
                </div>
                <div class="stat-item">
                    <div id="games-played" class="stat-value">0</div>
                    <div class="stat-label">Games Played</div>
                </div>
            </div>
            <div class="sound-controls" style="margin-top: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button class="btn" onclick="toggleSound()" id="sound-btn" style="background: var(--success); font-size: 0.9rem; padding: 8px 12px;">
                    🔊 Sound On
                </button>
                <button class="btn" onclick="toggleMusic()" id="music-btn" style="background: var(--accent); font-size: 0.9rem; padding: 8px 12px;">
                    🎵 Music On
                </button>
                <button class="btn" onclick="showDifficultySelector()" id="difficulty-btn" style="background: var(--warning); font-size: 0.9rem; padding: 8px 12px;">
                    🎯 Easy
                </button>
            </div>
        </div>

        <!-- Learning Section -->
        <div class="card">
            <h3>🎓 Learn Anoma Concepts</h3>
            <p style="color: var(--muted); margin-bottom: 20px;">
                Complete lessons to earn points and unlock games. Each lesson teaches you about Anoma's core concepts.
            </p>
            <div class="learning-section">
                <div class="lesson-card unlocked" onclick="startLesson(1)">
                    <h4>🌱 What is Anoma?</h4>
                    <p>Learn the basics of intent-centric blockchain</p>
                    <div class="cost">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(2)">
                    <h4>⚡ Intent System</h4>
                    <p>Understand how intents work in Anoma</p>
                    <div class="cost">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(3)">
                    <h4>🔐 Privacy & ZK</h4>
                    <p>Learn about zero-knowledge proofs</p>
                    <div class="cost">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(4)">
                    <h4>🌐 Cross-Chain</h4>
                    <p>Understand cross-chain operations</p>
                    <div class="cost">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(5)">
                    <h4>🎯 Advanced Intents</h4>
                    <p>Master complex intent strategies</p>
                    <div class="cost">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(6)">
                    <h4>🏆 Anoma Master</h4>
                    <p>Become an Anoma expert</p>
                    <div class="cost">Reward: 100 points</div>
                </div>
            </div>
        </div>

        <!-- Game Section -->
        <div class="card">
            <h3>🎮 Play Games with Your Points</h3>
            <p style="color: var(--muted); margin-bottom: 20px;">
                Use your earned points to play games that teach you more about Anoma concepts.
            </p>
            
            <!-- Knowledge Games Category -->
            <div class="game-category">
                <h4 class="category-title category-knowledge">🧠 Knowledge Games</h4>
            <div class="game-section">
                <div class="game-card">
                    <h4>🧠 Anoma Master Quiz</h4>
                    <p>Advanced knowledge test with comprehensive Anoma concepts</p>
                    <div class="cost">Cost: 50 points</div>
                    <button class="btn" onclick="playAnomaQuiz()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🎯 Intent Matching Game</h4>
                    <p>Match intents with their optimal execution paths</p>
                    <div class="cost">Cost: 20 points</div>
                    <button class="btn" onclick="playIntentGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🔍 Intent Detective</h4>
                    <p>Analyze complex intents and find the best path</p>
                    <div class="cost">Cost: 35 points</div>
                    <button class="btn" onclick="playDetectiveGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>⚡ Speed Intent</h4>
                    <p>Express intents as fast as possible</p>
                    <div class="cost">Cost: 25 points</div>
                    <button class="btn" onclick="playSpeedGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🎲 Intent Dice</h4>
                    <p>Roll dice to build intent combinations</p>
                    <div class="cost">Cost: 25 points</div>
                    <button class="btn" onclick="playDiceGame()">Play Game</button>
                </div>
                </div>
            </div>

            <!-- Puzzle & Visual Games Category -->
            <div class="game-category">
                <h4 class="category-title category-puzzle">🧩 Puzzle & Visual Games</h4>
                <div class="game-section">
                <div class="game-card">
                    <h4>🔐 Privacy Puzzle</h4>
                    <p>Solve puzzles using zero-knowledge concepts</p>
                    <div class="cost">Cost: 30 points</div>
                    <button class="btn" onclick="playPrivacyGame()">Play Game</button>
                </div>
                        <div class="game-card">
                            <h4>🧩 Privacy Puzzle (Visual)</h4>
                            <p>Drag and drop ZK proof components</p>
                    <div class="cost">Cost: 35 points</div>
                            <button class="btn" onclick="playPuzzleGame()">Play Game</button>
                        </div>
                        <div class="game-card">
                            <h4>🧠 Anoma Memory</h4>
                            <p>Match Anoma concepts and test your memory</p>
                            <div class="cost">Cost: 25 points</div>
                            <button class="btn" onclick="playMemoryGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🛡️ Privacy Guardian</h4>
                    <p>Protect user data using ZK proofs</p>
                    <div class="cost">Cost: 30 points</div>
                    <button class="btn" onclick="playGuardianGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🎯 Intent Builder</h4>
                    <p>Create complex multi-step intents</p>
                    <div class="cost">Cost: 50 points</div>
                    <button class="btn" onclick="playBuilderGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🎮 Intent Tower Defense</h4>
                    <p>Defend against attacks using Anoma tools</p>
                    <div class="cost">Cost: 60 points</div>
                    <button class="btn" onclick="playTowerDefense()">Play Game</button>
                </div>
                </div>
            </div>

            <!-- Action & Arcade Games Category -->
            <div class="game-category">
                <h4 class="category-title category-action">🎮 Action & Arcade Games</h4>
                <div class="game-section">
                <div class="game-card">
                    <h4>🦐 Shrimp Jump Game</h4>
                    <p>Control the shrimp to jump and avoid obstacles</p>
                    <div class="cost">Cost: 30 points</div>
                    <button class="btn" onclick="playShrimpJumpGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🦐 Shrimp Collector</h4>
                    <p>Collect Anoma shrimps in this fun arcade game</p>
                    <div class="cost">Cost: 20 points</div>
                    <button class="btn" onclick="playShrimpCollector()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🧙 Wizard Coin Game</h4>
                    <p>Control wizard to catch falling coins</p>
                    <div class="cost">Cost: 20 points</div>
                    <button class="btn" onclick="playWizardCoinGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🎯 Intent Archery</h4>
                    <p>Shoot intents at targets with precision</p>
                    <div class="cost">Cost: 30 points</div>
                    <button class="btn" onclick="playArcheryGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🐍 Intent Snake</h4>
                    <p>Control the snake to collect Anoma shrimps</p>
                    <div class="cost">Cost: 25 points</div>
                    <button class="btn" onclick="playSnakeGame()">Play Game</button>
                </div>
                <div class="game-card">
                    <h4>🧩 Intent Puzzle</h4>
                    <p>Solve the sliding puzzle to unlock Anoma secrets</p>
                    <div class="cost">Cost: 35 points</div>
                    <button class="btn" onclick="playPuzzleGame()">Play Game</button>
                </div>
                <div class="game-card coming-soon">
                    <h4>🎮 More Games Coming Soon!</h4>
                    <p>Stay tuned for exciting new Anoma games</p>
                    <div class="cost">Coming Soon</div>
                    <button class="btn" onclick="playComingSoon()" style="background: var(--muted);">Coming Soon</button>
                </div>
                </div>
            </div>
        </div>

        <!-- Anoma Brand Section -->
        <div class="card">
            <h3>⚡ About Anoma</h3>
            <p style="color: var(--muted); margin-bottom: 20px;">
                Anoma is the first intent-centric blockchain that enables privacy-preserving cross-chain operations. 
                Learn more about our revolutionary technology and join the future of Web3!
            </p>
            <div class="anoma-features">
                <div class="feature-item">
                    <div class="feature-icon">🎯</div>
                    <div class="feature-text">
                        <h4>Intent-Centric</h4>
                        <p>Express what you want, not how to do it</p>
                    </div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">🔐</div>
                    <div class="feature-text">
                        <h4>Privacy-First</h4>
                        <p>Zero-knowledge proofs protect your data</p>
                    </div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">🌐</div>
                    <div class="feature-text">
                        <h4>Cross-Chain</h4>
                        <p>Seamless operations across all chains</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Anoma Official Links -->
        <div class="card">
            <h3>⚡ Official Anoma Resources</h3>
            <p style="color: var(--muted); margin-bottom: 20px;">
                Connect with the Anoma ecosystem and stay updated with the latest developments!
            </p>
            <div class="anoma-resources">
                <div class="resource-category">
                    <h4>🌐 Official Channels</h4>
            <div class="social-links">
                        <a href="https://anoma.network" target="_blank" class="social-btn official">
                            <span>🏠</span> Official Website
                        </a>
                        <a href="https://twitter.com/anoma" target="_blank" class="social-btn official">
                            <span>🐦</span> Twitter
                        </a>
                        <a href="https://discord.gg/anoma" target="_blank" class="social-btn official">
                            <span>💬</span> Discord
                        </a>
                    </div>
                </div>
                <div class="resource-category">
                    <h4>💻 Developer Resources</h4>
                    <div class="social-links">
                        <a href="https://github.com/anoma" target="_blank" class="social-btn dev">
                            <span>💻</span> GitHub
                        </a>
                        <a href="https://docs.anoma.network" target="_blank" class="social-btn dev">
                            <span>📚</span> Documentation
                        </a>
                        <a href="https://anoma.network/blog" target="_blank" class="social-btn dev">
                            <span>📝</span> Blog
                        </a>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>

    <script>
        // Game State
        let gameState = {
            points: 1000,
            level: 1,
            lessonsCompleted: 0,
            gamesPlayed: 0,
            completedLessons: [],
            achievements: [],
            soundEnabled: true,
            musicEnabled: true,
            difficulty: 'easy', // easy, medium, hard
            gameLevels: {
                'Intent Matching': 1,
                'Privacy Puzzle': 1,
                'Cross-Chain Challenge': 1,
                'Speed Intent': 1,
                'Intent Detective': 1,
                'Privacy Guardian': 1,
                'Intent Dice': 1,
                'Bridge Master': 1,
                'Intent Builder': 1,
                'Tower Defense': 1,
                'Privacy Puzzle (Visual)': 1,
                'Intent Runner': 1
            }
        };

        // 丰富的Anoma题库系统
        const anomaQuestionBank = {
            easy: [
                {
                    question: "Anoma是什么类型的区块链？",
                    options: ["权益证明", "意图中心化", "工作量证明", "委托权益证明"],
                    correct: 1,
                    explanation: "Anoma是意图中心化的区块链，专注于用户意图的表达和执行"
                },
                {
                    question: "在Anoma中，用户如何表达需求？",
                    options: ["使用复杂的交易代码", "通过意图表达", "发送邮件", "打电话"],
                    correct: 1,
                    explanation: "Anoma使用意图系统，用户只需表达想要什么，而不是如何实现"
                },
                {
                    question: "Anoma如何保护用户隐私？",
                    options: ["使用密码", "零知识证明", "隐藏IP地址", "删除数据"],
                    correct: 1,
                    explanation: "Anoma使用零知识证明技术来保护用户隐私"
                },
                {
                    question: "Anoma支持哪些操作？",
                    options: ["仅以太坊", "仅比特币", "跨链操作", "仅DeFi"],
                    correct: 2,
                    explanation: "Anoma支持跨链操作，可以连接多个区块链生态系统"
                },
                {
                    question: "意图系统的优势是什么？",
                    options: ["更复杂", "更简单易用", "更昂贵", "更慢"],
                    correct: 1,
                    explanation: "意图系统让用户只需表达需求，系统自动找到最佳执行路径"
                },
                {
                    question: "Anoma的AI系统做什么？",
                    options: ["挖矿", "匹配最佳执行路径", "存储数据", "验证交易"],
                    correct: 1,
                    explanation: "AI系统分析用户意图，找到最优的执行路径"
                },
                {
                    question: "零知识证明的作用是？",
                    options: ["提高速度", "证明某事而不泄露信息", "降低成本", "增加安全性"],
                    correct: 1,
                    explanation: "零知识证明允许证明某个陈述为真，而不泄露任何额外信息"
                },
                {
                    question: "Anoma如何处理跨链交易？",
                    options: ["手动操作", "自动无缝处理", "需要多个钱包", "不支持"],
                    correct: 1,
                    explanation: "Anoma自动处理跨链操作，为用户提供统一体验"
                },
                {
                    question: "Anoma的创始人是谁？",
                    options: ["Vitalik Buterin", "Arianne Flemming", "Charles Hoskinson", "Gavin Wood"],
                    correct: 1,
                    explanation: "Arianne Flemming是Anoma的创始人，她提出了意图中心化的区块链设计理念。"
                },
                {
                    question: "Anoma网络的原生代币是什么？",
                    options: ["ANOMA", "NOM", "ANM", "ANOMA Token"],
                    correct: 1,
                    explanation: "NOM是Anoma网络的原生代币，用于网络治理和交易费用。"
                },
                {
                    question: "Anoma的主要编程语言是什么？",
                    options: ["Solidity", "Rust", "Go", "Python"],
                    correct: 1,
                    explanation: "Anoma主要使用Rust语言开发，确保了高性能和内存安全。"
                },
                {
                    question: "Anoma的意图语言叫什么？",
                    options: ["Solidity", "Rust", "Taiga", "Move"],
                    correct: 2,
                    explanation: "Taiga是Anoma的意图语言，专门用于表达和描述用户意图。"
                }
            ],
            medium: [
                {
                    question: "在Anoma中，意图匹配器的主要功能是什么？",
                    options: ["挖矿", "匹配兼容的意图", "存储数据", "验证身份"],
                    correct: 1,
                    explanation: "意图匹配器负责找到可以相互满足的意图对"
                },
                {
                    question: "Anoma的隐私保护机制包括哪些？",
                    options: ["仅加密", "零知识证明和混淆", "仅匿名", "仅隐藏IP"],
                    correct: 1,
                    explanation: "Anoma使用零知识证明和交易混淆来保护隐私"
                },
                {
                    question: "意图表达的最佳实践是什么？",
                    options: ["详细描述步骤", "表达最终目标", "使用技术术语", "避免具体化"],
                    correct: 1,
                    explanation: "应该表达最终目标，让系统找到最佳实现方式"
                },
                {
                    question: "Anoma如何处理MEV（最大可提取价值）？",
                    options: ["忽略", "通过意图系统减少", "增加费用", "禁止套利"],
                    correct: 1,
                    explanation: "意图系统通过优化匹配减少MEV提取"
                },
                {
                    question: "跨链意图的优势是什么？",
                    options: ["更便宜", "获得最佳流动性", "更简单", "更安全"],
                    correct: 1,
                    explanation: "跨链意图可以访问所有链上的流动性，获得最佳价格"
                },
                {
                    question: "Anoma的共识机制是什么？",
                    options: ["PoW", "PoS", "混合共识", "DPoS"],
                    correct: 2,
                    explanation: "Anoma使用混合共识机制，结合多种共识算法"
                },
                {
                    question: "意图执行失败时会发生什么？",
                    options: ["资金丢失", "自动重试", "回滚交易", "手动处理"],
                    correct: 2,
                    explanation: "如果意图执行失败，交易会回滚，资金安全"
                },
                {
                    question: "Anoma如何确保意图的隐私性？",
                    options: ["加密存储", "零知识证明", "本地处理", "以上都是"],
                    correct: 3,
                    explanation: "Anoma使用多种技术确保意图的隐私性"
                },
                {
                    question: "Anoma的治理机制是什么？",
                    options: ["中心化治理", "PoS治理", "意图驱动的治理", "无治理"],
                    correct: 2,
                    explanation: "Anoma采用意图驱动的治理机制，用户可以通过表达治理意图来参与网络决策。"
                },
                {
                    question: "Anoma如何处理复杂的多步骤意图？",
                    options: ["不支持", "通过意图分解", "通过智能合约", "通过预言机"],
                    correct: 1,
                    explanation: "Anoma可以将复杂的多步骤意图分解为多个简单的子意图，然后并行执行。"
                },
                {
                    question: "Anoma的零知识证明系统基于什么？",
                    options: ["仅zk-SNARKs", "仅zk-STARKs", "仅Plonk", "多种技术"],
                    correct: 3,
                    explanation: "Anoma支持多种零知识证明系统，包括zk-SNARKs、zk-STARKs和Plonk等。"
                },
                {
                    question: "Anoma的意图匹配算法基于什么原理？",
                    options: ["贪心算法", "动态规划", "机器学习", "博弈论"],
                    correct: 3,
                    explanation: "Anoma的意图匹配算法基于博弈论原理，通过市场机制来优化意图匹配。"
                }
            ],
            hard: [
                {
                    question: "Anoma的意图语言（Intent Language）支持哪些高级功能？",
                    options: ["基本交换", "条件逻辑和复合意图", "仅限DeFi", "仅限NFT"],
                    correct: 1,
                    explanation: "意图语言支持复杂的条件逻辑和复合意图"
                },
                {
                    question: "在Anoma中，如何实现隐私保护的跨链套利？",
                    options: ["不可能", "使用零知识证明隐藏套利策略", "公开进行", "仅限单链"],
                    correct: 1,
                    explanation: "可以使用零知识证明来隐藏套利策略，同时保护隐私"
                },
                {
                    question: "Anoma的意图匹配算法如何优化？",
                    options: ["随机匹配", "使用AI和博弈论", "仅按时间", "仅按金额"],
                    correct: 1,
                    explanation: "使用AI和博弈论来优化意图匹配，找到最优解"
                },
                {
                    question: "Anoma的隐私保护如何与可验证性平衡？",
                    options: ["牺牲隐私", "牺牲可验证性", "通过零知识证明实现", "通过加密实现"],
                    correct: 2,
                    explanation: "Anoma通过零知识证明技术，在保护用户隐私的同时保持交易的可验证性。"
                },
                {
                    question: "Anoma的意图分解器如何工作？",
                    options: ["不支持分解", "将复杂意图分解为简单子意图", "仅支持单一意图", "通过智能合约"],
                    correct: 1,
                    explanation: "意图分解器可以将复杂的多步骤意图分解为多个简单的子意图，然后并行执行。"
                },
                {
                    question: "Anoma如何处理意图冲突？",
                    options: ["忽略冲突", "通过博弈论解决", "随机选择", "用户手动解决"],
                    correct: 1,
                    explanation: "Anoma使用博弈论机制来解决意图冲突，找到最优的解决方案。"
                },
                {
                    question: "Anoma的跨链意图如何保证原子性？",
                    options: ["无法保证", "通过哈希锁定", "通过意图协调器", "通过智能合约"],
                    correct: 2,
                    explanation: "Anoma通过意图协调器来保证跨链意图的原子性，要么全部成功，要么全部失败。"
                },
                {
                    question: "如何处理意图的原子性执行？",
                    options: ["忽略", "使用哈希时间锁", "手动确认", "分批执行"],
                    correct: 1,
                    explanation: "使用哈希时间锁等技术确保意图的原子性执行"
                },
                {
                    question: "Anoma的隐私保护如何扩展到复杂交易？",
                    options: ["不支持", "使用递归零知识证明", "仅限简单交易", "手动处理"],
                    correct: 1,
                    explanation: "使用递归零知识证明来保护复杂交易的隐私"
                },
                {
                    question: "意图系统的可扩展性如何保证？",
                    options: ["增加节点", "使用分片技术", "限制用户", "以上都是"],
                    correct: 3,
                    explanation: "通过多种技术手段保证意图系统的可扩展性"
                },
                {
                    question: "Anoma如何处理意图的优先级和排序？",
                    options: ["FIFO", "基于费用", "使用拍卖机制", "以上都是"],
                    correct: 3,
                    explanation: "使用多种机制来处理意图的优先级和排序"
                },
                {
                    question: "在Anoma中，如何实现隐私保护的治理投票？",
                    options: ["不可能", "使用零知识证明", "公开投票", "委托投票"],
                    correct: 1,
                    explanation: "使用零知识证明技术实现隐私保护的治理投票"
                }
            ]
        };

        // 题目选择函数
        function getRandomQuestions(difficulty, count = 3) {
            const questions = anomaQuestionBank[difficulty] || anomaQuestionBank.easy;
            const shuffled = [...questions].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        // 生成隐私谜题
        function generatePrivacyPuzzles(difficulty) {
            const puzzleTemplates = {
                easy: [
                    {
                        title: "ZK证明基础",
                        description: "排列零知识证明的基本组件",
                        pieces: ["秘密", "证明", "验证者", "证明者"],
                        solution: ["证明者", "秘密", "证明", "验证者"],
                        explanation: "证明者使用秘密创建证明，验证者检查证明的有效性"
                    },
                    {
                        title: "意图流程",
                        description: "排列意图执行的基本步骤",
                        pieces: ["表达意图", "执行", "验证", "结算"],
                        solution: ["表达意图", "执行", "验证", "结算"],
                        explanation: "用户表达意图 → 系统执行 → 验证结果 → 交易结算"
                    }
                ],
                medium: [
                    {
                        title: "隐私保护机制",
                        description: "排列Anoma的隐私保护组件",
                        pieces: ["零知识证明", "交易混淆", "意图匹配", "隐私计算"],
                        solution: ["意图匹配", "零知识证明", "交易混淆", "隐私计算"],
                        explanation: "意图匹配 → 零知识证明 → 交易混淆 → 隐私计算"
                    },
                    {
                        title: "跨链隐私",
                        description: "排列跨链隐私保护的步骤",
                        pieces: ["跨链意图", "隐私证明", "链间验证", "隐私结算"],
                        solution: ["跨链意图", "隐私证明", "链间验证", "隐私结算"],
                        explanation: "创建跨链意图 → 生成隐私证明 → 链间验证 → 隐私结算"
                    }
                ],
                hard: [
                    {
                        title: "高级隐私架构",
                        description: "排列复杂的隐私保护架构组件",
                        pieces: ["递归ZK", "隐私聚合", "零知识虚拟机", "隐私状态机", "隐私共识"],
                        solution: ["隐私状态机", "递归ZK", "零知识虚拟机", "隐私聚合", "隐私共识"],
                        explanation: "隐私状态机 → 递归ZK → 零知识虚拟机 → 隐私聚合 → 隐私共识"
                    },
                    {
                        title: "隐私治理",
                        description: "排列隐私治理的完整流程",
                        pieces: ["隐私投票", "零知识验证", "治理证明", "隐私结果", "状态更新"],
                        solution: ["隐私投票", "零知识验证", "治理证明", "隐私结果", "状态更新"],
                        explanation: "隐私投票 → 零知识验证 → 治理证明 → 隐私结果 → 状态更新"
                    }
                ]
            };
            
            const puzzles = puzzleTemplates[difficulty] || puzzleTemplates.easy;
            return [...puzzles].sort(() => 0.5 - Math.random());
        }

        // 生成跨链挑战
        function generateCrossChainChallenges(difficulty) {
            const challengeTemplates = {
                easy: [
                    { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                    { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                    { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 }
                ],
                medium: [
                    { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                    { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                    { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 },
                    { from: 'Arbitrum', to: 'Optimism', method: 'Synapse Protocol', cost: 0.03, time: 4 },
                    { from: 'Ethereum', to: 'BSC', method: 'Binance Bridge', cost: 0.08, time: 8 },
                    { from: 'Polygon', to: 'Avalanche', method: 'Avalanche Bridge', cost: 0.06, time: 6 }
                ],
                hard: [
                    { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                    { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                    { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 },
                    { from: 'Arbitrum', to: 'Optimism', method: 'Synapse Protocol', cost: 0.03, time: 4 },
                    { from: 'Ethereum', to: 'BSC', method: 'Binance Bridge', cost: 0.08, time: 8 },
                    { from: 'Polygon', to: 'Avalanche', method: 'Avalanche Bridge', cost: 0.06, time: 6 },
                    { from: 'Ethereum', to: 'Solana', method: 'Wormhole', cost: 0.12, time: 15 },
                    { from: 'Arbitrum', to: 'Base', method: 'Base Bridge', cost: 0.04, time: 7 },
                    { from: 'Polygon', to: 'Fantom', method: 'Multichain', cost: 0.07, time: 9 }
                ]
            };
            
            const bridges = challengeTemplates[difficulty] || challengeTemplates.easy;
            return [...bridges].sort(() => 0.5 - Math.random());
        }

        // Sound System
        const soundSystem = {
            playSound: function(soundName) {
                if (!gameState.soundEnabled) return;
                
                const sounds = {
                    click: () => this.createTone(800, 0.1, 'sine'),
                    success: () => this.createTone(1200, 0.3, 'sine'),
                    error: () => this.createTone(400, 0.5, 'sawtooth'),
                    jump: () => this.createTone(600, 0.2, 'square'),
                    collect: () => this.createTone(1000, 0.15, 'triangle'),
                    gameStart: () => this.createTone(800, 0.5, 'sine'),
                    gameEnd: () => this.createTone(400, 1, 'sawtooth')
                };
                
                if (sounds[soundName]) {
                    sounds[soundName]();
                }
            },
            
            createTone: function(frequency, duration, type) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }
        };

        // Background Music System
        const musicSystem = {
            isPlaying: false,
            audioContext: null,
            oscillators: [],
            
            startMusic: function() {
                if (!gameState.musicEnabled || this.isPlaying) return;
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.isPlaying = true;
                this.playMelody();
            },
            
            stopMusic: function() {
                this.isPlaying = false;
                this.oscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
                this.oscillators = [];
            },
            
            playMelody: function() {
                if (!this.isPlaying) return;
                
                // Anoma Academy Theme - Simple melody
                const melody = [
                    {freq: 523.25, duration: 0.5}, // C5
                    {freq: 659.25, duration: 0.5}, // E5
                    {freq: 783.99, duration: 0.5}, // G5
                    {freq: 659.25, duration: 0.5}, // E5
                    {freq: 523.25, duration: 0.5}, // C5
                    {freq: 440.00, duration: 0.5}, // A4
                    {freq: 523.25, duration: 1.0}, // C5
                ];
                
                let time = this.audioContext.currentTime;
                
                melody.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(note.freq, time);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, time);
                    gainNode.gain.linearRampToValueAtTime(0.05, time + 0.01);
                    gainNode.gain.linearRampToValueAtTime(0, time + note.duration);
                    
                    oscillator.start(time);
                    oscillator.stop(time + note.duration);
                    
                    this.oscillators.push(oscillator);
                    time += note.duration;
                });
                
                // Loop the melody
                setTimeout(() => {
                    if (this.isPlaying) {
                        this.playMelody();
                    }
                }, time * 1000);
            }
        };

        // Particle System
        const particleSystem = {
            particles: [],
            
            createParticle: function(x, y, type = 'sparkle') {
                const particle = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0,
                    decay: 0.02,
                    size: Math.random() * 4 + 2,
                    type: type,
                    color: this.getParticleColor(type)
                };
                this.particles.push(particle);
            },
            
            getParticleColor: function(type) {
                const colors = {
                    sparkle: ['#00d4ff', '#ff6b6b', '#4ecdc4', '#45b7d1'],
                    collect: ['#ffd700', '#ffed4e', '#fbbf24'],
                    jump: ['#8b5cf6', '#a78bfa', '#c4b5fd'],
                    success: ['#10b981', '#34d399', '#6ee7b7'],
                    error: ['#ef4444', '#f87171', '#fca5a5']
                };
                const colorSet = colors[type] || colors.sparkle;
                return colorSet[Math.floor(Math.random() * colorSet.length)];
            },
            
            update: function() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    particle.vy += 0.1; // gravity
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },
            
            render: function(context) {
                this.particles.forEach(particle => {
                    context.save();
                    context.globalAlpha = particle.life;
                    context.fillStyle = particle.color;
                    context.shadowBlur = 10;
                    context.shadowColor = particle.color;
                    context.beginPath();
                    context.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    context.fill();
                    context.restore();
                });
            },
            
            createExplosion: function(x, y, count = 20) {
                for (let i = 0; i < count; i++) {
                    this.createParticle(x, y, 'sparkle');
                }
            },
            
            createCollectEffect: function(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.createParticle(x, y, 'collect');
                }
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateStats();
            showToast('🏛️ Welcome to Anoma Academy! Start learning to earn points!', 'info');
            
            // Add mascot click events
            document.querySelectorAll('.mascot-shrimp').forEach(shrimp => {
                shrimp.addEventListener('click', function() {
                    this.classList.add('clicked');
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(this.offsetLeft + 20, this.offsetTop + 20, 20);
                    showToast('🦐 Anoma Shrimp says: Keep learning!', 'success');
                    
                    setTimeout(() => {
                        this.classList.remove('clicked');
                    }, 600);
                });
            });
            
            // Start background music after a short delay
            setTimeout(() => {
                if (gameState.musicEnabled) {
                    musicSystem.startMusic();
                }
            }, 1000);
        });

        // Update stats
        function updateStats() {
            document.getElementById('points').textContent = gameState.points;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('lessons-completed').textContent = `${gameState.lessonsCompleted}/6`;
            document.getElementById('games-played').textContent = gameState.gamesPlayed;
        }

        // Sound control functions
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const btn = document.getElementById('sound-btn');
            btn.textContent = gameState.soundEnabled ? '🔊 Sound On' : '🔇 Sound Off';
            btn.style.background = gameState.soundEnabled ? 'var(--success)' : 'var(--danger)';
            soundSystem.playSound('click');
        }

        function toggleMusic() {
            gameState.musicEnabled = !gameState.musicEnabled;
            const btn = document.getElementById('music-btn');
            btn.textContent = gameState.musicEnabled ? '🎵 Music On' : '🔇 Music Off';
            btn.style.background = gameState.musicEnabled ? 'var(--accent)' : 'var(--danger)';
            soundSystem.playSound('click');
            
            if (gameState.musicEnabled) {
                musicSystem.startMusic();
            } else {
                musicSystem.stopMusic();
            }
        }

        function showDifficultySelector() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Select Difficulty</h3>
                    <div style="margin: 30px 0;">
                        <div class="difficulty-option" onclick="setDifficulty('easy')" style="padding: 20px; margin: 10px 0; background: var(--surface); border-radius: 10px; cursor: pointer; border: 2px solid ${gameState.difficulty === 'easy' ? 'var(--success)' : 'var(--border)'};">
                            <h4 style="color: var(--success);">🟢 Easy</h4>
                            <p>Perfect for beginners. Slower pace, more hints.</p>
                        </div>
                        <div class="difficulty-option" onclick="setDifficulty('medium')" style="padding: 20px; margin: 10px 0; background: var(--surface); border-radius: 10px; cursor: pointer; border: 2px solid ${gameState.difficulty === 'medium' ? 'var(--warning)' : 'var(--border)'};">
                            <h4 style="color: var(--warning);">🟡 Medium</h4>
                            <p>Balanced challenge. Normal pace, some hints.</p>
                        </div>
                        <div class="difficulty-option" onclick="setDifficulty('hard')" style="padding: 20px; margin: 10px 0; background: var(--surface); border-radius: 10px; cursor: pointer; border: 2px solid ${gameState.difficulty === 'hard' ? 'var(--danger)' : 'var(--border)'};">
                            <h4 style="color: var(--danger);">🔴 Hard</h4>
                            <p>Expert level. Fast pace, no hints.</p>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            const btn = document.getElementById('difficulty-btn');
            const colors = { easy: 'var(--success)', medium: 'var(--warning)', hard: 'var(--danger)' };
            const icons = { easy: '🟢', medium: '🟡', hard: '🔴' };
            
            btn.textContent = `${icons[difficulty]} ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`;
            btn.style.background = colors[difficulty];
            
            soundSystem.playSound('success');
            showToast(`Difficulty set to ${difficulty}!`, 'success');
            closeModal();
        }

        // Achievement System
        function checkAchievements() {
            const newAchievements = [];
            
            // First game achievement
            if (gameState.gamesPlayed === 1 && !gameState.achievements.includes('first_game')) {
                newAchievements.push({ id: 'first_game', name: '🎮 First Game', description: 'Played your first game!' });
            }
            
            // Points achievements
            if (gameState.points >= 500 && !gameState.achievements.includes('points_500')) {
                newAchievements.push({ id: 'points_500', name: '💰 Point Collector', description: 'Earned 500 points!' });
            }
            
            if (gameState.points >= 1000 && !gameState.achievements.includes('points_1000')) {
                newAchievements.push({ id: 'points_1000', name: '💎 Point Master', description: 'Earned 1000 points!' });
            }
            
            // Lesson achievements
            if (gameState.lessonsCompleted >= 3 && !gameState.achievements.includes('lessons_3')) {
                newAchievements.push({ id: 'lessons_3', name: '📚 Student', description: 'Completed 3 lessons!' });
            }
            
            if (gameState.lessonsCompleted >= 6 && !gameState.achievements.includes('lessons_all')) {
                newAchievements.push({ id: 'lessons_all', name: '🎓 Graduate', description: 'Completed all lessons!' });
            }
            
            // Game achievements
            if (gameState.gamesPlayed >= 5 && !gameState.achievements.includes('games_5')) {
                newAchievements.push({ id: 'games_5', name: '🎯 Gamer', description: 'Played 5 games!' });
            }
            
            if (gameState.gamesPlayed >= 10 && !gameState.achievements.includes('games_10')) {
                newAchievements.push({ id: 'games_10', name: '🏆 Game Master', description: 'Played 10 games!' });
            }
            
            // Add new achievements
            newAchievements.forEach(achievement => {
                gameState.achievements.push(achievement.id);
                showAchievement(achievement);
            });
        }

        function showAchievement(achievement) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 400px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h2 class="animated-bounce">🏆 Achievement Unlocked!</h2>
                    <div style="font-size: 3rem; margin: 20px 0;">${achievement.name}</div>
                    <p style="font-size: 1.2rem; margin: 20px 0;">${achievement.description}</p>
                    <button class="btn" onclick="closeModal()" style="background: var(--accent);">Awesome!</button>
                </div>
            `;
            document.body.appendChild(modal);
            
            soundSystem.playSound('success');
            particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
        }

        // Start lesson
        function startLesson(lessonNumber) {
            if (gameState.completedLessons.includes(lessonNumber)) {
                showToast('You already completed this lesson!', 'error');
                soundSystem.playSound('error');
                return;
            }

            if (lessonNumber > 1 && !gameState.completedLessons.includes(lessonNumber - 1)) {
                showToast('Complete the previous lesson first!', 'error');
                soundSystem.playSound('error');
                return;
            }

            soundSystem.playSound('click');
            showLessonModal(lessonNumber);
        }

        // Show lesson modal
        function showLessonModal(lessonNumber) {
            const lessons = {
                1: {
                    title: "🌱 What is Anoma?",
                    content: `
                        <h3>What is Anoma?</h3>
                        <p>Anoma is a revolutionary blockchain protocol that introduces <strong>intent-centric interactions</strong>.</p>
                        <p>Instead of telling the system HOW to do something, you tell it WHAT you want to achieve.</p>
                        <br>
                        <h4>Key Concepts:</h4>
                        <ul>
                            <li><strong>Intent System:</strong> Express what you want, not how to do it</li>
                            <li><strong>Privacy First:</strong> Zero-knowledge proofs protect your data</li>
                            <li><strong>Cross-Chain:</strong> Works across multiple blockchains</li>
                            <li><strong>AI-Powered:</strong> Smart matching finds the best execution path</li>
                        </ul>
                        <br>
                        <h4>Example:</h4>
                        <p>Instead of: "Execute ETH/USDC swap on Uniswap V3"</p>
                        <p>You say: "I want to swap 1 ETH for the best possible amount of USDC"</p>
                    `
                },
                2: {
                    title: "⚡ Intent System",
                    content: `
                        <h3>How Intents Work</h3>
                        <p>Anoma's intent system processes your requests in three steps:</p>
                        <br>
                        <h4>1. Express Intent</h4>
                        <p>Tell the system what you want to achieve</p>
                        <br>
                        <h4>2. AI Analysis</h4>
                        <p>The system finds the best execution path across all available options</p>
                        <br>
                        <h4>3. Execute</h4>
                        <p>Your intent is automatically executed with optimal results</p>
                    `
                },
                3: {
                    title: "🔐 Privacy & ZK",
                    content: `
                        <h3>Zero-Knowledge Proofs</h3>
                        <p>Anoma uses zero-knowledge proofs to protect your privacy while maintaining security.</p>
                        <br>
                        <h4>How it works:</h4>
                        <ul>
                            <li>Prove you have the right to do something</li>
                            <li>Without revealing what that something is</li>
                            <li>Maintain complete privacy</li>
                        </ul>
                    `
                },
                4: {
                    title: "🌐 Cross-Chain",
                    content: `
                        <h3>Cross-Chain Operations</h3>
                        <p>Anoma works across multiple blockchains seamlessly.</p>
                        <br>
                        <h4>Benefits:</h4>
                        <ul>
                            <li>Access to all blockchain ecosystems</li>
                            <li>Best execution across chains</li>
                            <li>Unified experience</li>
                        </ul>
                    `
                },
                5: {
                    title: "🎯 Advanced Intents",
                    content: `
                        <h3>Complex Intent Strategies</h3>
                        <p>Learn to create sophisticated multi-step intents.</p>
                        <br>
                        <h4>Advanced Features:</h4>
                        <ul>
                            <li>Multi-step transactions</li>
                            <li>Conditional logic</li>
                            <li>Cross-chain arbitrage</li>
                        </ul>
                    `
                },
                6: {
                    title: "🏆 Anoma Master",
                    content: `
                        <h3>Congratulations!</h3>
                        <p>You've mastered the core concepts of Anoma!</p>
                        <br>
                        <h4>You now understand:</h4>
                        <ul>
                            <li>Intent-centric interactions</li>
                            <li>Privacy protection with ZK</li>
                            <li>Cross-chain operations</li>
                            <li>Advanced strategies</li>
                        </ul>
                    `
                }
            };

            const lesson = lessons[lessonNumber];
            if (!lesson) return;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>${lesson.title}</h3>
                    <div style="margin: 20px 0; line-height: 1.8;">
                        ${lesson.content}
                    </div>
                    <div style="text-align: center; margin-top: 30px;">
                        <button class="btn" onclick="completeLesson(${lessonNumber})">Complete Lesson</button>
                        <button class="btn" onclick="closeModal()" style="background: var(--muted);">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Complete lesson
        function completeLesson(lessonNumber) {
            if (!gameState.completedLessons.includes(lessonNumber)) {
                gameState.completedLessons.push(lessonNumber);
                gameState.lessonsCompleted++;
                gameState.points += lessonNumber === 6 ? 100 : 50;
                gameState.level = Math.floor(gameState.lessonsCompleted / 2) + 1;
                
                updateStats();
                showToast(`Lesson ${lessonNumber} completed! +${lessonNumber === 6 ? 100 : 50} points`, 'success');
                
                // Unlock next lesson
                if (lessonNumber < 6) {
                    const nextLesson = document.querySelector(`[onclick="startLesson(${lessonNumber + 1})"]`);
                    if (nextLesson) {
                        nextLesson.classList.add('unlocked');
                    }
                }
            }
            closeModal();
        }

        // Game functions
        function playIntentGame() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showIntentGame();
        }

        function showIntentGame() {
            // 根据当前难度获取随机题目
            const questions = getRandomQuestions(gameState.difficulty, 5);
            let currentQuestion = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Matching Game</h3>
                    <div style="text-align: center; margin: 10px 0; color: var(--accent);">
                        <strong>难度: ${gameState.difficulty.toUpperCase()} | 题目: ${questions.length}题</strong>
                    </div>
                    <div id="intent-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Question ${currentQuestion + 1}/${questions.length}</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>${questions[0].question}</strong>
                            </div>
                            <div id="intent-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${questions[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectIntentOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="intent-score">Score: 0/${questions.length}</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectIntentOption = function(selectedIndex) {
                const correct = questions[currentQuestion].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct!', 'success');
                } else {
                    showToast('❌ Wrong!', 'error');
                }

                currentQuestion++;
                if (currentQuestion < questions.length) {
                    document.querySelector('h4').textContent = `Question ${currentQuestion + 1}/3`;
                    document.querySelector('#intent-game-content strong').textContent = questions[currentQuestion].question;
                    document.getElementById('intent-options').innerHTML = questions[currentQuestion].options.map((option, index) => 
                        `<button class="btn" onclick="selectIntentOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('intent-score').textContent = `Score: ${score}/${currentQuestion}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 10);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('intent-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/3</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPrivacyGame();
        }

        function playPrivacyGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showPrivacyGame();
        }

        function showPrivacyGame() {
            // 根据难度生成不同的谜题
            const puzzles = generatePrivacyPuzzles(gameState.difficulty);

            let currentPuzzle = 0;
            let score = 0;
            let selectedPieces = [];
            let placedPieces = [];

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Privacy Puzzle Game</h3>
                    <div style="text-align: center; margin: 10px 0; color: var(--accent);">
                        <strong>难度: ${gameState.difficulty.toUpperCase()} | 谜题: ${puzzles.length}个</strong>
                    </div>
                    <div id="puzzle-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>${puzzles[0].title}</h4>
                            <p>${puzzles[0].description}</p>
                            <div id="puzzle-board" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; min-height: 200px;">
                                ${puzzles[0].pieces.map((piece, index) => 
                                    `<div class="puzzle-piece" onclick="selectPuzzlePiece(${index})" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s ease;">${piece}</div>`
                                ).join('')}
                            </div>
                            <div id="puzzle-solution" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; min-height: 200px; background: rgba(0, 212, 255, 0.1); border-radius: 10px; padding: 20px;">
                                <div style="grid-column: 1/-1; text-align: center; color: var(--muted);">Drop pieces here in correct order</div>
                            </div>
                            <button class="btn" onclick="checkPuzzle()" style="background: var(--success);">Check Solution</button>
                            <div id="puzzle-score">Score: 0/2</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectPuzzlePiece = function(index) {
                if (selectedPieces.includes(index)) return;
                
                selectedPieces.push(index);
                const piece = puzzles[currentPuzzle].pieces[index];
                placedPieces.push(piece);
                
                updatePuzzleDisplay();
            };

            window.checkPuzzle = function() {
                const solution = puzzles[currentPuzzle].solution;
                const isCorrect = JSON.stringify(placedPieces) === JSON.stringify(solution);
                
                if (isCorrect) {
                    score++;
                    showToast('✅ Puzzle solved!', 'success');
                    
                    document.getElementById('puzzle-solution').innerHTML = `
                        <div style="grid-column: 1/-1; text-align: center;">
                            <h4>Correct! 🎉</h4>
                            <p>${puzzles[currentPuzzle].explanation}</p>
                        </div>
                    `;
                    
                    setTimeout(() => {
                        currentPuzzle++;
                        if (currentPuzzle < puzzles.length) {
                            loadPuzzle(currentPuzzle);
                        } else {
                            endPuzzleGame();
                        }
                    }, 2000);
                } else {
                    showToast('❌ Try again!', 'error');
                    selectedPieces = [];
                    placedPieces = [];
                    loadPuzzle(currentPuzzle);
                }
            };

            function loadPuzzle(index) {
                selectedPieces = [];
                placedPieces = [];
                
                document.querySelector('h4').textContent = puzzles[index].title;
                document.querySelector('p').textContent = puzzles[index].description;
                
                document.getElementById('puzzle-board').innerHTML = puzzles[index].pieces.map((piece, i) => 
                    `<div class="puzzle-piece" onclick="selectPuzzlePiece(${i})" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s ease;">${piece}</div>`
                ).join('');
                
                document.getElementById('puzzle-solution').innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--muted);">Drop pieces here in correct order</div>';
            }

            function updatePuzzleDisplay() {
                document.getElementById('puzzle-solution').innerHTML = placedPieces.map(piece => 
                    `<div style="background: var(--accent); color: white; border-radius: 8px; padding: 15px; text-align: center;">${piece}</div>`
                ).join('');
            }

            function endPuzzleGame() {
                const pointsEarned = Math.floor(score * 15);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('puzzle-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 All Puzzles Solved!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${score}/2</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playCrossChainGame() {
            if (gameState.points < 40) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 40;
            gameState.gamesPlayed++;
            updateStats();
            showCrossChainGame();
        }

        function playDetectiveGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showDetectiveGame();
        }

        function playGuardianGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showGuardianGame();
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPuzzleGame();
        }

        function showCrossChainGame() {
            // 根据难度生成不同的跨链挑战
            const bridges = generateCrossChainChallenges(gameState.difficulty);

            let currentBridge = 0;
            let score = 0;
            let timeLeft = 60;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🌉 Bridge Master Game</h3>
                    <div id="bridge-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Connect different blockchains efficiently</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; color: var(--warning);">
                                Time Left: <span id="bridge-time-left">${timeLeft}</span>s
                            </div>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Bridge from ${bridges[0].from} to ${bridges[0].to}</strong>
                            </div>
                            <div id="bridge-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${bridges.map((bridge, index) => 
                                    `<button class="btn" onclick="selectBridge(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${bridge.method} (${bridge.cost} ETH, ${bridge.time}min)</button>`
                                ).join('')}
                            </div>
                            <div id="bridge-score">Score: 0</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('bridge-time-left').textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endBridgeGame(score);
                }
            }, 1000);

            window.selectBridge = function(bridgeIndex) {
                const selectedBridge = bridges[bridgeIndex];
                const currentTarget = bridges[currentBridge];
                
                if (selectedBridge.from === currentTarget.from && selectedBridge.to === currentTarget.to) {
                    score++;
                    currentBridge = (currentBridge + 1) % bridges.length;
                    document.querySelector('#bridge-game-content strong').textContent = `Bridge from ${bridges[currentBridge].from} to ${bridges[currentBridge].to}`;
                    document.getElementById('bridge-score').textContent = `Score: ${score}`;
                    showToast('✅ Correct bridge!', 'success');
                } else {
                    showToast('❌ Wrong bridge!', 'error');
                }
            };

            function endBridgeGame(finalScore) {
                clearInterval(timer);
                const pointsEarned = Math.floor(finalScore * 25);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('bridge-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playSpeedGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showSpeedGame();
        }

        function showSpeedGame() {
            const intentChallenges = [
                {
                    scenario: "You want to swap 1 ETH for USDC at the best rate",
                    options: [
                        "I want 1 ETH → USDC at best rate",
                        "Execute swap on Uniswap",
                        "Check ETH price first",
                        "Wait for better rate"
                    ],
                    correct: 0,
                    explanation: "Express your intent, not the method!"
                },
                {
                    scenario: "You need to bridge 100 USDC from Ethereum to Polygon",
                    options: [
                        "I want 100 USDC on Polygon",
                        "Use Polygon bridge",
                        "Convert to MATIC first",
                        "Wait for lower fees"
                    ],
                    correct: 0,
                    explanation: "Anoma finds the best bridge automatically!"
                },
                {
                    scenario: "You want to stake 10 ATOM and earn rewards",
                    options: [
                        "I want to earn staking rewards on 10 ATOM",
                        "Delegate to validator X",
                        "Check validator commission",
                        "Wait for better rates"
                    ],
                    correct: 0,
                    explanation: "Express the goal, not the validator choice!"
                },
                {
                    scenario: "You want to vote on a governance proposal",
                    options: [
                        "I want to vote YES on proposal #123",
                        "Connect wallet to governance",
                        "Read proposal details",
                        "Wait for more info"
                    ],
                    correct: 0,
                    explanation: "Intent system handles the voting process!"
                },
                {
                    scenario: "You want to provide liquidity and earn fees",
                    options: [
                        "I want to earn fees from ETH/USDC liquidity",
                        "Add liquidity to Uniswap V3",
                        "Choose fee tier first",
                        "Wait for better APR"
                    ],
                    correct: 0,
                    explanation: "Express your earning intent, not the platform!"
                }
            ];

            let currentChallenge = 0;
            let score = 0;
            let timeLeft = 45;
            let gameRunning = false;
            let streak = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>⚡ Speed Intent Challenge</h3>
                    <div id="speed-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Choose the best intent expression!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                                <div style="font-size: 1.2rem; color: var(--warning);">
                                    ⏰ Time: <span id="speed-time-left">${timeLeft}</span>s
                            </div>
                                <div style="font-size: 1.2rem; color: var(--success);">
                                    🎯 Score: <span id="speed-score">${score}</span>
                            </div>
                                <div style="font-size: 1.2rem; color: var(--accent);">
                                    🔥 Streak: <span id="streak">${streak}</span>
                                </div>
                            </div>
                            
                            <div style="background: var(--bg); padding: 20px; border-radius: 15px; margin: 20px 0; border: 2px solid var(--border);">
                                <h4 style="color: var(--accent); margin-bottom: 15px;">Scenario:</h4>
                                <p id="scenario-text" style="font-size: 1.1rem; line-height: 1.5; margin-bottom: 20px;">${intentChallenges[0].scenario}</p>
                                
                                <h4 style="color: var(--success); margin-bottom: 15px;">Which is the best intent expression?</h4>
                                <div id="options-container" style="display: grid; gap: 10px;">
                                    ${intentChallenges[0].options.map((option, index) => `
                                        <button class="btn option-btn" onclick="selectOption(${index})" disabled
                                                style="background: var(--surface); color: var(--text); border: 2px solid var(--border); 
                                                       padding: 15px; text-align: left; border-radius: 8px; transition: all 0.3s ease;
                                                       opacity: 0.6; cursor: not-allowed;">
                                            ${option}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startSpeedGame()" id="start-speed-btn" 
                                        style="background: var(--success); font-size: 1.2rem; padding: 15px 30px;">
                                    🚀 Start Challenge
                                </button>
                            </div>
                            
                            <div id="feedback" style="margin: 20px 0; padding: 15px; border-radius: 8px; display: none;"></div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startSpeedGame = function() {
                console.log('Speed Intent game starting...');
                gameRunning = true;
                document.getElementById('start-speed-btn').style.display = 'none';
                
                // Enable option buttons
                document.querySelectorAll('.option-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
                
                // Timer
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('speed-time-left').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endSpeedGame(score);
                    }
                }, 1000);

                showToast('Challenge started! Choose the best intent expression!', 'info');
            };

            window.selectOption = function(selectedIndex) {
                if (!gameRunning) return;
                
                const challenge = intentChallenges[currentChallenge];
                const isCorrect = selectedIndex === challenge.correct;
                const feedback = document.getElementById('feedback');
                
                if (isCorrect) {
                    score += 10 + (streak * 2);
                    streak++;
                    feedback.style.background = 'rgba(16, 185, 129, 0.2)';
                    feedback.style.border = '2px solid var(--success)';
                    feedback.style.color = 'var(--success)';
                    feedback.innerHTML = `✅ Correct! ${challenge.explanation}`;
                    showToast('Great intent expression!', 'success');
                } else {
                    streak = 0;
                    feedback.style.background = 'rgba(239, 68, 68, 0.2)';
                    feedback.style.border = '2px solid var(--danger)';
                    feedback.style.color = 'var(--danger)';
                    feedback.innerHTML = `❌ Wrong! ${challenge.explanation}`;
                    showToast('Try again!', 'error');
                }
                
                feedback.style.display = 'block';
                
                // Update score display
                document.getElementById('speed-score').textContent = score;
                document.getElementById('streak').textContent = streak;
                
                // Move to next challenge after delay
                setTimeout(() => {
                    currentChallenge = (currentChallenge + 1) % intentChallenges.length;
                    if (currentChallenge === 0) {
                        // Shuffle challenges
                        intentChallenges.sort(() => Math.random() - 0.5);
                    }
                    loadNextChallenge();
                }, 2000);
            };

            window.loadNextChallenge = function() {
                const challenge = intentChallenges[currentChallenge];
                document.getElementById('scenario-text').textContent = challenge.scenario;
                
                const optionsContainer = document.getElementById('options-container');
                optionsContainer.innerHTML = challenge.options.map((option, index) => `
                    <button class="btn option-btn" onclick="selectOption(${index})" 
                            style="background: var(--surface); color: var(--text); border: 2px solid var(--border); 
                                   padding: 15px; text-align: left; border-radius: 8px; transition: all 0.3s ease;
                                   opacity: ${gameRunning ? '1' : '0.6'}; cursor: ${gameRunning ? 'pointer' : 'not-allowed'};"
                            ${!gameRunning ? 'disabled' : ''}>
                        ${option}
                    </button>
                `).join('');
                
                document.getElementById('feedback').style.display = 'none';
            };

            window.endSpeedGame = function(finalScore) {
                gameRunning = false;
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('speed-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Challenge Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0; color: var(--accent);">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0; color: var(--success);">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0; color: var(--muted);">
                            You've mastered the art of expressing intents! 🎯
                        </div>
                        <button class="btn" onclick="closeModal()" style="background: var(--accent); font-size: 1.1rem; padding: 15px 30px;">
                            Close
                        </button>
                    </div>
                `;
            };
        }

        function playDetectiveGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showDetectiveGame();
        }

        function showDetectiveGame() {
            const scenarios = [
                {
                    situation: "User wants to swap 100 USDC for ETH with maximum privacy",
                    options: [
                        "Use public DEX with high fees",
                        "Use Anoma intent system with ZK proofs",
                        "Use centralized exchange",
                        "Use multiple small transactions"
                    ],
                    correct: 1,
                    explanation: "Anoma's intent system with ZK proofs provides maximum privacy while maintaining efficiency"
                },
                {
                    situation: "User wants to vote on governance without revealing their choice",
                    options: [
                        "Vote publicly",
                        "Use zero-knowledge proof voting",
                        "Skip voting",
                        "Use email verification"
                    ],
                    correct: 1,
                    explanation: "ZK proof voting allows participation while maintaining privacy"
                }
            ];

            let currentScenario = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🔍 Intent Detective Game</h3>
                    <div id="detective-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Analyze complex intents and find the best solution</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Situation:</strong> ${scenarios[0].situation}
                            </div>
                            <div id="detective-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${scenarios[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="detective-score">Score: 0/2</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectDetectiveOption = function(selectedIndex) {
                const correct = scenarios[currentScenario].correct;
                
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct analysis!', 'success');
                } else {
                    showToast('❌ Wrong analysis!', 'error');
                }

                currentScenario++;
                if (currentScenario < scenarios.length) {
                    document.querySelector('#detective-game-content strong').textContent = `Situation: ${scenarios[currentScenario].situation}`;
                    document.getElementById('detective-options').innerHTML = scenarios[currentScenario].options.map((option, index) => 
                        `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('detective-score').textContent = `Score: ${score}/${currentScenario}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 20);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('detective-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/2</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function showGuardianGame() {
            const scenarios = [
                {
                    situation: "User wants to make a private transaction",
                    options: [
                        "Use public blockchain",
                        "Use zero-knowledge proof + private execution",
                        "Use centralized exchange",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "ZK proofs enable private transactions while maintaining blockchain security"
                },
                {
                    situation: "User wants to prove they own an NFT without showing which one",
                    options: [
                        "Show the NFT publicly",
                        "Use selective disclosure with ZK proof",
                        "Use email verification",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "Selective disclosure allows proving ownership without revealing specific details"
                }
            ];

            let currentScenario = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🛡️ Privacy Guardian Game</h3>
                    <div id="guardian-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Protect user privacy using Anoma's ZK technology</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Situation:</strong> ${scenarios[0].situation}
                            </div>
                            <div id="guardian-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${scenarios[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="guardian-score">Score: 0/2</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectGuardianOption = function(selectedIndex) {
                const correct = scenarios[currentScenario].correct;
                
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct protection!', 'success');
                } else {
                    showToast('❌ Wrong protection!', 'error');
                }

                currentScenario++;
                if (currentScenario < scenarios.length) {
                    document.querySelector('#guardian-game-content strong').textContent = `Situation: ${scenarios[currentScenario].situation}`;
                    document.getElementById('guardian-options').innerHTML = scenarios[currentScenario].options.map((option, index) => 
                        `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('guardian-score').textContent = `Score: ${score}/${currentScenario}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 20);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('guardian-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/2</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function showPuzzleGame() {
            const puzzles = [
                {
                    title: "ZK Proof Components",
                    description: "Drag and drop to arrange ZK proof components in correct order",
                    pieces: ["Secret Input", "Proof Generation", "Verification", "Public Output"],
                    solution: ["Secret Input", "Proof Generation", "Verification", "Public Output"]
                }
            ];

            let currentPuzzle = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Privacy Puzzle (Visual)</h3>
                    <div id="puzzle-visual-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>${puzzles[0].title}</h4>
                            <p>${puzzles[0].description}</p>
                            <div id="puzzle-drop-zone" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 20px 0; min-height: 200px; border: 2px dashed var(--border); border-radius: 10px; padding: 20px;">
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                            </div>
                            <div id="puzzle-pieces" style="display: flex; gap: 10px; justify-content: center; margin: 20px 0;">
                                ${puzzles[0].pieces.map((piece, index) => 
                                    `<div class="puzzle-piece" draggable="true" data-piece="${piece}" style="background: var(--accent); color: white; padding: 10px 20px; border-radius: 5px; cursor: grab; user-select: none;">${piece}</div>`
                                ).join('')}
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="checkPuzzleSolution()">Check Solution</button>
                                <button class="btn" onclick="resetPuzzle()" style="background: var(--danger);">Reset</button>
                            </div>
                            <div id="puzzle-score">Score: 0</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Add drag and drop functionality
            const pieces = document.querySelectorAll('.puzzle-piece');
            const slots = document.querySelectorAll('.drop-slot');

            pieces.forEach(piece => {
                piece.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', this.dataset.piece);
                    this.style.opacity = '0.5';
                });

                piece.addEventListener('dragend', function(e) {
                    this.style.opacity = '1';
                });
            });

            slots.forEach(slot => {
                slot.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.background = 'var(--accent)';
                });

                slot.addEventListener('dragleave', function(e) {
                    this.style.background = 'var(--surface)';
                });

                slot.addEventListener('drop', function(e) {
                    e.preventDefault();
                    const piece = e.dataTransfer.getData('text/plain');
                    this.textContent = piece;
                    this.dataset.piece = piece;
                    this.style.background = 'var(--success)';
                    this.style.color = 'white';
                });
            });

            window.checkPuzzleSolution = function() {
                const placedPieces = Array.from(slots).map(slot => slot.dataset.piece);
                const solution = puzzles[currentPuzzle].solution;
                
                let correct = 0;
                placedPieces.forEach((piece, index) => {
                    if (piece === solution[index]) {
                        correct++;
                    }
                });

                if (correct === solution.length) {
                    score++;
                    showToast('🎉 Puzzle solved!', 'success');
                    document.getElementById('puzzle-score').textContent = `Score: ${score}`;
                } else {
                    showToast('❌ Try again!', 'error');
                }
            };

            window.resetPuzzle = function() {
                slots.forEach(slot => {
                    slot.textContent = 'Drop here';
                    slot.dataset.piece = '';
                    slot.style.background = 'var(--surface)';
                    slot.style.color = 'var(--muted)';
                });
            };
        }

        function showAnomaRunner() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            
            let score = 0;
            let timeLeft = 30;
            let gameRunning = true;
            let playerX = 50;
            let playerY = 200;
            let obstacles = [];
            let tokens = [];
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏃 Anoma Runner Game</h3>
                    <div id="runner-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Run and collect Anoma tokens!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="runner-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="runner-score">${score}</span></div>
                            </div>
                            <div id="runner-board" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden;">
                                <div id="runner-player" style="position: absolute; left: ${playerX}px; top: ${playerY}px; width: 30px; height: 30px; background: var(--accent); border-radius: 50%; font-size: 1.5rem; display: flex; align-items: center; justify-content: center;">🏃</div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startRunnerGame()" id="start-runner-btn" style="background: var(--success);">Start Game</button>
                                <button class="btn" onclick="jump()" id="jump-btn" disabled style="background: var(--accent);">Jump (Space)</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                Use Space key or click Jump to avoid obstacles and collect intent pieces!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            function startRunnerGame() {
                gameRunning = true;
                document.getElementById('start-runner-btn').disabled = true;
                document.getElementById('jump-btn').disabled = false;
                
                // Timer
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('runner-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endRunnerGame(score);
                    }
                }, 1000);

                // Game loop
                const gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    
                    moveObstacles();
                    checkCollisions();
                }, 50);

                // Keyboard controls
                document.addEventListener('keydown', handleKeyPress);
            }

            function handleKeyPress(e) {
                if (e.code === 'Space' && gameRunning) {
                    e.preventDefault();
                    jump();
                }
            }

            function jump() {
                if (!gameRunning) return;
                playerY = Math.max(50, playerY - 50);
                setTimeout(() => {
                    playerY = Math.min(350, playerY + 50);
                }, 300);
                soundSystem.playSound('jump');
            }

            function moveObstacles() {
                // Move existing obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 3;
                    if (obstacle.x < -50) {
                        obstacles.splice(index, 1);
                    }
                });

                // Spawn new obstacles
                if (Math.random() < 0.02) {
                    obstacles.push({
                        x: 600,
                        y: 300,
                        width: 30,
                        height: 50
                    });
                }

                // Spawn tokens
                if (Math.random() < 0.03) {
                    tokens.push({
                        x: 600,
                        y: Math.random() * 300 + 50,
                        type: Math.random() < 0.5 ? '🦐' : '💎'
                    });
                }

                // Move tokens
                tokens.forEach((token, index) => {
                    token.x -= 2;
                    if (token.x < -50) {
                        tokens.splice(index, 1);
                    }
                });

                // Check collisions
                checkCollisions();
                
                // Render
                renderRunnerGame();
            }

            function checkCollisions() {
                const playerX = 50;
                const playerWidth = 30;
                const playerHeight = 30;

                // Check obstacle collisions
                obstacles.forEach((obstacle, index) => {
                    const obstacleX = obstacle.x;
                    const obstacleY = 300 - obstacle.height;
                    const obstacleWidth = 30;
                    const obstacleHeight = obstacle.height;

                    if (playerX < obstacleX + obstacleWidth &&
                        playerX + playerWidth > obstacleX &&
                        playerY + playerHeight > obstacleY) {
                        // Collision detected
                        endRunnerGame(score);
                        return;
                    }
                });

                // Check token collisions
                tokens.forEach((token, index) => {
                    const itemX = token.x;
                    const itemY = token.y;
                    const itemSize = 20;

                    if (playerX < itemX + itemSize &&
                        playerX + playerWidth > itemX &&
                        playerY < itemY + itemSize &&
                        playerY + playerHeight > itemY) {
                        // Item collected
                        tokens.splice(index, 1);
                        score += 50;
                        soundSystem.playSound('collect');
                        particleSystem.createCollectEffect(itemX + itemSize/2, itemY + itemSize/2);
                        showToast('💎 Token collected!', 'success');
                    }
                });
            }

            function renderRunnerGame() {
                const board = document.getElementById('runner-board');
                const player = document.getElementById('runner-player');
                
                if (player) {
                    player.style.left = playerX + 'px';
                    player.style.top = playerY + 'px';
                }

                // Clear existing elements
                const existingObstacles = board.querySelectorAll('.runner-obstacle');
                const existingTokens = board.querySelectorAll('.runner-token');
                existingObstacles.forEach(el => el.remove());
                existingTokens.forEach(el => el.remove());
                
                // Render obstacles
                obstacles.forEach(obstacle => {
                    const obstacleEl = document.createElement('div');
                    obstacleEl.className = 'runner-obstacle';
                    obstacleEl.style.position = 'absolute';
                    obstacleEl.style.left = obstacle.x + 'px';
                    obstacleEl.style.top = (300 - obstacle.height) + 'px';
                    obstacleEl.style.width = obstacle.width + 'px';
                    obstacleEl.style.height = obstacle.height + 'px';
                    obstacleEl.style.background = 'var(--danger)';
                    obstacleEl.style.borderRadius = '5px';
                    board.appendChild(obstacleEl);
                });

                // Render tokens
                tokens.forEach(token => {
                    const tokenEl = document.createElement('div');
                    tokenEl.className = 'runner-token';
                    tokenEl.style.position = 'absolute';
                    tokenEl.style.left = token.x + 'px';
                    tokenEl.style.top = token.y + 'px';
                    tokenEl.style.fontSize = '1.5rem';
                    tokenEl.style.animation = 'float 1s ease-in-out infinite';
                    tokenEl.textContent = token.type;
                    board.appendChild(tokenEl);
                });

                // Update score
                document.getElementById('runner-score').textContent = score;
            }

            function endRunnerGame(finalScore) {
                gameRunning = false;
                clearInterval(gameLoop);
                clearInterval(timer);
                
                const pointsEarned = Math.floor(finalScore * 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('runner-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playAnomaRunner() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showAnomaRunner();
        }

        function showAnomaRunner() {
            const cases = [
                {
                    scenario: "User wants to swap 1 ETH for USDC but gas fees are too high",
                    options: [
                        "Wait for lower gas fees",
                        "Use Anoma intent system to find optimal path",
                        "Use centralized exchange",
                        "Skip the transaction"
                    ],
                    correct: 1,
                    explanation: "Anoma's intent system finds the most cost-effective execution path across all available options"
                },
                {
                    scenario: "User needs to vote on governance but wants to keep their choice private",
                    options: [
                        "Vote publicly",
                        "Use zero-knowledge proof voting",
                        "Skip voting",
                        "Use email verification"
                    ],
                    correct: 1,
                    explanation: "ZK proofs allow proving you voted without revealing your choice"
                },
                {
                    scenario: "User wants to bridge assets from Ethereum to Polygon with minimal slippage",
                    options: [
                        "Use direct bridge contract",
                        "Use Anoma cross-chain intent",
                        "Use centralized exchange",
                        "Wait for better rates"
                    ],
                    correct: 1,
                    explanation: "Anoma's cross-chain intents find the best bridge with optimal execution"
                }
            ];

            let currentCase = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🔍 Intent Detective Game</h3>
                    <div id="detective-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Case ${currentCase + 1}/3</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>${cases[0].scenario}</strong>
                            </div>
                            <div id="detective-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${cases[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="detective-score">Score: 0/3</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectDetectiveOption = function(selectedIndex) {
                const correct = cases[currentCase].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct solution!', 'success');
                } else {
                    showToast('❌ Wrong approach!', 'error');
                }

                currentCase++;
                if (currentCase < cases.length) {
                    document.querySelector('h4').textContent = `Case ${currentCase + 1}/3`;
                    document.querySelector('#detective-game-content strong').textContent = cases[currentCase].scenario;
                    document.getElementById('detective-options').innerHTML = cases[currentCase].options.map((option, index) => 
                        `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('detective-score').textContent = `Score: ${score}/${currentCase}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 20);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('detective-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 All Cases Solved!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/3</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playGuardianGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showGuardianGame();
        }

        function showGuardianGame() {
            const scenarios = [
                {
                    situation: "User wants to vote on a governance proposal privately",
                    options: [
                        "Use public voting",
                        "Use zero-knowledge proof",
                        "Use email verification",
                        "Skip verification"
                    ],
                    correct: 1,
                    explanation: "Zero-knowledge proofs allow proving possession of voting rights without revealing identity"
                },
                {
                    situation: "User wants to make a private transaction",
                    options: [
                        "Use public blockchain",
                        "Use zero-knowledge proof + private execution",
                        "Use centralized exchange",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "ZK proofs enable private transactions while maintaining blockchain security"
                },
                {
                    situation: "User wants to prove they own an NFT without showing which one",
                    options: [
                        "Show the NFT publicly",
                        "Use selective disclosure with ZK proof",
                        "Use email verification",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "Selective disclosure allows proving ownership without revealing specific details"
                }
            ];

            let currentScenario = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🛡️ Privacy Guardian Game</h3>
                    <div id="guardian-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Protect user privacy using Anoma's ZK technology</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Situation:</strong> ${scenarios[0].situation}
                            </div>
                            <div id="guardian-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${scenarios[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="guardian-score">Score: 0/3</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectGuardianOption = function(selectedIndex) {
                const correct = scenarios[currentScenario].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct privacy solution!', 'success');
                } else {
                    showToast('❌ Wrong approach!', 'error');
                }

                currentScenario++;
                if (currentScenario < scenarios.length) {
                    document.querySelector('#guardian-game-content strong').textContent = scenarios[currentScenario].situation;
                    document.getElementById('guardian-options').innerHTML = scenarios[currentScenario].options.map((option, index) => 
                        `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('guardian-score').textContent = `Score: ${score}/${currentScenario}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 15);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('guardian-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/3</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playBridgeGame() {
            if (gameState.points < 40) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 40;
            gameState.gamesPlayed++;
            updateStats();
            showBridgeGame();
        }

        function showBridgeGame() {
            const bridges = [
                { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 },
                { from: 'Arbitrum', to: 'Optimism', method: 'Synapse Protocol', cost: 0.03, time: 4 },
                { from: 'Ethereum', to: 'BSC', method: 'Binance Bridge', cost: 0.08, time: 8 }
            ];

            let currentBridge = 0;
            let score = 0;
            let timeLeft = 60;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🌉 Bridge Master Game</h3>
                    <div id="bridge-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Connect different blockchains efficiently</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; color: var(--warning);">
                                Time Left: <span id="bridge-time-left">${timeLeft}</span>s
                            </div>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Bridge from ${bridges[0].from} to ${bridges[0].to}</strong>
                            </div>
                            <div id="bridge-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${bridges.map((bridge, index) => 
                                    `<button class="btn" onclick="selectBridge(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${bridge.method} (${bridge.cost} ETH, ${bridge.time}min)</button>`
                                ).join('')}
                            </div>
                            <div id="bridge-score">Score: 0</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('bridge-time-left').textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endBridgeGame(score);
                }
            }, 1000);

            window.selectBridge = function(bridgeIndex) {
                const selectedBridge = bridges[bridgeIndex];
                const currentTarget = bridges[currentBridge];
                
                if (selectedBridge.from === currentTarget.from && selectedBridge.to === currentTarget.to) {
                    score++;
                    currentBridge = (currentBridge + 1) % bridges.length;
                    document.querySelector('#bridge-game-content strong').textContent = `Bridge from ${bridges[currentBridge].from} to ${bridges[currentBridge].to}`;
                    document.getElementById('bridge-score').textContent = `Score: ${score}`;
                    showToast('✅ Correct bridge!', 'success');
                } else {
                    showToast('❌ Wrong bridge!', 'error');
                }
            };

            function endBridgeGame(finalScore) {
                clearInterval(timer);
                const pointsEarned = Math.floor(finalScore * 25);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('bridge-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playBuilderGame() {
            if (gameState.points < 50) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 50;
            gameState.gamesPlayed++;
            updateStats();
            showBuilderGame();
        }

        function showBuilderGame() {
            const components = [
                { type: 'action', text: 'Swap', cost: 10 },
                { type: 'action', text: 'Bridge', cost: 15 },
                { type: 'action', text: 'Vote', cost: 5 },
                { type: 'action', text: 'Stake', cost: 20 },
                { type: 'token', text: 'ETH', cost: 5 },
                { type: 'token', text: 'USDC', cost: 5 },
                { type: 'token', text: 'USDT', cost: 5 },
                { type: 'amount', text: '1', cost: 2 },
                { type: 'amount', text: '100', cost: 2 },
                { type: 'amount', text: '1000', cost: 2 },
                { type: 'chain', text: 'Ethereum', cost: 8 },
                { type: 'chain', text: 'Polygon', cost: 8 },
                { type: 'chain', text: 'Arbitrum', cost: 8 }
            ];

            let budget = 50;
            let selectedComponents = [];
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 800px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Builder Game</h3>
                    <div id="builder-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Build complex intents with limited budget</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Budget: <span id="budget">${budget}</span> points</div>
                                <div>Score: <span id="builder-score">${score}</span></div>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                                <div>
                                    <h5>Available Components:</h5>
                                    <div id="components-list" style="display: grid; gap: 5px; max-height: 300px; overflow-y: auto;">
                                        ${components.map((comp, index) => 
                                            `<button class="btn" onclick="addComponent(${index})" style="font-size: 0.9rem; padding: 8px 12px; background: var(--surface); color: var(--text); border: 1px solid var(--border);">${comp.text} (${comp.cost})</button>`
                                        ).join('')}
                                    </div>
                                </div>
                                <div>
                                    <h5>Your Intent:</h5>
                                    <div id="intent-display" style="min-height: 200px; background: var(--bg); border: 2px solid var(--border); border-radius: 10px; padding: 15px; margin: 10px 0;">
                                        <div style="color: var(--muted); text-align: center;">No components selected</div>
                                    </div>
                                    <div style="margin: 10px 0;">
                                        <button class="btn" onclick="buildIntent()" style="background: var(--success);">Build Intent</button>
                                        <button class="btn" onclick="clearIntent()" style="background: var(--danger);">Clear</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.addComponent = function(index) {
                const component = components[index];
                if (budget >= component.cost) {
                    budget -= component.cost;
                    selectedComponents.push(component);
                    updateDisplay();
                } else {
                    showToast('Not enough budget!', 'error');
                }
            };

            window.buildIntent = function() {
                if (selectedComponents.length === 0) {
                    showToast('Select at least one component!', 'error');
                    return;
                }

                const intent = buildIntentText(selectedComponents);
                const points = calculateIntentScore(selectedComponents);
                score += points;
                
                showToast(`Intent built! +${points} points`, 'success');
                
                // Reset for next round
                budget = 50;
                selectedComponents = [];
                updateDisplay();
            };

            window.clearIntent = function() {
                budget = 50;
                selectedComponents = [];
                updateDisplay();
            };

            function updateDisplay() {
                document.getElementById('budget').textContent = budget;
                document.getElementById('builder-score').textContent = score;
                
                const intentDisplay = document.getElementById('intent-display');
                if (selectedComponents.length === 0) {
                    intentDisplay.innerHTML = '<div style="color: var(--muted); text-align: center;">No components selected</div>';
                } else {
                    intentDisplay.innerHTML = selectedComponents.map(comp => 
                        `<span style="background: var(--accent); color: white; padding: 4px 8px; border-radius: 4px; margin: 2px; display: inline-block;">${comp.text}</span>`
                    ).join('');
                }
            }

            function buildIntentText(components) {
                const actions = components.filter(c => c.type === 'action');
                const tokens = components.filter(c => c.type === 'token');
                const amounts = components.filter(c => c.type === 'amount');
                const chains = components.filter(c => c.type === 'chain');
                
                let intent = 'I want to ';
                if (actions.length > 0) {
                    intent += actions.map(a => a.text.toLowerCase()).join(' and ');
                }
                if (amounts.length > 0 && tokens.length > 0) {
                    intent += ` ${amounts[0].text} ${tokens[0].text}`;
                }
                if (chains.length > 0) {
                    intent += ` on ${chains[0].text}`;
                }
                
                return intent;
            }

            function calculateIntentScore(components) {
                let score = 0;
                const types = components.map(c => c.type);
                
                // Base score for each component
                score += components.length * 5;
                
                // Bonus for combinations
                if (types.includes('action') && types.includes('token')) score += 20;
                if (types.includes('action') && types.includes('chain')) score += 15;
                if (types.includes('amount') && types.includes('token')) score += 10;
                
                // Bonus for multiple actions
                const actionCount = types.filter(t => t === 'action').length;
                if (actionCount > 1) score += actionCount * 10;
                
                return score;
            }
        }

        function playTowerDefense() {
            if (gameState.points < 60) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 60;
            gameState.gamesPlayed++;
            updateStats();
            showTowerDefense();
        }

        function showTowerDefense() {
            let wave = 1;
            let score = 200;
            let health = 100;
            let towers = [];
            let enemies = [];
            let projectiles = [];
            let gameRunning = false;
            let selectedTower = null;
            let gameSpeed = 1;
            let enemySpawnTimer = 0;
            let waveEnemiesSpawned = 0;
            let waveEnemiesTotal = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 98%; max-width: 1200px; height: 90vh; overflow-y: auto;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎮 Intent Tower Defense - Defend Anoma!</h3>
                    <div id="tower-defense-content">
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent);">Wave ${wave}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Enemies: ${waveEnemiesSpawned}/${waveEnemiesTotal}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--danger);">❤️ ${health}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Health</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--success);">💰 ${score}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Score</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--warning);">⚡ ${gameSpeed}x</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Speed</div>
                            </div>
                        </div>
                        
                        <div id="game-board" onclick="handleGameBoardClick(event)" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 3px solid var(--accent); border-radius: 15px; position: relative; overflow: hidden; cursor: crosshair; margin: 20px 0;">
                            <!-- Game path -->
                            <div id="path" style="position: absolute; top: 50%; left: 0; width: 100%; height: 40px; background: linear-gradient(90deg, rgba(0,212,255,0.3) 0%, rgba(0,212,255,0.1) 50%, rgba(0,212,255,0.3) 100%); transform: translateY(-50%); border-radius: 20px;"></div>
                            
                            <!-- Start and end points -->
                            <div style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--danger); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🚪</div>
                            <div style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🏠</div>
                            
                            <!-- Tower placement grid -->
                            <div id="tower-grid" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <h4>🛡️ Defense Tools - Click to select, then click on the field to place:</h4>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; padding: 15px; background: rgba(0, 0, 0, 0.05); border-radius: 10px;">
                                <button class="btn tower-btn" onclick="selectTower('ZK-Proof')" data-type="ZK-Proof" style="background: #10b981; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">🛡️</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">ZK-Proof</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 30 | Damage: 25 | Range: 80</div>
                                </button>
                                <button class="btn tower-btn" onclick="selectTower('Intent-Solver')" data-type="Intent-Solver" style="background: #3b82f6; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">⚡</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">Intent Solver</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 50 | Damage: 35 | Range: 100</div>
                                </button>
                                <button class="btn tower-btn" onclick="selectTower('Privacy-Guard')" data-type="Privacy-Guard" style="background: #f59e0b; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(245, 158, 11, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">🔐</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">Privacy Guard</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 40 | Damage: 30 | Range: 70</div>
                                </button>
                                <button class="btn tower-btn" onclick="selectTower('Cross-Chain')" data-type="Cross-Chain" style="background: #ef4444; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">🌉</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">Cross-Chain</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 60 | Damage: 45 | Range: 90</div>
                                </button>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 15px; margin: 25px 0; justify-content: center; flex-wrap: wrap; padding: 20px; background: rgba(0, 0, 0, 0.1); border-radius: 10px; min-height: 80px; align-items: center;">
                            <button class="btn" onclick="startWave()" id="wave-btn" style="background: #10b981; color: white; font-size: 1.3rem; padding: 18px 35px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 6px 12px rgba(16, 185, 129, 0.4); transition: all 0.3s ease; min-width: 180px;">🚀 Start Wave ${wave}</button>
                            <button class="btn" onclick="pauseGame()" id="pause-btn" style="background: #f59e0b; color: white; font-size: 1.3rem; padding: 18px 35px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 6px 12px rgba(245, 158, 11, 0.4); transition: all 0.3s ease; min-width: 150px;">⏸️ Pause</button>
                            <button class="btn" onclick="changeSpeed()" id="speed-btn" style="background: #3b82f6; color: white; font-size: 1.3rem; padding: 18px 35px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 6px 12px rgba(59, 130, 246, 0.4); transition: all 0.3s ease; min-width: 150px;">⚡ Speed ${gameSpeed}x</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Add hover effects for buttons
            setTimeout(() => {
                const buttons = modal.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    btn.addEventListener('mouseenter', function() {
                        this.style.transform = 'translateY(-2px)';
                        this.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3)';
                    });
                    btn.addEventListener('mouseleave', function() {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
                    });
                });
            }, 100);

            let gameInterval;
            let enemyInterval;

            // Tower selection and placement
            window.selectTower = function(type) {
                console.log('Selecting tower:', type);
                selectedTower = type;
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.style.border = '3px solid transparent';
                    btn.style.transform = 'scale(1)';
                });
                const selectedBtn = document.querySelector(`[data-type="${type}"]`);
                if (selectedBtn) {
                    selectedBtn.style.border = '3px solid #00ff88';
                    selectedBtn.style.transform = 'scale(1.05)';
                    selectedBtn.style.boxShadow = '0 8px 16px rgba(0, 255, 136, 0.4)';
                    console.log('Tower selected:', type);
                } else {
                    console.error('Tower button not found:', type);
                }
                soundSystem.playSound('click');
                showToast(`${type} selected! Click on the field to place.`, 'info');
            };

            // Click to place tower - bind after modal is added to DOM
            setTimeout(() => {
                const gameBoard = document.getElementById('game-board');
                if (gameBoard) {
                    // Remove any existing listeners
                    gameBoard.removeEventListener('click', handleGameBoardClick);
                    
                    // Add new listener
                    gameBoard.addEventListener('click', handleGameBoardClick);
                    console.log('Game board click listener bound');
                } else {
                    console.error('Game board element not found!');
                }
            }, 100);

            window.handleGameBoardClick = function(e) {
                console.log('Game board clicked, selectedTower:', selectedTower);
                if (!selectedTower) {
                    showToast('Please select a tower first!', 'error');
                    return;
                }
                
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                console.log('Click position:', x, y);
                
                // Check if position is valid (not on path)
                const pathY = rect.height / 2;
                const pathHeight = 40;
                if (Math.abs(y - pathY) < pathHeight / 2 + 30) {
                    showToast('Cannot place tower on the path!', 'error');
                    return;
                }
                
                // Check if position is too close to existing towers
                const minDistance = 60;
                const tooClose = towers.some(tower => {
                    const distance = Math.sqrt(Math.pow(tower.x - x, 2) + Math.pow(tower.y - y, 2));
                    return distance < minDistance;
                });
                
                if (tooClose) {
                    showToast('Too close to existing tower!', 'error');
                    return;
                }
                
                placeTower(selectedTower, x, y);
            };

            function placeTower(type, x, y) {
                console.log('Placing tower:', type, 'at position:', x, y);
                const cost = getTowerCost(type);
                if (score < cost) {
                    showToast('Not enough points!', 'error');
                    return;
                }
                
                const tower = {
                    type: type,
                    x: x,
                    y: y,
                    cost: cost,
                    damage: getTowerDamage(type),
                    range: getTowerRange(type),
                    lastShot: 0,
                    level: 1
                };
                
                towers.push(tower);
                score -= cost;
                selectedTower = null; // Reset selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.style.border = '2px solid transparent';
                });
                updateTowerDefenseDisplay();
                renderGame();
                soundSystem.playSound('success');
                showToast(`${type} tower placed!`, 'success');
            }

            window.startWave = function() {
                console.log('Starting wave...');
                if (!gameRunning) {
                    gameRunning = true;
                    startGameLoop();
                    soundSystem.playSound('gameStart');
                    console.log('Game loop started');
                }
                
                waveEnemiesTotal = 5 + wave * 2;
                waveEnemiesSpawned = 0;
                enemySpawnTimer = 0;
                
                document.getElementById('wave-btn').disabled = true;
                document.getElementById('wave-btn').textContent = `Wave ${wave} In Progress...`;
                showToast(`Wave ${wave} started! ${waveEnemiesTotal} enemies incoming!`, 'info');
                console.log(`Wave ${wave} started with ${waveEnemiesTotal} enemies`);
            };

            window.pauseGame = function() {
                gameRunning = !gameRunning;
                const btn = document.getElementById('pause-btn');
                btn.textContent = gameRunning ? '⏸️ Pause' : '▶️ Resume';
                btn.style.background = gameRunning ? 'var(--warning)' : 'var(--success)';
                soundSystem.playSound('click');
            };

            window.changeSpeed = function() {
                gameSpeed = gameSpeed >= 3 ? 1 : gameSpeed + 1;
                document.getElementById('speed-btn').textContent = `⚡ Speed ${gameSpeed}x`;
                soundSystem.playSound('click');
            };

            window.testPlaceTower = function() {
                console.log('Test place tower clicked');
                selectedTower = 'ZK-Proof';
                placeTower('ZK-Proof', 200, 100);
            };

            // Add click test to game board
            window.testGameBoardClick = function() {
                console.log('Testing game board click...');
                const gameBoard = document.getElementById('game-board');
                if (gameBoard) {
                    console.log('Game board found, adding test click');
                    gameBoard.style.border = '3px solid red';
                    setTimeout(() => {
                        gameBoard.style.border = '3px solid var(--accent)';
                    }, 1000);
                } else {
                    console.error('Game board not found!');
                }
            };

            function getTowerCost(type) {
                const costs = { 'ZK-Proof': 30, 'Intent-Solver': 50, 'Privacy-Guard': 40, 'Cross-Chain': 60 };
                return costs[type] || 30;
            }

            function getTowerDamage(type) {
                const damages = { 'ZK-Proof': 25, 'Intent-Solver': 35, 'Privacy-Guard': 30, 'Cross-Chain': 45 };
                return damages[type] || 25;
            }

            function getTowerRange(type) {
                const ranges = { 'ZK-Proof': 80, 'Intent-Solver': 100, 'Privacy-Guard': 70, 'Cross-Chain': 90 };
                return ranges[type] || 80;
            }

            function getTowerIcon(type) {
                const icons = { 'ZK-Proof': '🛡️', 'Intent-Solver': '⚡', 'Privacy-Guard': '🔐', 'Cross-Chain': '🌉' };
                return icons[type] || '🛡️';
            }

            function spawnEnemies() {
                if (waveEnemiesSpawned >= waveEnemiesTotal) return;
                
                const enemyTypes = [
                    { name: 'Malicious Intent', icon: '👹', health: 40, speed: 1.5, reward: 15, color: '#ff6b6b' },
                    { name: 'Privacy Breach', icon: '🕵️', health: 60, speed: 1.2, reward: 20, color: '#4ecdc4' },
                    { name: 'MEV Attack', icon: '💰', health: 80, speed: 1.0, reward: 25, color: '#ffe66d' },
                    { name: 'Front-running', icon: '🏃', health: 30, speed: 2.0, reward: 12, color: '#a8e6cf' },
                    { name: 'Sybil Attack', icon: '👥', health: 100, speed: 0.8, reward: 30, color: '#ff8b94' }
                ];
                
                const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const gameBoard = document.getElementById('game-board');
                const boardHeight = gameBoard ? gameBoard.offsetHeight : 500;
                const pathY = boardHeight / 2; // Center of the game board
                
                const enemy = {
                    type: enemyType.name,
                    icon: enemyType.icon,
                    x: -30,
                    y: pathY, // Center of path
                    health: enemyType.health + wave * 15,
                    maxHealth: enemyType.health + wave * 15,
                    speed: enemyType.speed + wave * 0.1,
                    reward: enemyType.reward + wave * 3,
                    color: enemyType.color,
                    id: Date.now() + Math.random()
                };
                
                enemies.push(enemy);
                waveEnemiesSpawned++;
                updateTowerDefenseDisplay();
                soundSystem.playSound('click');
            }

            function startGameLoop() {
                gameInterval = setInterval(() => {
                    if (!gameRunning) return;
                    
                    // Spawn enemies
                    enemySpawnTimer += gameSpeed;
                    if (enemySpawnTimer >= 60 && waveEnemiesSpawned < waveEnemiesTotal) {
                        spawnEnemies();
                        enemySpawnTimer = 0;
                    }
                    
                    // Move enemies
                    enemies.forEach((enemy, index) => {
                        enemy.x += enemy.speed * gameSpeed;
                        
                        if (enemy.x > 950) {
                            health -= Math.max(1, Math.floor(10 - wave * 0.5));
                            enemies.splice(index, 1);
                            soundSystem.playSound('error');
                            particleSystem.createExplosion(950, enemy.y, 20);
                            
                            if (health <= 0) {
                                endTowerDefense();
                            }
                        }
                    });

                    // Tower attacks
                    const currentTime = Date.now();
                    towers.forEach(tower => {
                        if (currentTime - tower.lastShot < 1000) return; // 1 second cooldown
                        
                        let target = null;
                        let minDistance = tower.range;
                        
                        enemies.forEach(enemy => {
                            const distance = Math.sqrt(Math.pow(tower.x - enemy.x, 2) + Math.pow(tower.y - enemy.y, 2));
                            if (distance <= tower.range && distance < minDistance) {
                                target = enemy;
                                minDistance = distance;
                            }
                        });
                        
                        if (target) {
                            tower.lastShot = currentTime;
                            createProjectile(tower, target);
                            soundSystem.playSound('click');
                        }
                    });

                    // Move projectiles
                    projectiles.forEach((projectile, index) => {
                        const dx = projectile.target.x - projectile.x;
                        const dy = projectile.target.y - projectile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // Hit target
                            projectile.target.health -= projectile.damage;
                            particleSystem.createExplosion(projectile.x, projectile.y, 15);
                            
                            if (projectile.target.health <= 0) {
                                score += projectile.target.reward;
                                enemies.splice(enemies.indexOf(projectile.target), 1);
                                soundSystem.playSound('collect');
                                particleSystem.createExplosion(projectile.target.x, projectile.target.y, 25);
                            }
                            
                            projectiles.splice(index, 1);
                        } else {
                            projectile.x += (dx / distance) * projectile.speed * gameSpeed;
                            projectile.y += (dy / distance) * projectile.speed * gameSpeed;
                        }
                    });

                    updateTowerDefenseDisplay();
                    renderGame();
                    
                    // Check wave complete
                    if (enemies.length === 0 && waveEnemiesSpawned >= waveEnemiesTotal) {
                        wave++;
                        if (wave <= 10) {
                            document.getElementById('wave-btn').disabled = false;
                            document.getElementById('wave-btn').textContent = `🚀 Start Wave ${wave}`;
                            showToast(`Wave ${wave - 1} complete! Get ready for Wave ${wave}!`, 'success');
                            soundSystem.playSound('success');
                        } else {
                            endTowerDefense();
                        }
                    }
                }, 1000 / 60); // 60 FPS
            }

            function createProjectile(tower, target) {
                const projectile = {
                    x: tower.x + 15,
                    y: tower.y + 15,
                    target: target,
                    damage: tower.damage,
                    speed: 8,
                    id: Date.now() + Math.random()
                };
                projectiles.push(projectile);
            }

            function renderGame() {
                const board = document.getElementById('game-board');
                board.innerHTML = `
                    <div id="path" style="position: absolute; top: 50%; left: 0; width: 100%; height: 40px; background: linear-gradient(90deg, rgba(0,212,255,0.3) 0%, rgba(0,212,255,0.1) 50%, rgba(0,212,255,0.3) 100%); transform: translateY(-50%); border-radius: 20px;"></div>
                    <div style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--danger); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🚪</div>
                    <div style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🏠</div>
                `;
                
                // Render towers
                towers.forEach(tower => {
                    const towerEl = document.createElement('div');
                    towerEl.style.position = 'absolute';
                    towerEl.style.left = (tower.x - 20) + 'px';
                    towerEl.style.top = (tower.y - 20) + 'px';
                    towerEl.style.width = '40px';
                    towerEl.style.height = '40px';
                    towerEl.style.fontSize = '1.5rem';
                    towerEl.style.display = 'flex';
                    towerEl.style.alignItems = 'center';
                    towerEl.style.justifyContent = 'center';
                    towerEl.style.background = 'rgba(0, 212, 255, 0.2)';
                    towerEl.style.border = '2px solid var(--accent)';
                    towerEl.style.borderRadius = '50%';
                    towerEl.style.cursor = 'pointer';
                    towerEl.style.zIndex = '10';
                    towerEl.title = `${tower.type} - Level ${tower.level} - Range: ${tower.range}`;
                    towerEl.innerHTML = getTowerIcon(tower.type);
                    
                    // Range indicator
                    const rangeEl = document.createElement('div');
                    rangeEl.style.position = 'absolute';
                    rangeEl.style.left = '50%';
                    rangeEl.style.top = '50%';
                    rangeEl.style.transform = 'translate(-50%, -50%)';
                    rangeEl.style.width = (tower.range * 2) + 'px';
                    rangeEl.style.height = (tower.range * 2) + 'px';
                    rangeEl.style.border = '1px dashed rgba(0, 212, 255, 0.3)';
                    rangeEl.style.borderRadius = '50%';
                    rangeEl.style.pointerEvents = 'none';
                    rangeEl.style.display = 'none';
                    rangeEl.style.zIndex = '5';
                    towerEl.appendChild(rangeEl);
                    
                    towerEl.addEventListener('mouseenter', () => {
                        rangeEl.style.display = 'block';
                    });
                    
                    towerEl.addEventListener('mouseleave', () => {
                        rangeEl.style.display = 'none';
                    });
                    
                    board.appendChild(towerEl);
                });
                
                // Render enemies
                enemies.forEach(enemy => {
                    const enemyEl = document.createElement('div');
                    enemyEl.style.position = 'absolute';
                    enemyEl.style.left = (enemy.x - 15) + 'px';
                    enemyEl.style.top = (enemy.y - 15) + 'px';
                    enemyEl.style.width = '30px';
                    enemyEl.style.height = '30px';
                    enemyEl.style.fontSize = '1.2rem';
                    enemyEl.style.display = 'flex';
                    enemyEl.style.alignItems = 'center';
                    enemyEl.style.justifyContent = 'center';
                    enemyEl.style.background = enemy.color;
                    enemyEl.style.borderRadius = '50%';
                    enemyEl.style.border = '2px solid white';
                    enemyEl.style.animation = 'float 1s ease-in-out infinite';
                    enemyEl.style.zIndex = '8';
                    enemyEl.innerHTML = enemy.icon;
                    
                    // Health bar
                    const healthBar = document.createElement('div');
                    healthBar.style.position = 'absolute';
                    healthBar.style.top = '-8px';
                    healthBar.style.left = '0';
                    healthBar.style.width = '30px';
                    healthBar.style.height = '4px';
                    healthBar.style.background = 'rgba(0,0,0,0.3)';
                    healthBar.style.borderRadius = '2px';
                    healthBar.style.overflow = 'hidden';
                    
                    const healthFill = document.createElement('div');
                    healthFill.style.width = ((enemy.health / enemy.maxHealth) * 100) + '%';
                    healthFill.style.height = '100%';
                    healthFill.style.background = enemy.health > enemy.maxHealth * 0.5 ? '#4CAF50' : '#f44336';
                    healthFill.style.transition = 'width 0.3s ease';
                    
                    healthBar.appendChild(healthFill);
                    enemyEl.appendChild(healthBar);
                    
                    board.appendChild(enemyEl);
                });
                
                // Render projectiles
                projectiles.forEach(projectile => {
                    const projectileEl = document.createElement('div');
                    projectileEl.style.position = 'absolute';
                    projectileEl.style.left = (projectile.x - 3) + 'px';
                    projectileEl.style.top = (projectile.y - 3) + 'px';
                    projectileEl.style.width = '6px';
                    projectileEl.style.height = '6px';
                    projectileEl.style.background = 'var(--accent)';
                    projectileEl.style.borderRadius = '50%';
                    projectileEl.style.boxShadow = '0 0 10px var(--accent)';
                    projectileEl.style.animation = 'pulse 0.5s infinite';
                    projectileEl.style.zIndex = '15';
                    
                    board.appendChild(projectileEl);
                });
            }

            function updateTowerDefenseDisplay() {
                // Update the display elements in the modal
                const waveElement = document.querySelector('[style*="Wave"]');
                const healthElement = document.querySelector('[style*="❤️"]');
                const scoreElement = document.querySelector('[style*="💰"]');
                const waveInfo = document.querySelector('[style*="Enemies:"]');
                
                if (waveElement) {
                    waveElement.textContent = wave;
                }
                if (healthElement) {
                    healthElement.textContent = `❤️ ${health}`;
                }
                if (scoreElement) {
                    scoreElement.textContent = `💰 ${score}`;
                }
                if (waveInfo) {
                    waveInfo.textContent = `Enemies: ${waveEnemiesSpawned}/${waveEnemiesTotal}`;
                }
            }

            function endTowerDefense() {
                gameRunning = false;
                clearInterval(gameInterval);
                
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                gameState.gamesPlayed++;
                updateStats();
                checkAchievements();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">${health <= 0 ? '💀 Game Over!' : '🎉 Victory!'}</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Waves Survived: ${wave - 1}/10
                        </div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Towers Built: ${towers.length}
                        </div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Enemies Defeated: ${score / 20}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }

            function upgradeTower(tower) {
                if (score >= tower.cost) {
                    tower.damage += 5;
                    tower.range += 10;
                    score -= tower.cost;
                    updateTowerDefenseDisplay();
                    renderGame();
                    showToast('Tower upgraded!', 'success');
                } else {
                    showToast('Not enough points to upgrade!', 'error');
                }
            }
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPuzzleGame();
        }

        function showPuzzleGame() {
            const puzzlePieces = [
                { id: 1, text: 'Generate Proof', type: 'step', order: 1 },
                { id: 2, text: 'Verify Identity', type: 'step', order: 2 },
                { id: 3, text: 'Submit Transaction', type: 'step', order: 3 },
                { id: 4, text: 'Validate on Chain', type: 'step', order: 4 },
                { id: 5, text: 'Privacy Preserved', type: 'result', order: 5 }
            ];

            let score = 0;
            let timeLeft = 60;
            let currentPuzzle = 0;
            let selectedPieces = [];

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Privacy Puzzle Game</h3>
                    <div id="puzzle-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Arrange ZK-Proof flow correctly</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time Left: <span id="puzzle-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="puzzle-score">${score}</span></div>
                            </div>
                            <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Drop pieces here in correct order:</h5>
                                <div id="puzzle-area" style="min-height: 200px; border: 2px dashed var(--border); border-radius: 5px; padding: 10px; display: flex; flex-direction: column; gap: 5px;">
                                    <div style="color: var(--muted); text-align: center;">Drag pieces here</div>
                                </div>
                            </div>
                            <div style="background: var(--surface); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Available pieces:</h5>
                                <div id="pieces-container" style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                    ${puzzlePieces.map(piece => 
                                        `<div class="puzzle-piece" data-id="${piece.id}" data-order="${piece.order}" style="background: var(--accent); color: white; padding: 10px 15px; border-radius: 5px; cursor: grab; user-select: none;">${piece.text}</div>`
                                    ).join('')}
                                </div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="checkPuzzle()" style="background: var(--success);">Check Solution</button>
                                <button class="btn" onclick="resetPuzzle()" style="background: var(--warning);">Reset</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('puzzle-time').textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endPuzzleGame(score);
                }
            }, 1000);

            // Make pieces draggable
            const pieces = document.querySelectorAll('.puzzle-piece');
            pieces.forEach(piece => {
                piece.draggable = true;
                piece.addEventListener('dragstart', handleDragStart);
            });

            const puzzleArea = document.getElementById('puzzle-area');
            puzzleArea.addEventListener('dragover', handleDragOver);
            puzzleArea.addEventListener('drop', handleDrop);

            let draggedPiece = null;

            function handleDragStart(e) {
                draggedPiece = e.target;
                e.target.style.opacity = '0.5';
            }

            function handleDragOver(e) {
                e.preventDefault();
            }

            function handleDrop(e) {
                e.preventDefault();
                if (draggedPiece) {
                    const piece = {
                        id: parseInt(draggedPiece.dataset.id),
                        text: draggedPiece.textContent,
                        order: parseInt(draggedPiece.dataset.order)
                    };
                    
                    if (!selectedPieces.find(p => p.id === piece.id)) {
                        selectedPieces.push(piece);
                        renderPuzzleArea();
                        draggedPiece.style.display = 'none';
                    }
                    draggedPiece.style.opacity = '1';
                    draggedPiece = null;
                }
            }

            function renderPuzzleArea() {
                const area = document.getElementById('puzzle-area');
                if (selectedPieces.length === 0) {
                    area.innerHTML = '<div style="color: var(--muted); text-align: center;">Drag pieces here</div>';
                } else {
                    area.innerHTML = selectedPieces.map((piece, index) => 
                        `<div style="background: var(--accent); color: white; padding: 8px 12px; border-radius: 4px; margin: 2px; display: inline-block; cursor: pointer;" onclick="removePiece(${piece.id})">${index + 1}. ${piece.text}</div>`
                    ).join('');
                }
            }

            window.removePiece = function(id) {
                selectedPieces = selectedPieces.filter(p => p.id !== id);
                renderPuzzleArea();
                
                // Show the piece again
                const piece = document.querySelector(`[data-id="${id}"]`);
                if (piece) {
                    piece.style.display = 'block';
                }
            };

            window.checkPuzzle = function() {
                if (selectedPieces.length !== puzzlePieces.length) {
                    showToast('Complete the puzzle first!', 'error');
                    return;
                }

                let correct = 0;
                selectedPieces.forEach((piece, index) => {
                    if (piece.order === index + 1) {
                        correct++;
                    }
                });

                const points = Math.floor((correct / puzzlePieces.length) * 100);
                score += points;
                document.getElementById('puzzle-score').textContent = score;

                if (correct === puzzlePieces.length) {
                    showToast('🎉 Perfect! Puzzle solved!', 'success');
                    setTimeout(() => {
                        resetPuzzle();
                    }, 2000);
                } else {
                    showToast(`✅ ${correct}/${puzzlePieces.length} correct! Try again!`, 'warning');
                }
            };

            window.resetPuzzle = function() {
                selectedPieces = [];
                renderPuzzleArea();
                
                // Show all pieces again
                pieces.forEach(piece => {
                    piece.style.display = 'block';
                });
            };

            function endPuzzleGame(finalScore) {
                clearInterval(timer);
                const pointsEarned = Math.floor(finalScore / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('puzzle-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playRunnerGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showSimpleRunnerGame();
        }

        function showSimpleRunnerGame() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏃 Intent Runner</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                            <div>Score: <span id="runner-score">0</span></div>
                            <div>Status: <span id="jump-status">Ready</span></div>
                        </div>
                        <div id="runner-board" style="width: 100%; height: 300px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid var(--border); border-radius: 10px; position: relative; overflow: hidden;">
                            <div id="runner-player" style="position: absolute; left: 50px; bottom: 20px; width: 30px; height: 30px; background: var(--accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; z-index: 10;">🧙‍♂️</div>
                        </div>
                        <div style="margin: 20px 0;">
                            <p><strong>Controls:</strong> Press SPACE to jump!</p>
                            <p><strong>Goal:</strong> Jump over obstacles 🚫 on the ground and collect diamonds 💎 in the air!</p>
                        </div>
                        <div style="margin: 20px 0;">
                            <button class="btn" onclick="startSimpleRunner()" id="start-runner-btn">Start Game</button>
                            <button class="btn" onclick="testJump()" style="background: var(--accent);">Test Jump</button>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Game state variables
            let gameRunning = false;
            let score = 0;
            let obstacles = [];
            let collectibles = [];
            let gameInterval;
            let obstacleInterval;
            let player = document.getElementById('runner-player');
            let isJumping = false;
            let jumpHeight = 0;
            let jumpSpeed = 0;
            let gravity = 0.4; // 减少重力，让跳跃更高
            let jumpPower = 18; // 增加跳跃力度，确保能跳过障碍物

            function startSimpleRunner() {
                console.log('Starting Intent Runner game...');
                gameRunning = true;
                score = 0;
                isJumping = false;
                obstacles = [];
                collectibles = [];
                jumpHeight = 0;
                jumpSpeed = 0;
                
                document.getElementById('start-runner-btn').disabled = true;
                document.getElementById('jump-status').textContent = 'Ready';
                
                // Reset player position
                player.style.bottom = '20px';
                
                // Start game loop
                gameInterval = setInterval(() => {
                    if (!gameRunning) return;
                    updateGame();
                    renderGame();
                }, 16); // 60 FPS
                
                // Start spawning obstacles
                obstacleInterval = setInterval(() => {
                    if (!gameRunning) return;
                    spawnObstacle();
                    if (Math.random() < 0.4) { // 增加收集品生成概率
                        spawnCollectible();
                    }
                }, 1200); // 更频繁的障碍物生成

                soundSystem.playSound('gameStart');
                showToast('Intent Runner started! Press SPACE to jump!', 'success');
            }

            function spawnObstacle() {
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                obstacle.style.position = 'absolute';
                obstacle.style.right = '-30px';
                obstacle.style.bottom = '20px'; // 障碍物在地面上
                obstacle.style.width = '30px';
                obstacle.style.height = '50px'; // 更高的障碍物
                obstacle.style.background = 'var(--danger)';
                obstacle.style.borderRadius = '5px';
                obstacle.style.display = 'flex';
                obstacle.style.alignItems = 'center';
                obstacle.style.justifyContent = 'center';
                obstacle.style.fontSize = '20px';
                obstacle.style.zIndex = '5';
                obstacle.textContent = '🚫';
                
                document.getElementById('runner-board').appendChild(obstacle);
                
                obstacles.push({
                    element: obstacle,
                    x: 600,
                    speed: 4 // 更快的移动速度
                });
            }

            function spawnCollectible() {
                const collectible = document.createElement('div');
                collectible.className = 'collectible';
                collectible.style.position = 'absolute';
                collectible.style.right = '-30px';
                collectible.style.bottom = '120px'; // 在空中，需要跳跃才能收集
                collectible.style.width = '25px';
                collectible.style.height = '25px';
                collectible.style.background = 'var(--success)';
                collectible.style.borderRadius = '50%';
                collectible.style.display = 'flex';
                collectible.style.alignItems = 'center';
                collectible.style.justifyContent = 'center';
                collectible.style.fontSize = '16px';
                collectible.style.zIndex = '5';
                collectible.textContent = '💎';
                
                document.getElementById('runner-board').appendChild(collectible);
                
                collectibles.push({
                    element: collectible,
                    x: 600,
                    speed: 4
                });
            }

            function updateGame() {
                // Update jump physics
                if (isJumping) {
                    jumpSpeed -= gravity;
                    jumpHeight += jumpSpeed;
                    
                    if (jumpHeight <= 0) {
                        jumpHeight = 0;
                        jumpSpeed = 0;
                        isJumping = false;
                        player.style.bottom = '20px';
                        document.getElementById('jump-status').textContent = 'Ready';
                    } else {
                        player.style.bottom = (20 + jumpHeight) + 'px';
                        document.getElementById('jump-status').textContent = 'Jumping!';
                    }
                }

                // Move obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= obstacle.speed;
                    obstacle.element.style.right = (600 - obstacle.x) + 'px';
                    
                    if (obstacle.x < -50) {
                        obstacle.element.remove();
                        obstacles.splice(index, 1);
                        score += 10;
                    }
                });

                // Move collectibles
                collectibles.forEach((collectible, index) => {
                    collectible.x -= collectible.speed;
                    collectible.element.style.right = (600 - collectible.x) + 'px';
                    
                    if (collectible.x < -50) {
                        collectible.element.remove();
                        collectibles.splice(index, 1);
                    }
                });

                // Check collisions
                checkCollisions();
            }

            function checkCollisions() {
                const playerRect = player.getBoundingClientRect();
                const boardRect = document.getElementById('runner-board').getBoundingClientRect();
                const playerX = playerRect.left - boardRect.left;
                const playerY = playerRect.top - boardRect.top;
                const playerWidth = 30;
                const playerHeight = 30;

                // Check obstacle collisions
                obstacles.forEach((obstacle, index) => {
                    const obstacleRect = obstacle.element.getBoundingClientRect();
                    const obstacleX = obstacleRect.left - boardRect.left;
                    const obstacleY = obstacleRect.top - boardRect.top;
                    const obstacleWidth = 30;
                    const obstacleHeight = 50;

                    // 简单的碰撞检测：玩家和障碍物重叠就碰撞
                    if (playerX < obstacleX + obstacleWidth &&
                        playerX + playerWidth > obstacleX &&
                        playerY < obstacleY + obstacleHeight &&
                        playerY + playerHeight > obstacleY) {
                        // Collision detected
                        endGame();
                        return;
                    }
                });

                // Check collectible collisions
                collectibles.forEach((collectible, index) => {
                    const collectibleRect = collectible.element.getBoundingClientRect();
                    const collectibleX = collectibleRect.left - boardRect.left;
                    const collectibleY = collectibleRect.top - boardRect.top;
                    const collectibleWidth = 20;
                    const collectibleHeight = 20;

                    if (playerX < collectibleX + collectibleWidth &&
                        playerX + playerWidth > collectibleX &&
                        playerY < collectibleY + collectibleHeight &&
                        playerY + playerHeight > collectibleY) {
                        // Item collected
                        collectible.element.remove();
                        collectibles.splice(index, 1);
                        score += 50;
                        soundSystem.playSound('collect');
                        particleSystem.createCollectEffect(collectibleX + collectibleWidth/2, collectibleY + collectibleHeight/2);
                        showToast('💎 Diamond collected!', 'success');
                    }
                });
            }

            function renderGame() {
                // Update score
                document.getElementById('runner-score').textContent = score;
                
                // Render ground line
                const board = document.getElementById('runner-board');
                const existingGround = document.getElementById('ground-line');
                if (existingGround) {
                    existingGround.remove();
                }
                
                const ground = document.createElement('div');
                ground.id = 'ground-line';
                ground.style.position = 'absolute';
                ground.style.left = '0px';
                ground.style.bottom = '20px';
                ground.style.width = '100%';
                ground.style.height = '3px';
                ground.style.background = 'var(--accent)';
                ground.style.zIndex = '1';
                board.appendChild(ground);
            }

            function jump() {
                console.log('Jump function called!');
                if (isJumping || !gameRunning) {
                    console.log('Jump blocked - isJumping:', isJumping, 'gameRunning:', gameRunning);
                    return;
                }
                
                isJumping = true;
                jumpSpeed = jumpPower;
                jumpHeight = 0;
                document.getElementById('jump-status').textContent = 'Jumping!';
                soundSystem.playSound('jump');
                particleSystem.createParticle(50 + 15, 20 + 15, 'jump');
                console.log('Jump started!');
            }

            function testJump() {
                if (!gameRunning) {
                    showToast('Please start the game first!', 'warning');
                    return;
                }
                jump();
            }

            // Make functions globally accessible
            window.jump = jump;
            window.testJump = testJump;

            function endGame() {
                gameRunning = false;
                clearInterval(gameInterval);
                clearInterval(obstacleInterval);
                
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                gameState.gamesPlayed++;
                updateStats();
                checkAchievements();
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(400, 150, 30);
                
                document.getElementById('runner-board').innerHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                        <h3 class="animated-bounce">🎉 Game Over!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                    </div>
                `;
            }

            window.startSimpleRunner = startSimpleRunner;
        }

        function playDiceGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showDiceGame();
        }

        function showArcheryGame() {
            if (gameState.points < 30) {
                showToast('Not enough points! Need 30 points to play.', 'error');
                return;
            }
            
            gameState.points -= 30;
            updateStats();
            
            let score = 0;
            let arrows = 10;
            let targetX = 400;
            let targetY = 200;
            let targetSize = 60;
            let gameRunning = true;
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Archery Game</h3>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Score: <span id="archery-score">0</span></div>
                        <div>Arrows: <span id="archery-arrows">10</span></div>
                        <div>Target: <span id="archery-target">🎯</span></div>
                    </div>
                    <div id="archery-game" style="width: 100%; height: 400px; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); border: 3px solid var(--accent); border-radius: 15px; position: relative; overflow: hidden; cursor: crosshair;">
                        <div id="archery-target" style="position: absolute; left: ${targetX}px; top: ${targetY}px; width: ${targetSize}px; height: ${targetSize}px; background: radial-gradient(circle, #ff6b6b 0%, #ee5a24 50%, #c23616 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2rem; animation: pulse 2s infinite; border: 3px solid white; box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);">
                            🎯
                        </div>
                        <div id="archery-arrow" style="position: absolute; left: 50px; top: 50%; transform: translateY(-50%); font-size: 3rem; transition: all 0.3s ease; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));">🏹</div>
                        <div id="crosshair" style="position: absolute; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; pointer-events: none; display: none;"></div>
                        <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 1.2rem; text-align: center;">
                            <div>🎯 Click to shoot! Aim for the moving target!</div>
                            <div style="font-size: 0.9rem; margin-top: 5px; opacity: 0.8;">Target moves every 1.5-3 seconds</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const gameArea = document.getElementById('archery-game');
            const target = document.getElementById('archery-target');
            
            // Move target randomly
            function moveTarget() {
                if (!gameRunning) return;
                
                targetX = 200 + Math.random() * 400;
                targetY = 100 + Math.random() * 200;
                target.style.left = targetX + 'px';
                target.style.top = targetY + 'px';
                
                setTimeout(moveTarget, 1500 + Math.random() * 1500);
            }
            
            // Start moving target immediately
            moveTarget();
            
            // Add crosshair following mouse
            gameArea.addEventListener('mousemove', function(e) {
                const rect = this.getBoundingClientRect();
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = (e.clientX - rect.left - 10) + 'px';
                crosshair.style.top = (e.clientY - rect.top - 10) + 'px';
                crosshair.style.display = 'block';
            });
            
            gameArea.addEventListener('mouseleave', function() {
                document.getElementById('crosshair').style.display = 'none';
            });
            
            gameArea.addEventListener('click', function(e) {
                if (!gameRunning || arrows <= 0) return;
                
                const rect = this.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Calculate distance from target center
                const distance = Math.sqrt(Math.pow(clickX - (targetX + targetSize/2), 2) + Math.pow(clickY - (targetY + targetSize/2), 2));
                
                let points = 0;
                let hitType = '';
                if (distance < targetSize/2) {
                    points = 100;
                    hitType = 'BULLSEYE!';
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(clickX, clickY, 30);
                    showToast('🎯 BULLSEYE! +100 points!', 'success');
                } else if (distance < targetSize) {
                    points = 50;
                    hitType = 'HIT!';
                    soundSystem.playSound('click');
                    particleSystem.createExplosion(clickX, clickY, 20);
                    showToast('🎯 HIT! +50 points!', 'success');
                } else if (distance < targetSize * 1.5) {
                    points = 25;
                    hitType = 'CLOSE!';
                    soundSystem.playSound('click');
                    showToast('🎯 Close! +25 points!', 'warning');
                } else {
                    hitType = 'MISS!';
                    soundSystem.playSound('error');
                    showToast('❌ Miss! Try again!', 'error');
                }
                
                score += points;
                arrows--;
                
                document.getElementById('archery-score').textContent = score;
                document.getElementById('archery-arrows').textContent = arrows;
                
                // Show arrow trajectory
                const arrow = document.getElementById('archery-arrow');
                arrow.style.left = clickX + 'px';
                arrow.style.top = clickY + 'px';
                arrow.style.transform = 'translate(-50%, -50%)';
                
                // Create trajectory line
                const trajectory = document.createElement('div');
                trajectory.style.position = 'absolute';
                trajectory.style.left = '50px';
                trajectory.style.top = '50%';
                trajectory.style.width = Math.sqrt(Math.pow(clickX - 50, 2) + Math.pow(clickY - 200, 2)) + 'px';
                trajectory.style.height = '2px';
                trajectory.style.background = 'linear-gradient(90deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.2) 100%)';
                trajectory.style.transformOrigin = '0 50%';
                trajectory.style.transform = `rotate(${Math.atan2(clickY - 200, clickX - 50)}rad)`;
                trajectory.style.pointerEvents = 'none';
                trajectory.style.zIndex = '1';
                gameArea.appendChild(trajectory);
                
                setTimeout(() => {
                    arrow.style.left = '50px';
                    arrow.style.top = '50%';
                    arrow.style.transform = 'translateY(-50%)';
                    trajectory.remove();
                }, 500);
                
                if (arrows <= 0) {
                    endArcheryGame();
                }
            });
            
            function endArcheryGame() {
                gameRunning = false;
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎯 Archery Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Accuracy: ${Math.round((score / 1000) * 100)}%
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function playRunnerGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showRunnerGame();
        }

        function showRunnerGame() {
            
            let score = 0;
            let timeLeft = 30;
            let gameRunning = true;
            let playerX = 50;
            let playerY = 200;
            let tokens = [];
            let obstacles = [];
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏃 Anoma Runner Game</h3>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Score: <span id="runner-score">0</span></div>
                        <div>Time: <span id="runner-time">30</span></div>
                        <div>Speed: <span id="runner-speed">1x</span></div>
                    </div>
                    <div id="runner-game" style="width: 100%; height: 400px; background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%); border: 3px solid var(--accent); border-radius: 15px; position: relative; overflow: hidden;">
                        <div id="runner-player" style="position: absolute; left: ${playerX}px; top: ${playerY}px; font-size: 3rem; z-index: 10;">🧙‍♂️</div>
                        <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 1.2rem;">
                            Use WASD or Arrow Keys to move! Collect Anoma tokens!
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const gameArea = document.getElementById('runner-game');
            const player = document.getElementById('runner-player');
            
            // Game loop
            const gameLoop = setInterval(() => {
                if (!gameRunning) return;
                
                // Move player
                player.style.left = playerX + 'px';
                player.style.top = playerY + 'px';
                
                // Spawn tokens
                if (Math.random() < 0.1) {
                    spawnToken();
                }
                
                // Spawn obstacles
                if (Math.random() < 0.05) {
                    spawnObstacle();
                }
                
                // Move tokens
                tokens.forEach((token, index) => {
                    token.x -= 3;
                    if (token.x < -50) {
                        tokens.splice(index, 1);
                    }
                });
                
                // Move obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 2;
                    if (obstacle.x < -50) {
                        obstacles.splice(index, 1);
                    }
                });
                
                // Check collisions
                checkCollisions();
                
                // Render
                renderRunnerGame();
                
            }, 1000 / 60);
            
            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('runner-time').textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    endRunnerGame();
                }
            }, 1000);
            
            // Controls
            document.addEventListener('keydown', function(e) {
                if (!gameRunning) return;
                
                const speed = 10;
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        playerY = Math.max(50, playerY - speed);
                        break;
                    case 's':
                    case 'arrowdown':
                        playerY = Math.min(350, playerY + speed);
                        break;
                    case 'a':
                    case 'arrowleft':
                        playerX = Math.max(50, playerX - speed);
                        break;
                    case 'd':
                    case 'arrowright':
                        playerX = Math.min(750, playerX + speed);
                        break;
                }
            });
            
            function spawnToken() {
                tokens.push({
                    x: 800,
                    y: 100 + Math.random() * 200,
                    type: Math.random() < 0.5 ? '🪙' : '💎',
                    value: Math.random() < 0.5 ? 10 : 20
                });
            }
            
            function spawnObstacle() {
                obstacles.push({
                    x: 800,
                    y: 100 + Math.random() * 200,
                    type: '🚫'
                });
            }
            
            function checkCollisions() {
                // Check token collisions
                tokens.forEach((token, index) => {
                    const distance = Math.sqrt(Math.pow(playerX - token.x, 2) + Math.pow(playerY - token.y, 2));
                    if (distance < 30) {
                        score += token.value;
                        tokens.splice(index, 1);
                        soundSystem.playSound('collect');
                        particleSystem.createExplosion(token.x, token.y, 20);
                    }
                });
                
                // Check obstacle collisions
                obstacles.forEach((obstacle, index) => {
                    const distance = Math.sqrt(Math.pow(playerX - obstacle.x, 2) + Math.pow(playerY - obstacle.y, 2));
                    if (distance < 30) {
                        score = Math.max(0, score - 50);
                        obstacles.splice(index, 1);
                        soundSystem.playSound('error');
                        particleSystem.createExplosion(obstacle.x, obstacle.y, 30);
                    }
                });
                
                document.getElementById('runner-score').textContent = score;
            }
            
            function renderRunnerGame() {
                // Clear previous elements
                const existingTokens = gameArea.querySelectorAll('.runner-token');
                const existingObstacles = gameArea.querySelectorAll('.runner-obstacle');
                existingTokens.forEach(el => el.remove());
                existingObstacles.forEach(el => el.remove());
                
                // Render tokens
                tokens.forEach(token => {
                    const tokenEl = document.createElement('div');
                    tokenEl.className = 'runner-token';
                    tokenEl.style.position = 'absolute';
                    tokenEl.style.left = token.x + 'px';
                    tokenEl.style.top = token.y + 'px';
                    tokenEl.style.fontSize = '2rem';
                    tokenEl.style.animation = 'float 1s ease-in-out infinite';
                    tokenEl.textContent = token.type;
                    gameArea.appendChild(tokenEl);
                });
                
                // Render obstacles
                obstacles.forEach(obstacle => {
                    const obstacleEl = document.createElement('div');
                    obstacleEl.className = 'runner-obstacle';
                    obstacleEl.style.position = 'absolute';
                    obstacleEl.style.left = obstacle.x + 'px';
                    obstacleEl.style.top = obstacle.y + 'px';
                    obstacleEl.style.fontSize = '2rem';
                    obstacleEl.style.animation = 'pulse 1s ease-in-out infinite';
                    obstacleEl.textContent = obstacle.type;
                    gameArea.appendChild(obstacleEl);
                });
            }
            
            function endRunnerGame() {
                gameRunning = false;
                clearInterval(gameLoop);
                clearInterval(timer);
                
                const pointsEarned = Math.floor(score / 5);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🏃 Runner Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Tokens Collected: ${Math.floor(score / 15)}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function showComingSoon() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <div style="font-size: 4rem; margin: 20px 0;">🚀</div>
                    <h2>More Games Coming Soon!</h2>
                    <h3>更多游戏敬请期待！</h3>
                    <div style="margin: 30px 0; padding: 20px; background: var(--surface); border-radius: 10px;">
                        <h4>🎮 Upcoming Games:</h4>
                        <ul style="text-align: left; margin: 20px 0;">
                            <li>🎯 Intent Battle Royale</li>
                            <li>🏆 Anoma Racing Championship</li>
                            <li>🧠 Memory Challenge</li>
                            <li>🎪 Intent Carnival</li>
                            <li>⚔️ Privacy Wars</li>
                            <li>🎨 Intent Art Studio</li>
                        </ul>
                    </div>
                    <p style="color: var(--muted); margin: 20px 0;">
                        We're working hard to bring you more exciting games that teach Anoma concepts!
                    </p>
                    <button class="btn" onclick="closeModal()" style="background: var(--accent);">Got it!</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showShrimpCollector() {
            if (gameState.points < 20) {
                showToast('Not enough points! Need 20 points to play.', 'error');
                return;
            }
            
            gameState.points -= 20;
            updateStats();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🦐 Shrimp Collector Game</h3>
                    <div id="shrimp-game-board" style="width: 500px; height: 300px; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); margin: 20px auto; position: relative; border-radius: 10px; overflow: hidden;">
                        <div id="shrimp-score" style="position: absolute; top: 10px; left: 10px; color: white; font-size: 1.2rem; font-weight: bold;">Score: 0</div>
                        <div id="shrimp-timer" style="position: absolute; top: 10px; right: 10px; color: white; font-size: 1.2rem; font-weight: bold;">Time: 30</div>
                        <div id="shrimp-instructions" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.1rem;">
                            Click the shrimps to collect them!<br>
                            <button class="btn" onclick="startShrimpGame()" style="margin-top: 10px;">Start Game</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function startShrimpGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = true;
            const board = document.getElementById('shrimp-game-board');
            const instructions = document.getElementById('shrimp-instructions');
            
            instructions.style.display = 'none';
            
            function createShrimp() {
                if (!gameRunning) return;
                
                const shrimp = document.createElement('div');
                shrimp.innerHTML = '🦐';
                shrimp.style.position = 'absolute';
                shrimp.style.fontSize = '2rem';
                shrimp.style.cursor = 'pointer';
                shrimp.style.left = Math.random() * 450 + 'px';
                shrimp.style.top = Math.random() * 250 + 'px';
                shrimp.style.animation = 'float 1s ease-in-out infinite';
                
                shrimp.onclick = function() {
                    score += 10;
                    document.getElementById('shrimp-score').textContent = 'Score: ' + score;
                    soundSystem.playSound('collect');
                    particleSystem.createExplosion(this.offsetLeft + 20, this.offsetTop + 20, 15);
                    this.remove();
                };
                
                board.appendChild(shrimp);
                
                setTimeout(() => {
                    if (shrimp.parentNode) {
                        shrimp.remove();
                    }
                }, 2000);
            }
            
            function updateTimer() {
                if (!gameRunning) return;
                
                timeLeft--;
                document.getElementById('shrimp-timer').textContent = 'Time: ' + timeLeft;
                
                if (timeLeft <= 0) {
                    gameRunning = false;
                    const pointsEarned = Math.floor(score / 10);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    board.innerHTML = `
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                            <h3 class="animated-bounce">🎉 Game Over!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        </div>
                    `;
                    soundSystem.playSound('gameEnd');
                    particleSystem.createExplosion(250, 150, 30);
                }
            }
            
            setInterval(createShrimp, 800);
            setInterval(updateTimer, 1000);
        }

        function showAnomaQuiz() {
            if (gameState.points < 50) {
                showToast('Not enough points! Need 50 points to play.', 'error');
                return;
            }
            
            gameState.points -= 50;
            updateStats();
            
            const questions = [
                {
                    question: "What is Anoma's core philosophy?",
                    options: ["Centralized control", "Intent-centric design", "Proof of work", "Mining rewards"],
                    correct: 1,
                    explanation: "Anoma is built around the concept of intents - what users want to achieve rather than how to achieve it."
                },
                {
                    question: "What does ZK stand for in Anoma?",
                    options: ["Zero Knowledge", "Zero Karma", "Zero Key", "Zero Kernel"],
                    correct: 0,
                    explanation: "ZK stands for Zero Knowledge, enabling privacy-preserving transactions."
                },
                {
                    question: "What is the main benefit of Anoma's intent system?",
                    options: ["Higher fees", "Better user experience", "More complexity", "Slower transactions"],
                    correct: 1,
                    explanation: "Intent systems abstract away complexity, making DeFi more accessible to users."
                },
                {
                    question: "How does Anoma ensure privacy?",
                    options: ["Public ledgers", "Zero-knowledge proofs", "Centralized servers", "Open source code"],
                    correct: 1,
                    explanation: "Anoma uses zero-knowledge proofs to enable private transactions while maintaining verifiability."
                },
                {
                    question: "What is cross-chain functionality in Anoma?",
                    options: ["Single chain only", "Multi-chain operations", "Chain isolation", "No interoperability"],
                    correct: 1,
                    explanation: "Anoma enables seamless operations across multiple blockchains through its intent system."
                }
            ];
            
            let currentQuestion = 0;
            let score = 0;
            
            function showQuestion() {
                if (currentQuestion >= questions.length) {
                    endQuiz();
                    return;
                }
                
                const q = questions[currentQuestion];
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; text-align: center;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3>🧠 Anoma Master Quiz</h3>
                        <div style="margin: 20px 0; font-size: 1.1rem;">
                            Question ${currentQuestion + 1} of ${questions.length}
                        </div>
                        <h4 style="margin: 20px 0;">${q.question}</h4>
                        <div style="display: grid; gap: 10px; margin: 20px 0;">
                            ${q.options.map((option, index) => `
                                <button class="btn" onclick="answerQuestion(${index})" style="text-align: left; padding: 15px;">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            window.answerQuestion = function(selectedIndex) {
                const q = questions[currentQuestion];
                const isCorrect = selectedIndex === q.correct;
                
                if (isCorrect) {
                    score += 20;
                    soundSystem.playSound('success');
                    showToast('Correct! +20 points', 'success');
                } else {
                    soundSystem.playSound('error');
                    showToast(`Wrong! The correct answer is: ${q.options[q.correct]}`, 'error');
                }
                
                closeModal();
                currentQuestion++;
                setTimeout(showQuestion, 1000);
            };
            
            function endQuiz() {
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px; text-align: center;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎉 Quiz Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Score: ${score}/${questions.length * 20}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Accuracy: ${Math.round((score / (questions.length * 20)) * 100)}%
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 40);
            }
            
            showQuestion();
        }

        function showMemoryGame() {
            if (gameState.points < 25) {
                showToast('Not enough points! Need 25 points to play.', 'error');
                return;
            }
            
            gameState.points -= 25;
            updateStats();
            
            const cards = [
                { id: 1, emoji: '🛡️', name: 'ZK-Proof' },
                { id: 2, emoji: '⚡', name: 'Intent Solver' },
                { id: 3, emoji: '🔐', name: 'Privacy Guard' },
                { id: 4, emoji: '🌉', name: 'Cross-Chain' },
                { id: 5, emoji: '🎯', name: 'Intent Matching' },
                { id: 6, emoji: '🔍', name: 'Intent Detective' },
                { id: 7, emoji: '🦐', name: 'Anoma Shrimp' },
                { id: 8, emoji: '🧙‍♂️', name: 'Anoma Wizard' }
            ];
            
            // Duplicate cards for matching
            const gameCards = [...cards, ...cards].sort(() => Math.random() - 0.5);
            
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let gameStartTime = Date.now();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧠 Anoma Memory Game</h3>
                    <div style="text-align: center; margin: 15px 0; color: var(--muted);">
                        Match Anoma concepts and characters! Find the pairs!
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Moves: <span id="memory-moves">0</span></div>
                        <div>Pairs: <span id="memory-pairs">0/8</span></div>
                        <div>Time: <span id="memory-time">0s</span></div>
                    </div>
                    <div id="memory-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;">
                        ${gameCards.map((card, index) => `
                            <div class="memory-card" data-index="${index}" data-id="${card.id}" onclick="flipCard(${index})" style="
                                width: 80px; height: 80px; background: var(--surface); border: 2px solid var(--border); 
                                border-radius: 10px; display: flex; align-items: center; justify-content: center; 
                                font-size: 2rem; cursor: pointer; transition: all 0.3s ease; user-select: none;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                            ">
                                <div class="card-back" style="font-size: 1.5rem; color: var(--accent);">❓</div>
                                <div class="card-front" style="display: none; font-size: 2.2rem; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));">${card.emoji}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div id="memory-message" style="font-size: 1.2rem; margin: 20px 0; min-height: 30px;"></div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Start timer
            const timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('memory-time').textContent = elapsed + 's';
            }, 1000);
            
            window.flipCard = function(index) {
                const card = document.querySelector(`[data-index="${index}"]`);
                if (!card || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                
                card.classList.add('flipped');
                card.querySelector('.card-back').style.display = 'none';
                card.querySelector('.card-front').style.display = 'flex';
                card.style.background = 'linear-gradient(135deg, var(--accent), var(--success))';
                card.style.transform = 'rotateY(180deg) scale(1.1)';
                card.style.boxShadow = '0 4px 15px rgba(0, 212, 255, 0.4)';
                
                flippedCards.push({ index, id: gameCards[index].id, element: card });
                moves++;
                document.getElementById('memory-moves').textContent = moves;
                
                if (flippedCards.length === 2) {
                    setTimeout(() => {
                        checkMatch();
                    }, 500);
                }
                
                soundSystem.playSound('click');
            };
            
            function checkMatch() {
                const [card1, card2] = flippedCards;
                
                if (card1.id === card2.id) {
                    // Match found
                    card1.element.classList.add('matched');
                    card2.element.classList.add('matched');
                    card1.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card2.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card1.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card2.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card1.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    card2.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    matchedPairs++;
                    document.getElementById('memory-pairs').textContent = `${matchedPairs}/8`;
                    
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(card1.element.offsetLeft + 40, card1.element.offsetTop + 40, 25);
                    showToast(`🎉 Match found! ${card1.element.querySelector('.card-front').textContent}`, 'success');
                    
                    if (matchedPairs === 8) {
                        endMemoryGame();
                    }
                } else {
                    // No match
                    setTimeout(() => {
                        card1.element.classList.remove('flipped');
                        card2.element.classList.remove('flipped');
                        card1.element.querySelector('.card-back').style.display = 'flex';
                        card1.element.querySelector('.card-front').style.display = 'none';
                        card2.element.querySelector('.card-back').style.display = 'flex';
                        card2.element.querySelector('.card-front').style.display = 'none';
                        card1.element.style.background = 'var(--surface)';
                        card2.element.style.background = 'var(--surface)';
                        card1.element.style.transform = 'rotateY(0deg)';
                        card2.element.style.transform = 'rotateY(0deg)';
                    }, 1000);
                    
                    soundSystem.playSound('error');
                }
                
                flippedCards = [];
            }
            
            function endMemoryGame() {
                clearInterval(timer);
                const timeElapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                const pointsEarned = Math.max(10, 100 - moves - timeElapsed);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎉 Memory Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Perfect Match!</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Time: ${timeElapsed}s | Moves: ${moves}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function playDiceGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showDiceGame();
        }

        function showDiceGame() {
            let score = 0;
            let rolls = 0;
            let maxRolls = 10;
            let dice = [0, 0, 0, 0, 0];

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎲 Intent Dice Game</h3>
                    <div id="dice-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Roll dice to build the best intent combinations</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Score: <span id="dice-score">${score}</span></div>
                                <div>Rolls Left: <span id="rolls-left">${maxRolls - rolls}</span></div>
                            </div>
                            <div id="dice-container" style="display: flex; justify-content: center; gap: 10px; margin: 20px 0;">
                                ${dice.map((value, index) => 
                                    `<div class="dice" onclick="holdDice(${index})" style="width: 60px; height: 60px; background: var(--surface); border: 2px solid var(--border); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: all 0.3s ease;">${value || '?'}</div>`
                                ).join('')}
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="rollDice()" id="roll-btn">Roll Dice</button>
                                <button class="btn" onclick="scoreDice()" id="score-btn" disabled>Score Intent</button>
                            </div>
                            <div id="dice-combinations" style="margin: 20px 0;">
                                <h5>Available Intent Combinations:</h5>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left;">
                                    <div>Swap + Token = 50 points</div>
                                    <div>Bridge + Chain = 40 points</div>
                                    <div>Vote + Privacy = 60 points</div>
                                    <div>Stake + Yield = 70 points</div>
                                    <div>Three of a kind = 30 points</div>
                                    <div>Full house = 100 points</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            const intentTypes = ['Swap', 'Bridge', 'Vote', 'Stake', 'Token', 'Chain', 'Privacy', 'Yield'];

            function updateDiceDisplay() {
                document.getElementById('dice-score').textContent = score;
                document.getElementById('rolls-left').textContent = maxRolls - rolls;
                
                dice.forEach((value, index) => {
                    const diceEl = document.querySelector(`.dice:nth-child(${index + 1})`);
                    if (diceEl) {
                        diceEl.textContent = value || '?';
                    }
                });
            }

            window.rollDice = function() {
                if (rolls >= maxRolls) return;
                
                dice = dice.map((value, index) => {
                    const diceEl = document.querySelector(`.dice:nth-child(${index + 1})`);
                    if (!diceEl.classList.contains('held')) {
                        return Math.floor(Math.random() * 8);
                    }
                    return value;
                });
                
                rolls++;
                updateDiceDisplay();
                
                if (rolls >= maxRolls) {
                    document.getElementById('roll-btn').disabled = true;
                }
                document.getElementById('score-btn').disabled = false;
            };

            window.holdDice = function(index) {
                const diceEl = document.querySelector(`.dice:nth-child(${index + 1})`);
                diceEl.classList.toggle('held');
                diceEl.style.background = diceEl.classList.contains('held') ? 'var(--accent)' : 'var(--surface)';
            };

            window.scoreDice = function() {
                const points = calculateScore();
                score += points;
                showToast(`Intent scored! +${points} points`, 'success');
                
                dice = [0, 0, 0, 0, 0];
                rolls = 0;
                
                document.querySelectorAll('.dice').forEach(el => {
                    el.classList.remove('held');
                    el.style.background = 'var(--surface)';
                });
                
                document.getElementById('roll-btn').disabled = false;
                document.getElementById('score-btn').disabled = true;
                updateDiceDisplay();
            };

            function calculateScore() {
                const types = dice.map(value => intentTypes[value]);
                
                // Check for specific combinations
                if (types.includes('Swap') && types.includes('Token')) return 50;
                if (types.includes('Bridge') && types.includes('Chain')) return 40;
                if (types.includes('Vote') && types.includes('Privacy')) return 60;
                if (types.includes('Stake') && types.includes('Yield')) return 70;
                
                // Check for dice combinations
                const counts = {};
                types.forEach(type => counts[type] = (counts[type] || 0) + 1);
                const values = Object.values(counts).sort((a, b) => b - a);
                
                if (values[0] === 5) return 200; // Five of a kind
                if (values[0] === 4) return 150; // Four of a kind
                if (values[0] === 3 && values[1] === 2) return 100; // Full house
                if (values[0] === 3) return 30; // Three of a kind
                if (values[0] === 2) return 10; // Pair
                
                return 0;
            }
        }

        // Close modal
        function closeModal() {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => modal.remove());
        }



        function playBuilderGame() {
            if (gameState.points < 50) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 50;
            gameState.gamesPlayed++;
            updateStats();
            showBuilderGame();
        }

        function showBuilderGame() {
            const components = [
                { name: 'Swap', type: 'action', cost: 10 },
                { name: 'Bridge', type: 'action', cost: 15 },
                { name: 'Stake', type: 'action', cost: 20 },
                { name: 'ETH', type: 'token', cost: 5 },
                { name: 'USDC', type: 'token', cost: 5 },
                { name: 'Ethereum', type: 'chain', cost: 8 },
                { name: 'Polygon', type: 'chain', cost: 8 },
                { name: 'Privacy', type: 'feature', cost: 12 }
            ];

            let selectedComponents = [];
            let budget = 100;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 800px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Builder Game</h3>
                    <div id="builder-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Build complex intents with available components</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Budget: <span id="builder-budget">${budget}</span> points</div>
                                <div>Score: <span id="builder-score">${score}</span></div>
                            </div>
                            <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Selected Components:</h5>
                                <div id="selected-components" style="min-height: 100px; border: 2px dashed var(--border); border-radius: 5px; padding: 10px; display: flex; flex-wrap: wrap; gap: 5px;">
                                    <div style="color: var(--muted); text-align: center; width: 100%;">No components selected</div>
                                </div>
                            </div>
                            <div style="background: var(--surface); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Available Components:</h5>
                                <div id="components-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                                    ${components.map((comp, index) => 
                                        `<div class="component" onclick="selectComponent(${index})" style="background: var(--accent); color: white; padding: 10px; border-radius: 5px; text-align: center; cursor: pointer; transition: all 0.3s ease;">
                                            <div style="font-weight: bold;">${comp.name}</div>
                                            <div style="font-size: 0.8rem;">${comp.type}</div>
                                            <div style="font-size: 0.8rem;">${comp.cost} pts</div>
                                        </div>`
                                    ).join('')}
                                </div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="buildIntent()" style="background: var(--success);">Build Intent</button>
                                <button class="btn" onclick="clearSelection()" style="background: var(--warning);">Clear</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectComponent = function(index) {
                const component = components[index];
                if (budget >= component.cost && !selectedComponents.includes(index)) {
                    selectedComponents.push(index);
                    budget -= component.cost;
                    updateBuilderDisplay();
                } else if (selectedComponents.includes(index)) {
                    selectedComponents = selectedComponents.filter(i => i !== index);
                    budget += component.cost;
                    updateBuilderDisplay();
                } else {
                    showToast('Not enough budget!', 'error');
                }
            };

            function updateBuilderDisplay() {
                document.getElementById('builder-budget').textContent = budget;
                
                const selectedEl = document.getElementById('selected-components');
                if (selectedComponents.length === 0) {
                    selectedEl.innerHTML = '<div style="color: var(--muted); text-align: center; width: 100%;">No components selected</div>';
                } else {
                    selectedEl.innerHTML = selectedComponents.map(index => {
                        const comp = components[index];
                        return `<div style="background: var(--accent); color: white; padding: 5px 10px; border-radius: 3px; display: inline-block; cursor: pointer;" onclick="selectComponent(${index})">${comp.name} (${comp.cost})</div>`;
                    }).join('');
                }
            }

            window.buildIntent = function() {
                if (selectedComponents.length === 0) {
                    showToast('Select at least one component!', 'error');
                    return;
                }

                const selectedComps = selectedComponents.map(i => components[i]);
                const points = calculateIntentScore(selectedComps);
                score += points;
                
                showToast(`Intent built! +${points} points`, 'success');
                
                // Reset for next intent
                selectedComponents = [];
                budget = 100;
                updateBuilderDisplay();
                document.getElementById('builder-score').textContent = score;
            };

            window.clearSelection = function() {
                selectedComponents = [];
                budget = 100;
                updateBuilderDisplay();
            };

            function calculateIntentScore(components) {
                let score = 0;
                const types = components.map(c => c.type);
                
                // Base score for each component
                score += components.length * 5;
                
                // Bonus for combinations
                if (types.includes('action') && types.includes('token')) score += 20;
                if (types.includes('action') && types.includes('chain')) score += 15;
                if (types.includes('amount') && types.includes('token')) score += 10;
                
                // Bonus for multiple actions
                const actionCount = types.filter(t => t === 'action').length;
                if (actionCount > 1) score += actionCount * 10;
                
                return score;
            }
        }

        function playShrimpJumpGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showShrimpJumpGame();
        }

        function showShrimpJumpGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let isJumping = false;
            let obstacles = [];
            let gameLoop = null;
            let obstacleSpawnInterval = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🦐 大虾跳跃游戏</h3>
                    <div id="shrimp-jump-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>控制大虾跳跃避开障碍物！</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>时间: <span id="shrimp-time">${timeLeft}</span>s</div>
                                <div>分数: <span id="shrimp-score">${score}</span></div>
                            </div>
                            <div id="shrimp-game-area" style="width: 100%; height: 300px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden;">
                                <div id="shrimp-player" style="position: absolute; bottom: 20px; left: 50px; width: 40px; height: 40px; font-size: 2rem; transition: all 0.3s ease;">🦐</div>
                                <div id="shrimp-obstacles" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startShrimpJumpGame()" id="start-shrimp-jump-btn" style="background: var(--success);">开始游戏</button>
                                <button class="btn" onclick="shrimpJump()" id="shrimp-jump-btn" disabled style="background: var(--accent);">跳跃 (空格)</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                使用空格键或点击跳跃按钮控制大虾避开障碍物！
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startShrimpJumpGame = function() {
                console.log('Starting shrimp jump game...');
                gameRunning = true;
                document.getElementById('start-shrimp-jump-btn').disabled = true;
                document.getElementById('shrimp-jump-btn').disabled = false;
                
                // 重置时间
                timeLeft = 30;
                document.getElementById('shrimp-time').textContent = timeLeft;
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('shrimp-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endShrimpJumpGame(score);
                    }
                }, 1000);

                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    
                    moveShrimpObstacles();
                    checkShrimpCollisions();
                }, 50);

                // Spawn obstacles
                obstacleSpawnInterval = setInterval(() => {
                    if (!gameRunning) return;
                    spawnShrimpObstacle();
                }, 2500);

                // Keyboard controls
                document.addEventListener('keydown', handleShrimpKeyPress);
            };

            function handleShrimpKeyPress(e) {
                if (e.code === 'Space' && gameRunning) {
                    e.preventDefault();
                    shrimpJump();
                }
            }

            window.shrimpJump = function() {
                if (!gameRunning || isJumping) return;
                
                isJumping = true;
                const player = document.getElementById('shrimp-player');
                player.style.bottom = '120px';
                player.style.transform = 'rotate(-20deg)';
                
                setTimeout(() => {
                    player.style.bottom = '20px';
                    player.style.transform = 'rotate(0deg)';
                    isJumping = false;
                }, 600);
            };

            function spawnShrimpObstacle() {
                const obstaclesContainer = document.getElementById('shrimp-obstacles');
                const obstacle = document.createElement('div');
                obstacle.style.position = 'absolute';
                obstacle.style.right = '-40px';
                obstacle.style.top = '220px';
                obstacle.style.width = '30px';
                obstacle.style.height = '30px';
                obstacle.style.fontSize = '1.5rem';
                obstacle.style.textAlign = 'center';
                obstacle.style.lineHeight = '30px';
                obstacle.style.background = 'var(--danger)';
                obstacle.style.borderRadius = '50%';
                obstacle.style.animation = 'moveLeft 4s linear forwards';
                obstacle.textContent = '🪨';
                
                obstaclesContainer.appendChild(obstacle);
                
                obstacles.push({
                    element: obstacle,
                    x: 650,
                    y: 220,
                    width: 30,
                    height: 30
                });
                
                setTimeout(() => {
                    if (obstacle.parentNode) {
                        obstacle.remove();
                        obstacles = obstacles.filter(obs => obs.element !== obstacle);
                    }
                }, 4000);
            }

            function moveShrimpObstacles() {
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 2;
                    obstacle.element.style.right = (600 - obstacle.x) + 'px';
                    
                    if (obstacle.x < -50) {
                        obstacle.element.remove();
                        obstacles.splice(index, 1);
                    }
                });
            }

            function checkShrimpCollisions() {
                const player = document.getElementById('shrimp-player');
                const playerRect = player.getBoundingClientRect();
                const gameAreaRect = document.getElementById('shrimp-game-area').getBoundingClientRect();
                
                const playerX = playerRect.left - gameAreaRect.left;
                const playerY = playerRect.top - gameAreaRect.top;
                const playerWidth = 40;
                const playerHeight = 40;
                
                // 增加分数（每帧+1分）
                score += 1;
                document.getElementById('shrimp-score').textContent = score;
                
                obstacles.forEach((obstacle, index) => {
                    // 使用实际的障碍物位置而不是计算位置
                    const obstacleRect = obstacle.element.getBoundingClientRect();
                    const obstacleX = obstacleRect.left - gameAreaRect.left;
                    const obstacleY = obstacleRect.top - gameAreaRect.top;
                    const obstacleWidth = 30;
                    const obstacleHeight = 30;
                    
                    // 只有当障碍物在玩家附近时才检测碰撞
                    if (obstacleX < playerX + playerWidth + 20 && 
                        obstacleX + obstacleWidth > playerX - 20) {
                        
                        if (playerY < obstacleY + obstacleHeight &&
                            playerY + playerHeight > obstacleY) {
                            // Collision - game over
                            console.log('Collision detected!');
                            gameRunning = false;
                            endShrimpJumpGame(score);
                        }
                    }
                });
            }

            function endShrimpJumpGame(finalScore) {
                gameRunning = false;
                if (gameLoop) clearInterval(gameLoop);
                if (obstacleSpawnInterval) clearInterval(obstacleSpawnInterval);
                if (timer) clearInterval(timer); // 确保清理计时器
                
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('shrimp-jump-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 游戏结束！</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">最终分数: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">获得积分: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">关闭</button>
                    </div>
                `;
            }
        }

        function playShrimpCollector() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showShrimpCollector();
        }

        function showShrimpCollector() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let timer = null;
            let spawnInterval = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🦐 Shrimp Collector Game</h3>
                    <div id="shrimp-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Collect Anoma shrimps!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="shrimp-time">${timeLeft}</span>s</div>
                                <div>Shrimps: <span id="shrimp-score">${score}</span></div>
                            </div>
                            <div id="shrimp-area" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden; cursor: crosshair;">
                                <div style="color: var(--muted); text-align: center; margin-top: 180px;">Click on shrimps to collect them!</div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startShrimpGame()" id="start-shrimp-btn" style="background: var(--success);">Start Game</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startShrimpGame = function() {
                gameRunning = true;
                document.getElementById('start-shrimp-btn').disabled = true;
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('shrimp-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endShrimpGame(score);
                    }
                }, 1000);

                // Spawn shrimps
                spawnInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(spawnInterval);
                        return;
                    }
                    spawnShrimp();
                }, 1000);

                // Click handler
                const shrimpArea = document.getElementById('shrimp-area');
                shrimpArea.addEventListener('click', handleShrimpClick);
            };

            function spawnShrimp() {
                const shrimpArea = document.getElementById('shrimp-area');
                const shrimp = document.createElement('div');
                shrimp.className = 'shrimp';
                shrimp.innerHTML = '🦐';
                shrimp.style.position = 'absolute';
                shrimp.style.left = Math.random() * (shrimpArea.offsetWidth - 30) + 'px';
                shrimp.style.top = Math.random() * (shrimpArea.offsetHeight - 30) + 'px';
                shrimp.style.fontSize = '24px';
                shrimp.style.cursor = 'pointer';
                shrimp.style.animation = 'float 2s ease-in-out infinite';
                
                shrimpArea.appendChild(shrimp);
                
                setTimeout(() => {
                    if (shrimp.parentNode) {
                        shrimp.remove();
                    }
                }, 3000);
            }

            function handleShrimpClick(e) {
                if (e.target.classList.contains('shrimp')) {
                    e.target.remove();
                    score++;
                    document.getElementById('shrimp-score').textContent = score;
                    showToast('Shrimp collected!', 'success');
                }
            }

            function endShrimpGame(finalScore) {
                gameRunning = false;
                if (timer) clearInterval(timer);
                if (spawnInterval) clearInterval(spawnInterval);
                
                const pointsEarned = Math.floor(finalScore * 3);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('shrimp-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Shrimps Collected: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playAnomaQuiz() {
            if (gameState.points < 50) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 50;
            gameState.gamesPlayed++;
            updateStats();
            showAnomaQuiz();
        }

        function showAnomaQuiz() {
            
            const questions = [
                {
                    question: "What is Anoma's core innovation?",
                    options: ["Faster transactions", "Intent-centric architecture", "Lower fees", "Better UI"],
                    correct: 1,
                    explanation: "Anoma's core innovation is intent-centric architecture that allows users to express what they want rather than how to do it."
                },
                {
                    question: "How does Anoma protect user privacy?",
                    options: ["Encryption", "Zero-knowledge proofs", "Private keys", "VPN"],
                    correct: 1,
                    explanation: "Anoma uses zero-knowledge proofs to protect user privacy while maintaining security."
                },
                {
                    question: "What makes Anoma different from other blockchains?",
                    options: ["Speed", "Intent system", "Fees", "Consensus"],
                    correct: 1,
                    explanation: "Anoma's intent system allows users to express their goals rather than specific transactions."
                }
            ];

            let currentQuestion = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧠 Anoma Master Quiz</h3>
                    <div id="quiz-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Question ${currentQuestion + 1}/${questions.length}</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>${questions[0].question}</strong>
                            </div>
                            <div id="quiz-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${questions[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectQuizOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="quiz-score">Score: 0/${questions.length}</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectQuizOption = function(selectedIndex) {
                const correct = questions[currentQuestion].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct!', 'success');
                } else {
                    showToast('❌ Wrong!', 'error');
                }

                currentQuestion++;
                if (currentQuestion < questions.length) {
                    document.querySelector('h4').textContent = `Question ${currentQuestion + 1}/${questions.length}`;
                    document.querySelector('#quiz-content strong').textContent = questions[currentQuestion].question;
                    document.getElementById('quiz-options').innerHTML = questions[currentQuestion].options.map((option, index) => 
                        `<button class="btn" onclick="selectQuizOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('quiz-score').textContent = `Score: ${score}/${currentQuestion}`;
                } else {
                    // Quiz finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 25);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('quiz-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Quiz Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/${questions.length}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playMemoryGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showMemoryGame();
        }

        function showMemoryGame() {
            const cards = [
                { id: 1, emoji: '🛡️', name: 'ZK-Proof' },
                { id: 2, emoji: '⚡', name: 'Intent Solver' },
                { id: 3, emoji: '🔐', name: 'Privacy Guard' },
                { id: 4, emoji: '🌉', name: 'Cross-Chain' },
                { id: 5, emoji: '🎯', name: 'Intent Matching' },
                { id: 6, emoji: '🔍', name: 'Intent Detective' },
                { id: 7, emoji: '🦐', name: 'Anoma Shrimp' },
                { id: 8, emoji: '🧙‍♂️', name: 'Anoma Wizard' }
            ];
            
            // Duplicate cards for matching
            const gameCards = [...cards, ...cards].sort(() => Math.random() - 0.5);
            
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let gameStartTime = Date.now();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧠 Anoma Memory Game</h3>
                    <div style="text-align: center; margin: 15px 0; color: var(--muted);">
                        Match Anoma concepts and characters! Find the pairs!
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Moves: <span id="memory-moves">0</span></div>
                        <div>Pairs: <span id="memory-pairs">0/8</span></div>
                        <div>Time: <span id="memory-time">0s</span></div>
                    </div>
                    <div id="memory-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;">
                        ${gameCards.map((card, index) => `
                            <div class="memory-card" data-index="${index}" data-id="${card.id}" onclick="flipCard(${index})" style="
                                width: 80px; height: 80px; background: var(--surface); border: 2px solid var(--border); 
                                border-radius: 10px; display: flex; align-items: center; justify-content: center; 
                                font-size: 2rem; cursor: pointer; transition: all 0.3s ease; user-select: none;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                            ">
                                <div class="card-back" style="font-size: 1.5rem; color: var(--accent);">❓</div>
                                <div class="card-front" style="display: none; font-size: 2.2rem; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));">${card.emoji}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div id="memory-message" style="font-size: 1.2rem; margin: 20px 0; min-height: 30px;"></div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Start timer
            const timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('memory-time').textContent = elapsed + 's';
            }, 1000);
            
            window.flipCard = function(index) {
                const card = document.querySelector(`[data-index="${index}"]`);
                if (!card || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                
                card.classList.add('flipped');
                card.querySelector('.card-back').style.display = 'none';
                card.querySelector('.card-front').style.display = 'flex';
                card.style.background = 'linear-gradient(135deg, var(--accent), var(--success))';
                card.style.transform = 'rotateY(180deg) scale(1.1)';
                card.style.boxShadow = '0 4px 15px rgba(0, 212, 255, 0.4)';
                
                flippedCards.push({ index, id: gameCards[index].id, element: card });
                moves++;
                document.getElementById('memory-moves').textContent = moves;
                
                if (flippedCards.length === 2) {
                    setTimeout(() => {
                        checkMatch();
                    }, 500);
                }
                
                soundSystem.playSound('click');
            };
            
            function checkMatch() {
                const [card1, card2] = flippedCards;
                
                if (card1.id === card2.id) {
                    // Match found
                    card1.element.classList.add('matched');
                    card2.element.classList.add('matched');
                    card1.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card2.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card1.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card2.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card1.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    card2.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    matchedPairs++;
                    document.getElementById('memory-pairs').textContent = `${matchedPairs}/8`;
                    
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(card1.element.offsetLeft + 40, card1.element.offsetTop + 40, 25);
                    showToast(`🎉 Match found! ${card1.element.querySelector('.card-front').textContent}`, 'success');
                    
                    if (matchedPairs === 8) {
                        endMemoryGame();
                    }
                } else {
                    // No match
                    setTimeout(() => {
                        card1.element.classList.remove('flipped');
                        card2.element.classList.remove('flipped');
                        card1.element.querySelector('.card-back').style.display = 'flex';
                        card1.element.querySelector('.card-front').style.display = 'none';
                        card2.element.querySelector('.card-back').style.display = 'flex';
                        card2.element.querySelector('.card-front').style.display = 'none';
                        card1.element.style.background = 'var(--surface)';
                        card2.element.style.background = 'var(--surface)';
                        card1.element.style.transform = 'rotateY(0deg)';
                        card2.element.style.transform = 'rotateY(0deg)';
                    }, 1000);
                    
                    soundSystem.playSound('error');
                }
                
                flippedCards = [];
            }
            
            function endMemoryGame() {
                clearInterval(timer);
                const timeElapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                const pointsEarned = Math.max(10, 100 - moves - timeElapsed);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎉 Memory Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Perfect Match!</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Time: ${timeElapsed}s | Moves: ${moves}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function playArcheryGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showArcheryGame();
        }

        function showArcheryGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let arrows = [];
            let targets = [];
            let arrowCount = 50; // 大幅增加箭的数量
            let mouseX = 0;
            let mouseY = 0;
            let timer = null;
            let spawnInterval = null;
            let gameLoop = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Archery Game</h3>
                    <div id="archery-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Shoot arrows at targets! Use mouse to aim and click to shoot!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="archery-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="archery-score">${score}</span></div>
                                <div>Arrows: <span id="archery-arrows">${arrowCount}</span></div>
                            </div>
                            <div id="archery-area" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden; cursor: crosshair;">
                                <div id="bow" style="position: absolute; left: 50px; top: 50%; transform: translateY(-50%); font-size: 40px; z-index: 10;">🏹</div>
                                <div id="crosshair" style="position: absolute; width: 20px; height: 20px; border: 2px solid var(--accent); border-radius: 50%; pointer-events: none; z-index: 5;"></div>
                                <div style="color: var(--muted); text-align: center; margin-top: 180px; position: absolute; left: 50%; transform: translateX(-50%);">Move mouse to aim, click to shoot!</div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startArcheryGame()" id="start-archery-btn" style="background: var(--success);">Start Game</button>
                                <button class="btn" onclick="shootArrow()" id="shoot-btn" disabled style="background: var(--accent);">Shoot Arrow (Space)</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                Use mouse to aim and click or press Space to shoot arrows at targets!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startArcheryGame = function() {
                gameRunning = true;
                document.getElementById('start-archery-btn').disabled = true;
                document.getElementById('shoot-btn').disabled = false;
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('archery-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endArcheryGame(score);
                    }
                }, 1000);

                // Spawn targets
                spawnInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(spawnInterval);
                        return;
                    }
                    spawnTarget();
                }, 1500);

                // Mouse tracking
                const archeryArea = document.getElementById('archery-area');
                archeryArea.addEventListener('mousemove', handleMouseMove);
                archeryArea.addEventListener('click', handleArcheryClick);
                document.addEventListener('keydown', handleKeyPress);

                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    updateArrows();
                    checkCollisions();
                }, 16);
            };

            function handleMouseMove(e) {
                const rect = e.currentTarget.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                
                // Update crosshair position
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = (mouseX - 10) + 'px';
                crosshair.style.top = (mouseY - 10) + 'px';
                
                // Update bow direction
                const bow = document.getElementById('bow');
                const dx = mouseX - 50;
                const dy = mouseY - 200; // Center of game area
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                bow.style.transform = `translateY(-50%) rotate(${angle}deg)`;
            }

            function handleKeyPress(e) {
                if (e.code === 'Space' && gameRunning && arrowCount > 0) {
                    e.preventDefault();
                    shootArrow();
                }
            }

            function handleArcheryClick(e) {
                if (gameRunning && arrowCount > 0) {
                    shootArrow();
                }
            }

            window.shootArrow = function() {
                if (!gameRunning || arrowCount <= 0) return;
                
                arrowCount--;
                document.getElementById('archery-arrows').textContent = arrowCount;
                
                const archeryArea = document.getElementById('archery-area');
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.innerHTML = '🏹';
                arrow.style.position = 'absolute';
                arrow.style.left = '50px';
                arrow.style.top = '50%';
                arrow.style.fontSize = '20px';
                arrow.style.zIndex = '15';
                
                // Calculate direction
                const dx = mouseX - 50;
                const dy = mouseY - 200; // Center of game area
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                arrow.style.transform = `translateY(-50%) rotate(${angle}deg)`;
                
                archeryArea.appendChild(arrow);
                
                // Add arrow to tracking array
                arrows.push({
                    element: arrow,
                    x: 50,
                    y: 200,
                    targetX: mouseX,
                    targetY: mouseY,
                    angle: angle,
                    speed: 12 // 增加箭头速度
                });
                
                if (arrowCount <= 0) {
                    document.getElementById('shoot-btn').disabled = true;
                }
            };

            function spawnTarget() {
                const archeryArea = document.getElementById('archery-area');
                const target = document.createElement('div');
                target.className = 'target';
                target.innerHTML = '🎯';
                target.style.position = 'absolute';
                
                // 确保目标在游戏区域内
                const x = Math.random() * (archeryArea.offsetWidth - 60) + 30;
                const y = Math.random() * (archeryArea.offsetHeight - 60) + 30;
                
                target.style.left = x + 'px';
                target.style.top = y + 'px';
                target.style.fontSize = '30px';
                target.style.cursor = 'pointer';
                target.style.animation = 'pulse 1s ease-in-out infinite';
                target.style.zIndex = '5';
                target.style.width = '30px';
                target.style.height = '30px';
                
                archeryArea.appendChild(target);
                
                targets.push({
                    element: target,
                    x: x,
                    y: y,
                    width: 30,
                    height: 30
                });
                
                setTimeout(() => {
                    if (target.parentNode) {
                        target.remove();
                        targets = targets.filter(t => t.element !== target);
                    }
                }, 4000);
            }

            function updateArrows() {
                // 从后往前遍历，避免删除元素时索引错乱
                for (let index = arrows.length - 1; index >= 0; index--) {
                    const arrow = arrows[index];
                    const dx = arrow.targetX - arrow.x;
                    const dy = arrow.targetY - arrow.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 10) {
                        // Arrow reached target position
                        if (arrow.element && arrow.element.parentNode) {
                            arrow.element.remove();
                        }
                        arrows.splice(index, 1);
                    } else {
                        // Move arrow towards target
                        arrow.x += (dx / distance) * arrow.speed;
                        arrow.y += (dy / distance) * arrow.speed;
                        
                        // Check if arrow is out of bounds
                        if (arrow.x < 0 || arrow.x > 800 || arrow.y < 0 || arrow.y > 400) {
                            if (arrow.element && arrow.element.parentNode) {
                                arrow.element.remove();
                            }
                            arrows.splice(index, 1);
                            continue;
                        }
                        
                        // Update arrow position
                        if (arrow.element) {
                            arrow.element.style.left = arrow.x + 'px';
                            arrow.element.style.top = arrow.y + 'px';
                            arrow.element.style.transform = `translate(-50%, -50%) rotate(${arrow.angle}deg)`;
                        }
                    }
                }
            }

            function checkCollisions() {
                // 从后往前遍历，避免删除元素时索引错乱
                for (let arrowIndex = arrows.length - 1; arrowIndex >= 0; arrowIndex--) {
                    const arrow = arrows[arrowIndex];
                    
                    for (let targetIndex = targets.length - 1; targetIndex >= 0; targetIndex--) {
                        const target = targets[targetIndex];
                        
                        // 计算箭头中心到目标中心的距离
                        const arrowCenterX = arrow.x;
                        const arrowCenterY = arrow.y;
                        const targetCenterX = target.x + 15; // 目标宽度的一半
                        const targetCenterY = target.y + 15; // 目标高度的一半
                        
                        const distance = Math.sqrt(
                            Math.pow(arrowCenterX - targetCenterX, 2) + 
                            Math.pow(arrowCenterY - targetCenterY, 2)
                        );
                        
                        if (distance < 30) { // 增加碰撞检测范围
                            // Hit!
                            console.log('Target hit! Distance:', distance);
                            
                            // 移除目标
                            if (target.element && target.element.parentNode) {
                                target.element.remove();
                            }
                            targets.splice(targetIndex, 1);
                            
                            // 移除箭头
                            if (arrow.element && arrow.element.parentNode) {
                                arrow.element.remove();
                            }
                            arrows.splice(arrowIndex, 1);
                            
                            score += 10;
                            document.getElementById('archery-score').textContent = score;
                            showToast('🎯 Target hit! +10 points', 'success');
                            soundSystem.playSound('success');
                            
                            // 创建爆炸效果
                            particleSystem.createExplosion(targetCenterX, targetCenterY, 20);
                            
                            break; // 箭头击中目标后跳出内层循环
                        }
                    }
                }
            }

            function endArcheryGame(finalScore) {
                gameRunning = false;
                if (timer) clearInterval(timer);
                if (spawnInterval) clearInterval(spawnInterval);
                if (gameLoop) clearInterval(gameLoop);
                
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('archery-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Archery Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function showWizardCoinGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let coins = [];
            let timer = null;
            let gameLoop = null;
            let coinSpawnInterval = null;
            let wizardX = 200; // 巫师初始位置

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 800px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧙 巫师接金币游戏</h3>
                    <div id="wizard-coin-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>控制巫师左右移动接住下落的金币！</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>时间: <span id="wizard-time">${timeLeft}</span>s</div>
                                <div>分数: <span id="wizard-score">${score}</span></div>
                                <div>金币: <span id="coin-count">0</span></div>
                            </div>
                            <div id="wizard-game-area" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden;">
                                <div id="wizard-player" style="position: absolute; left: ${wizardX}px; bottom: 20px; width: 50px; height: 50px; font-size: 2.5rem; transition: all 0.1s ease;">🧙</div>
                                <div id="wizard-coins" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startWizardCoinGame()" id="start-wizard-btn" style="background: var(--success);">开始游戏</button>
                                <button class="btn" onclick="moveWizardLeft()" id="wizard-left-btn" disabled style="background: var(--accent);">← 左移</button>
                                <button class="btn" onclick="moveWizardRight()" id="wizard-right-btn" disabled style="background: var(--accent);">右移 →</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                使用左右箭头键或点击按钮控制巫师移动接住金币！
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startWizardCoinGame = function() {
                console.log('Starting wizard coin game...');
                gameRunning = true;
                score = 0;
                coins = [];
                wizardX = 200;
                
                // 重置时间
                timeLeft = 30;
                document.getElementById('wizard-time').textContent = timeLeft;
                
                document.getElementById('start-wizard-btn').disabled = true;
                document.getElementById('wizard-left-btn').disabled = false;
                document.getElementById('wizard-right-btn').disabled = false;
                
                // Reset wizard position
                const wizard = document.getElementById('wizard-player');
                wizard.style.left = wizardX + 'px';
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('wizard-time').textContent = timeLeft;
                    
                    if (timeLeft <= 0) {
                        endWizardCoinGame(score);
                    }
                }, 1000);

                // Spawn coins
                coinSpawnInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(coinSpawnInterval);
                        return;
                    }
                    spawnWizardCoin();
                }, 1500);

                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    
                    moveWizardCoins();
                    checkWizardCollisions();
                }, 16); // 60 FPS

                // Keyboard controls
                document.addEventListener('keydown', handleWizardKeyPress);
                
                soundSystem.playSound('gameStart');
                showToast('巫师接金币游戏开始！使用左右箭头键移动！', 'success');
            };

            function handleWizardKeyPress(e) {
                if (!gameRunning) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveWizardLeft();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveWizardRight();
                        break;
                }
            }

            window.moveWizardLeft = function() {
                if (!gameRunning) return;
                wizardX = Math.max(0, wizardX - 30);
                document.getElementById('wizard-player').style.left = wizardX + 'px';
            };

            window.moveWizardRight = function() {
                if (!gameRunning) return;
                const gameArea = document.getElementById('wizard-game-area');
                const maxX = gameArea.offsetWidth - 50;
                wizardX = Math.min(maxX, wizardX + 30);
                document.getElementById('wizard-player').style.left = wizardX + 'px';
            };

            function spawnWizardCoin() {
                const coinsContainer = document.getElementById('wizard-coins');
                const coin = document.createElement('div');
                coin.style.position = 'absolute';
                coin.style.left = Math.random() * 700 + 'px';
                coin.style.top = '0px';
                coin.style.width = '30px';
                coin.style.height = '30px';
                coin.style.fontSize = '1.5rem';
                coin.style.textAlign = 'center';
                coin.style.lineHeight = '30px';
                coin.style.background = 'var(--success)';
                coin.style.borderRadius = '50%';
                coin.style.animation = 'fallDown 3s linear forwards';
                coin.textContent = '🪙';
                
                coinsContainer.appendChild(coin);
                
                coins.push({
                    element: coin,
                    x: parseInt(coin.style.left),
                    y: 0,
                    width: 30,
                    height: 30,
                    speed: 2
                });
                
                setTimeout(() => {
                    if (coin.parentNode) {
                        coin.remove();
                        coins = coins.filter(c => c.element !== coin);
                    }
                }, 3000);
            }

            function moveWizardCoins() {
                coins.forEach((coin, index) => {
                    coin.y += coin.speed;
                    coin.element.style.top = coin.y + 'px';
                    
                    if (coin.y > 350) {
                        coin.element.remove();
                        coins.splice(index, 1);
                    }
                });
            }

            function checkWizardCollisions() {
                const wizard = document.getElementById('wizard-player');
                const wizardRect = wizard.getBoundingClientRect();
                const gameAreaRect = document.getElementById('wizard-game-area').getBoundingClientRect();
                
                const wizardX = wizardRect.left - gameAreaRect.left;
                const wizardY = wizardRect.top - gameAreaRect.top;
                const wizardWidth = 50;
                const wizardHeight = 50;
                
                coins.forEach((coin, index) => {
                    const coinX = coin.x;
                    const coinY = coin.y;
                    
                    if (wizardX < coinX + coin.width &&
                        wizardX + wizardWidth > coinX &&
                        wizardY < coinY + coin.height &&
                        wizardY + wizardHeight > coinY) {
                        // Coin collected
                        coin.element.remove();
                        coins.splice(index, 1);
                        score += 10;
                        document.getElementById('wizard-score').textContent = score;
                        document.getElementById('coin-count').textContent = Math.floor(score / 10);
                        soundSystem.playSound('collect');
                        particleSystem.createCollectEffect(coinX + coin.width/2, coinY + coin.height/2);
                        showToast('🪙 金币收集成功！+10分', 'success');
                    }
                });
            }

            function endWizardCoinGame(finalScore) {
                gameRunning = false;
                if (timer) clearInterval(timer);
                if (gameLoop) clearInterval(gameLoop);
                if (coinSpawnInterval) clearInterval(coinSpawnInterval);
                
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(400, 200, 30);
                
                document.getElementById('wizard-coin-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 巫师接金币游戏结束！</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">最终分数: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">收集金币: ${Math.floor(finalScore / 10)} 个</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">获得积分: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">关闭</button>
                    </div>
                `;
            }
        }

        function playComingSoon() {
            if (gameState.points < 10) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 10;
            gameState.gamesPlayed++;
            updateStats();
            showComingSoon();
        }

        function showComingSoon() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🚧 Coming Soon!</h3>
                    <div style="margin: 30px 0;">
                        <div style="font-size: 4rem; margin: 20px 0;">🚀</div>
                        <h4>New Games in Development!</h4>
                        <p style="color: var(--muted); margin: 20px 0;">
                            We're working hard to bring you more exciting Anoma games!
                        </p>
                        <div style="background: var(--surface); padding: 20px; border-radius: 10px; margin: 20px 0;">
                            <h5>Upcoming Features:</h5>
                            <ul style="text-align: left; margin: 10px 0;">
                                <li>🎮 Multiplayer Intent Battles</li>
                                <li>🧩 Advanced Privacy Puzzles</li>
                                <li>🏆 Tournament Mode</li>
                                <li>🎨 Custom Intent Builder</li>
                                <li>🌐 Cross-Chain Adventures</li>
                            </ul>
                        </div>
                        <div style="font-size: 1.2rem; margin: 20px 0; color: var(--accent);">
                            Stay tuned for updates!
                        </div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            soundSystem.playSound('success');
            particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 30);
        }

        // Add CSS for animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes moveLeft {
                from { right: -30px; }
                to { right: 100%; }
            }
            @keyframes fallDown {
                from { top: 0px; }
                to { top: 400px; }
            }
        `;
        document.head.appendChild(style);

        // Show toast
        function showToast(message, type) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            // Add animation based on type
            if (type === 'success') {
                toast.classList.add('animated-bounce');
                particleSystem.createParticle(window.innerWidth/2, 50, 'success');
            } else if (type === 'error') {
                toast.classList.add('animated-shake');
            }
            
            setTimeout(() => {
                toast.classList.remove('show');
                toast.classList.remove('animated-bounce');
                toast.classList.remove('animated-shake');
            }, 4000);
        }

        // Make Anoma Runner functions globally accessible
        window.startAnomaRunner = function() {
            // This will be set when showAnomaRunner is called
        };
        window.testAnomaJump = function() {
            // This will be set when showAnomaRunner is called
        };

        // Missing play functions
        function playShrimpCollector() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showShrimpCollector();
        }

        function playArcheryGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showArcheryGame();
        }

        function playWizardCoinGame() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showWizardCoinGame();
        }

        function playSnakeGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showSnakeGame();
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPuzzleGame();
        }

        function showSnakeGame() {
            let score = 0;
            let gameRunning = false;
            let snake = [{x: 10, y: 10}];
            let direction = {x: 0, y: 0};
            let food = {x: 15, y: 15};
            let gameLoop = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🐍 Intent Snake Game</h3>
                    <div id="snake-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Control the snake to collect Anoma shrimps!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>分数: <span id="snake-score">${score}</div>
                                <div>长度: <span id="snake-length">1</span></div>
                            </div>
                            <div id="snake-game-area" style="width: 400px; height: 400px; background: #000; border: 2px solid var(--accent); border-radius: 10px; position: relative; margin: 0 auto; display: grid; grid-template-columns: repeat(20, 1fr); grid-template-rows: repeat(20, 1fr);">
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                                    <h4>🐍 Intent Snake</h4>
                                    <p>Use arrow keys to control the snake!</p>
                                    <button class="btn" onclick="startSnakeGame()" style="margin-top: 10px;">Start Game</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startSnakeGame = function() {
                gameRunning = true;
                document.querySelector('#snake-game-area > div').style.display = 'none';
                
                // Reset game state
                snake = [{x: 10, y: 10}];
                direction = {x: 0, y: 0};
                score = 0;
                document.getElementById('snake-score').textContent = score;
                document.getElementById('snake-length').textContent = snake.length;
                
                const gameArea = document.getElementById('snake-game-area');
                
                function drawGame() {
                    gameArea.innerHTML = '';
                    
                    // Draw snake
                    snake.forEach((segment, index) => {
                        const cell = document.createElement('div');
                        cell.style.gridColumn = segment.x + 1;
                        cell.style.gridRow = segment.y + 1;
                        cell.style.background = index === 0 ? '#00ff88' : '#00d4ff';
                        cell.style.border = '1px solid #333';
                        cell.style.borderRadius = '2px';
                        gameArea.appendChild(cell);
                    });
                    
                    // Draw food
                    const foodCell = document.createElement('div');
                    foodCell.style.gridColumn = food.x + 1;
                    foodCell.style.gridRow = food.y + 1;
                    foodCell.style.background = '#ff6b6b';
                    foodCell.style.border = '1px solid #333';
                    foodCell.style.borderRadius = '50%';
                    foodCell.innerHTML = '🦐';
                    foodCell.style.display = 'flex';
                    foodCell.style.alignItems = 'center';
                    foodCell.style.justifyContent = 'center';
                    gameArea.appendChild(foodCell);
                }
                
                function moveSnake() {
                    if (!gameRunning) return;
                    
                    // Don't move if no direction is set
                    if (direction.x === 0 && direction.y === 0) {
                        drawGame();
                        return;
                    }
                    
                    const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
                    
                    // Check wall collision
                    if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20) {
                        endSnakeGame();
                        return;
                    }
                    
                    // Check self collision
                    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                        endSnakeGame();
                        return;
                    }
                    
                    snake.unshift(head);
                    
                    // Check food collision
                    if (head.x === food.x && head.y === food.y) {
                        score += 10;
                        document.getElementById('snake-score').textContent = score;
                        document.getElementById('snake-length').textContent = snake.length;
                        
                        // Generate new food
                        do {
                            food.x = Math.floor(Math.random() * 20);
                            food.y = Math.floor(Math.random() * 20);
                        } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
                    } else {
                        snake.pop();
                    }
                    
                    drawGame();
                }
                
                function endSnakeGame() {
                    gameRunning = false;
                    if (gameLoop) clearInterval(gameLoop);
                    
                    const pointsEarned = Math.floor(score / 5);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('snake-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Snake Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${score}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Snake Length: ${snake.length}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
                
                // Add keydown listener
                const keyHandler = function(e) {
                    if (!gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            if (direction.y !== 1) direction = {x: 0, y: -1};
                            break;
                        case 'ArrowDown':
                            if (direction.y !== -1) direction = {x: 0, y: 1};
                            break;
                        case 'ArrowLeft':
                            if (direction.x !== 1) direction = {x: -1, y: 0};
                            break;
                        case 'ArrowRight':
                            if (direction.x !== -1) direction = {x: 1, y: 0};
                            break;
                    }
                };
                
                document.addEventListener('keydown', keyHandler);
                
                drawGame();
                gameLoop = setInterval(moveSnake, 200);
            };
        }

        function showPuzzleGame() {
            let moves = 0;
            let puzzle = [1, 2, 3, 4, 5, 6, 7, 8, 0]; // 0 represents empty space
            let gameRunning = false;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Intent Puzzle Game</h3>
                    <div id="puzzle-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Solve the sliding puzzle to unlock Anoma secrets!</h4>
                            <p style="color: var(--muted); margin: 10px 0; font-size: 0.9rem;">
                                目标：将数字1-8按顺序排列，空位在右下角
                            </p>
                            <div style="margin: 20px 0;">
                                <div>移动次数: <span id="puzzle-moves">${moves}</span></div>
                            </div>
                            <div style="display: flex; gap: 20px; justify-content: center; align-items: center; margin: 20px 0;">
                                <div>
                                    <div style="font-size: 0.8rem; color: var(--muted); margin-bottom: 5px;">目标状态：</div>
                                    <div id="target-puzzle" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; width: 120px; height: 120px; background: #333; padding: 5px; border-radius: 5px;">
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">1</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">2</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">3</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">4</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">5</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">6</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">7</div>
                                        <div style="background: linear-gradient(135deg, #00d4ff, #10b981); color: white; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; border-radius: 2px;">8</div>
                                        <div style="background: #555; border-radius: 2px;"></div>
                                    </div>
                                </div>
                                <div>
                                    <div style="font-size: 0.8rem; color: var(--muted); margin-bottom: 5px;">当前状态：</div>
                                    <div id="puzzle-board" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; width: 300px; height: 300px; background: #333; padding: 10px; border-radius: 10px;">
                                    </div>
                                </div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startPuzzleGame()" style="margin-right: 10px;">Start Game</button>
                                <button class="btn" onclick="shufflePuzzle()" style="background: var(--warning);">Shuffle</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startPuzzleGame = function() {
                gameRunning = true;
                drawPuzzle();
            };

            window.shufflePuzzle = function() {
                // Shuffle the puzzle
                for (let i = puzzle.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [puzzle[i], puzzle[j]] = [puzzle[j], puzzle[i]];
                }
                moves = 0;
                document.getElementById('puzzle-moves').textContent = moves;
                drawPuzzle();
            };

            function drawPuzzle() {
                const board = document.getElementById('puzzle-board');
                board.innerHTML = '';
                
                puzzle.forEach((value, index) => {
                    const cell = document.createElement('div');
                    cell.style.background = value === 0 ? '#555' : 'linear-gradient(135deg, #00d4ff, #10b981)';
                    cell.style.color = 'white';
                    cell.style.display = 'flex';
                    cell.style.alignItems = 'center';
                    cell.style.justifyContent = 'center';
                    cell.style.fontSize = '2rem';
                    cell.style.fontWeight = 'bold';
                    cell.style.borderRadius = '5px';
                    cell.style.cursor = value === 0 ? 'default' : 'pointer';
                    cell.textContent = value === 0 ? '' : value;
                    
                    if (value !== 0) {
                        cell.onclick = () => movePiece(index);
                    }
                    
                    board.appendChild(cell);
                });
            }

            function movePiece(index) {
                if (!gameRunning) return;
                
                const emptyIndex = puzzle.indexOf(0);
                const row = Math.floor(index / 3);
                const col = index % 3;
                const emptyRow = Math.floor(emptyIndex / 3);
                const emptyCol = emptyIndex % 3;
                
                // Check if the piece is adjacent to empty space
                if ((Math.abs(row - emptyRow) === 1 && col === emptyCol) || 
                    (Math.abs(col - emptyCol) === 1 && row === emptyRow)) {
                    
                    [puzzle[index], puzzle[emptyIndex]] = [puzzle[emptyIndex], puzzle[index]];
                    moves++;
                    document.getElementById('puzzle-moves').textContent = moves;
                    drawPuzzle();
                    
                    // Check if puzzle is solved
                    if (isSolved()) {
                        endPuzzleGame();
                    }
                }
            }

            function isSolved() {
                for (let i = 0; i < puzzle.length - 1; i++) {
                    if (puzzle[i] !== i + 1) return false;
                }
                return puzzle[puzzle.length - 1] === 0;
            }

            function endPuzzleGame() {
                gameRunning = false;
                
                const pointsEarned = Math.max(10, 50 - moves);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('puzzle-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Puzzle Solved!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Moves: ${moves}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }

            // Initialize with shuffled puzzle
            shufflePuzzle();
        }
    </script>
    
    <!-- Author Information -->
    <div class="author-info">
        <h3>Created by</h3>
        <div class="author-links">
            <a href="https://twitter.com/251262871Com" target="_blank" class="author-btn">🐦 Twitter: @251262871Com</a>
            <a href="https://discord.com/users/More2591" target="_blank" class="author-btn">💬 Discord: More2591</a>
        </div>
    </div>
</body>
</html>

