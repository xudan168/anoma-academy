<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anoma Academy - Learn, Play, Master</title>
    <style>
        :root {
            --bg: #ffffff;
            --surface: #f8f9fa;
            --text: #1a1a1a;
            --muted: #666666;
            --accent: #00d4ff;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #e0e0e0;
            
            /* Anoma Brand Colors */
            --anoma-primary: #00d4ff;
            --anoma-secondary: #10b981;
            --anoma-accent: #6366f1;
            --anoma-gradient: linear-gradient(135deg, #00d4ff 0%, #10b981 50%, #6366f1 100%);
            --anoma-glow: 0 0 30px rgba(0, 212, 255, 0.3);
        }

        /* Dark theme variables */
        .dark-theme {
            --bg: #0a0a0a !important;
            --surface: #1a1a1a !important;
            --text: #ffffff !important;
            --muted: #888888 !important;
            --accent: #00d4ff !important;
            --success: #10b981 !important;
            --warning: #f59e0b !important;
            --danger: #ef4444 !important;
            --border: #333333 !important;
            
            /* Anoma Brand Colors for dark theme */
            --anoma-primary: #00d4ff !important;
            --anoma-secondary: #10b981 !important;
            --anoma-accent: #6366f1 !important;
            --anoma-gradient: linear-gradient(135deg, #00d4ff 0%, #10b981 50%, #6366f1 100%) !important;
            --anoma-glow: 0 0 30px rgba(0, 212, 255, 0.5) !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Login System Styles */
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .login-form {
            background: var(--surface);
            border: 2px solid var(--anoma-primary);
            border-radius: 20px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 212, 255, 0.3);
        }

        .login-form h3 {
            color: var(--anoma-primary);
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .login-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 16px;
            margin: 10px 0;
            background: var(--bg);
            color: var(--text);
        }

        .login-input:focus {
            outline: none;
            border-color: var(--anoma-primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .user-profile {
            background: var(--surface);
            border: 2px solid var(--anoma-secondary);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .user-profile h4 {
            color: var(--anoma-secondary);
            margin-bottom: 15px;
        }

        .user-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .user-stat {
            background: var(--bg);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .user-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--anoma-primary);
        }

        .user-stat-label {
            font-size: 0.9rem;
            color: var(--muted);
        }

        .demo-button {
            background: var(--anoma-gradient);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }

        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }


        /* Mobile Responsive Optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .card {
                margin-bottom: 15px;
                padding: 15px;
            }
            
            .game-section {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .game-card {
                padding: 15px;
            }
            
            .user-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .requirements-content {
                padding: 20px;
                margin: 10px;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            .timeline-item {
                flex-direction: column;
                text-align: center;
            }
            
            .timeline-day {
                margin-bottom: 10px;
            }
            
            .mascot-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .anoma-badges {
                flex-direction: column;
                gap: 5px;
            }
            
            .badge {
                font-size: 0.8rem;
                padding: 5px 10px;
            }
        }

        @media (max-width: 480px) {
            .main-title {
                font-size: 1.5rem;
            }
            
            .card h3 {
                font-size: 1.2rem;
            }
            
            .game-card h4 {
                font-size: 1rem;
            }
            
            .user-stats {
                grid-template-columns: 1fr;
            }
            
            .requirements-content {
                padding: 15px;
            }
            
            .demo-button {
                font-size: 0.9rem;
                padding: 8px 12px;
                margin: 5px;
            }
        }

        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 50px;
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-color: var(--accent);
        }

        .theme-toggle .icon {
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .theme-toggle:hover .icon {
            transform: rotate(180deg);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .anoma-logo-container {
            margin-bottom: 30px;
        }

        .banner-image {
            text-align: center;
            margin-bottom: 20px;
            width: 100vw;
            margin-left: calc(-50vw + 50%);
            margin-right: calc(-50vw + 50%);
        }

        .banner-img {
            width: 100%;
            height: auto;
            max-height: 250px;
            object-fit: cover;
            object-position: center;
            border-radius: 0;
            box-shadow: none;
            transition: transform 0.3s ease;
        }

        .banner-img:hover {
            transform: scale(1.01);
        }

        .anoma-tagline {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 20px 30px;
            margin: 25px auto;
            max-width: 700px;
            backdrop-filter: none;
        }

        .anoma-tagline p {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            color: var(--text);
            font-weight: 500;
        }

        .anoma-badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .badge {
            background: rgba(0, 212, 255, 0.1);
            color: var(--text);
            padding: 6px 14px;
            border-radius: 16px;
            font-size: 0.85rem;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .badge:hover {
            transform: translateY(-1px);
            background: rgba(0, 212, 255, 0.15);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }

        .main-title {
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d4ff 0%, #10b981 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
            letter-spacing: -0.02em;
            line-height: 1.1;
        }

        .main-subtitle {
            font-size: 1.1rem;
            color: var(--muted);
            margin-bottom: 25px;
            font-weight: 400;
            line-height: 1.4;
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .card h3 {
            color: var(--accent);
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent), var(--success));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            color: var(--muted);
            font-size: 0.9rem;
        }

        .learning-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .lesson-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lesson-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .lesson-card.unlocked {
            border-color: var(--success);
        }

        .lesson-card h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .cost {
            color: var(--success);
            font-weight: bold;
            margin-top: 10px;
        }

        .game-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .game-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .game-card:hover::before {
            left: 100%;
        }

        .game-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
        }

        .game-card h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .social-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .social-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .social-btn:hover {
            background: var(--accent);
            color: white;
        }

        .anoma-resources {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 20px;
        }

        .resource-category h4 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .social-btn.official {
            background: var(--anoma-gradient);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .social-btn.official:hover {
            background: var(--anoma-gradient);
            transform: translateY(-2px);
            box-shadow: var(--anoma-glow);
        }

        .social-btn.dev {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .social-btn.dev:hover {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
        }

        .anoma-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.05), rgba(16, 185, 129, 0.05));
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .feature-item:hover {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(16, 185, 129, 0.1));
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .feature-icon {
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent), var(--success));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .feature-text h4 {
            margin: 0 0 5px 0;
            color: var(--accent);
            font-size: 1.1rem;
        }

        .feature-text p {
            margin: 0;
            color: var(--muted);
            font-size: 0.9rem;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background: var(--surface);
            margin: 5% auto;
            padding: 20px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            position: relative;
        }

        .close-btn {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--muted);
            z-index: 1002;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            color: var(--text);
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .toast.show {
            opacity: 1;
        }

        .toast.success { background: var(--success); }
        .toast.error { background: var(--danger); }
        .toast.info { background: var(--accent); }
        .toast.warning { background: var(--warning); }

        /* 炫酷动画效果 */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px var(--accent); }
            50% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
            100% { box-shadow: 0 0 5px var(--accent); }
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-20px); }
            60% { transform: translateY(-10px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes rainbow {
            0% { color: #ff0000; }
            16% { color: #ff8000; }
            33% { color: #ffff00; }
            50% { color: #00ff00; }
            66% { color: #0080ff; }
            83% { color: #8000ff; }
            100% { color: #ff0000; }
        }

        .animated-pulse { animation: pulse 2s infinite; }
        .animated-glow { animation: glow 2s infinite; }
        .animated-float { animation: float 3s ease-in-out infinite; }
        .animated-spin { animation: spin 1s linear infinite; }
        .animated-bounce { animation: bounce 1s infinite; }
        .animated-shake { animation: shake 0.5s ease-in-out; }
        .animated-rainbow { animation: rainbow 3s linear infinite; }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 212, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--anoma-primary);
            animation: spin 1s ease-in-out infinite;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            backdrop-filter: blur(10px);
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-content h3 {
            margin-bottom: 20px;
            color: var(--anoma-primary);
        }

        .game-card:hover {
            animation: pulse 0.6s ease-in-out;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }

        .lesson-card:hover {
            animation: glow 1s ease-in-out;
        }

        .stat-value {
            animation: float 4s ease-in-out infinite;
        }

        .main-title {
            animation: glow 3s ease-in-out infinite;
        }

        .mascot-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .mascot-shrimp {
            font-size: 2rem;
            cursor: pointer;
            transition: transform 0.3s ease;
            user-select: none;
        }

        .mascot-shrimp:hover {
            transform: scale(1.2) rotate(10deg);
        }

        .mascot-shrimp:active {
            transform: scale(0.9) rotate(-10deg);
        }

        .mascot-shrimp.clicked {
            animation: bounce 0.6s ease-in-out;
        }

        /* Game Categories */
        .game-category {
            margin-bottom: 30px;
        }

        .category-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            padding: 10px 20px;
            border-radius: 10px;
            border-left: 4px solid;
        }

        .category-knowledge {
            color: var(--success);
            background: rgba(16, 185, 129, 0.1);
            border-left-color: var(--success);
        }

        .category-intent {
            color: var(--accent);
            background: rgba(0, 212, 255, 0.1);
            border-left-color: var(--accent);
        }

        .category-puzzle {
            color: var(--warning);
            background: rgba(245, 158, 11, 0.1);
            border-left-color: var(--warning);
        }


        .category-action {
            color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
            border-left-color: var(--danger);
        }

        .category-speed {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            border-left-color: #00ff88;
        }

        @media (max-width: 768px) {
            .main-title { font-size: 2rem; }
            .learning-section, .game-section { grid-template-columns: 1fr; }
            .social-links { grid-template-columns: 1fr; }
            
            .modal-content {
                width: 95% !important;
                height: 95vh !important;
                margin: 2.5vh auto !important;
            }
            
            .tower-btn {
                min-width: 150px !important;
                padding: 12px !important;
            }
            
            .tower-btn div:first-child {
                font-size: 1.5rem !important;
            }
            
            .tower-btn div:nth-child(2) {
                font-size: 1rem !important;
            }
            
            .tower-btn div:last-child {
                font-size: 0.8rem !important;
            }
        }
        .author-info {
            text-align: center;
            margin: 40px 0 20px 0;
            padding: 20px;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 12px;
        }

        .author-info h3 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .author-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .author-btn {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(0, 212, 255, 0.1);
            color: var(--accent);
            text-decoration: none;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .author-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }

        .game-card.coming-soon {
            opacity: 0.7;
            border-style: dashed;
        }

        .game-card.coming-soon:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
        <!-- Login Modal -->
        <div id="login-modal" class="login-modal" style="display: none;">
            <div class="login-form">
                <h3 data-translate="welcome">🎮 Welcome to Anoma Academy</h3>
                <p data-translate="login-desc">Create an account to save your progress and compete with other players!</p>
                
                <input type="text" id="username-input" class="login-input" data-translate="username" placeholder="Enter username">
                <input type="email" id="email-input" class="login-input" data-translate="email" placeholder="Enter email (optional)">
                
                <div style="margin-top: 20px;">
                    <button class="demo-button" onclick="login()" data-translate="login-register">Login / Register</button>
                    <button class="demo-button" onclick="guestLogin()" data-translate="guest-mode" style="background: var(--muted);">Guest Mode</button>
                </div>
            </div>
        </div>
    <!-- Theme Toggle Button (Hidden) -->
    <button class="theme-toggle" id="theme-toggle-btn" onclick="toggleTheme()" style="display: none;">
        <span class="icon">🌙</span>
        <span class="text">Dark Mode</span>
    </button>
    
    <!-- Theme Toggle Button -->
    <button class="theme-btn" onclick="switchTheme()" style="position: fixed; top: 20px; left: 20px; z-index: 9999; background: #00d4ff; color: white; padding: 12px 20px; border: none; border-radius: 25px; cursor: pointer; font-size: 14px; font-weight: 500; box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
        <span id="theme-icon">🌙</span>
        <span id="theme-text">Dark Mode</span>
    </button>
    
    <!-- Language Toggle Button -->
    <button class="lang-btn" onclick="switchLanguage()" style="position: fixed; top: 80px; right: 20px; z-index: 9999; background: #10b981; color: white; padding: 12px 20px; border: none; border-radius: 25px; cursor: pointer; font-size: 14px; font-weight: 500; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
        <span id="lang-icon">🌐</span>
        <span id="lang-text">中文</span>
    </button>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
            <h3>🎓 Anoma Academy</h3>
            <div class="loading-spinner"></div>
            <p style="margin-top: 20px;">Loading your learning experience...</p>
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="anoma-logo-container">
                <div class="banner-image">
                    <img src="aaaa.jpg" alt="Anoma Academy Banner" class="banner-img">
                </div>
                <div class="anoma-tagline">
                    <p data-translate="academy-title">🎓 Welcome to Anoma Academy - Your Gateway to Mastering Intent-Centric Blockchain Technology</p>
                    <p data-translate="academy-desc" style="font-size: 1rem; color: var(--muted); margin-top: 10px;">
                        Learn, earn points, and play games while discovering the revolutionary world of Anoma's privacy-preserving cross-chain operations. 
                        From racing through blockchain networks to solving puzzles, our interactive platform makes complex blockchain concepts accessible and fun for everyone.
                    </p>
                    <div class="anoma-badges">
                        <span class="badge" data-translate="interactive-learning">🎮 Interactive Learning</span>
                        <span class="badge" data-translate="gamified-education">🏆 Gamified Education</span>
                        <span class="badge" data-translate="racing-games">🏎️ Racing Games</span>
                        <span class="badge" data-translate="future-ready-skills">🚀 Future-Ready Skills</span>
                    </div>
                </div>
            </div>
            <div class="mascot-container">
                <div class="mascot-shrimp animated-float">🦐</div>
                <div class="mascot-shrimp animated-float" style="animation-delay: 0.5s;">🦐</div>
                <div class="mascot-shrimp animated-float" style="animation-delay: 1s;">🦐</div>
            <div class="mascot-shrimp animated-float" style="animation-delay: 1.5s;">🦐</div>
            </div>
        </div>

        <!-- Player Stats -->
        <div class="card">
            <h3 data-translate="your-progress">📊 Your Progress</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div id="points" class="stat-value">1000</div>
                    <div class="stat-label" data-translate="points">Points</div>
                </div>
                <div class="stat-item">
                    <div id="level" class="stat-value">1</div>
                    <div class="stat-label" data-translate="level">Level</div>
                </div>
                <div class="stat-item">
                    <div id="lessons-completed" class="stat-value">0/6</div>
                    <div class="stat-label" data-translate="lessons-completed">Lessons</div>
                </div>
                <div class="stat-item">
                    <div id="games-played" class="stat-value">0</div>
                    <div class="stat-label" data-translate="games-played">Games Played</div>
                </div>
            </div>
            <div class="sound-controls" style="margin-top: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button class="btn" onclick="toggleSound()" id="sound-btn" style="background: var(--success); font-size: 0.9rem; padding: 8px 12px;">
                    <span data-translate="sound-on">🔊 Sound On</span>
                </button>
                <button class="btn" onclick="toggleMusic()" id="music-btn" style="background: var(--accent); font-size: 0.9rem; padding: 8px 12px;">
                    <span data-translate="music-on">🎵 Music On</span>
                </button>
                <button class="btn" onclick="showDifficultySelector()" id="difficulty-btn" style="background: var(--warning); font-size: 0.9rem; padding: 8px 12px;">
                    <span data-translate="difficulty">🎯 Easy</span>
                </button>
            </div>
        </div>

        <!-- Learning Section -->
        <div class="card">
            <h3 data-translate="learn-concepts">🎓 Learn Anoma Concepts</h3>
            <p data-translate="learn-desc" style="color: var(--muted); margin-bottom: 20px;">
                Complete lessons to earn points and unlock games. Each lesson teaches you about Anoma's core concepts.
            </p>
            <div class="learning-section">
                <div class="lesson-card unlocked" onclick="startLesson(1)">
                    <h4 data-translate="lesson1-title">🌱 What is Anoma?</h4>
                    <p data-translate="lesson1-desc">Learn the basics of intent-centric blockchain</p>
                    <div class="cost" data-translate="reward-50">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(2)">
                    <h4 data-translate="lesson2-title">⚡ Intent System</h4>
                    <p data-translate="lesson2-desc">Understand how intents work in Anoma</p>
                    <div class="cost" data-translate="reward-50">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(3)">
                    <h4 data-translate="lesson3-title">🔐 Privacy & ZK</h4>
                    <p data-translate="lesson3-desc">Learn about zero-knowledge proofs</p>
                    <div class="cost" data-translate="reward-50">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(4)">
                    <h4 data-translate="lesson4-title">🌐 Cross-Chain</h4>
                    <p data-translate="lesson4-desc">Understand cross-chain operations</p>
                    <div class="cost" data-translate="reward-50">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(5)">
                    <h4 data-translate="lesson5-title">🎯 Advanced Intents</h4>
                    <p data-translate="lesson5-desc">Master complex intent strategies</p>
                    <div class="cost" data-translate="reward-50">Reward: 50 points</div>
                </div>
                <div class="lesson-card" onclick="startLesson(6)">
                    <h4 data-translate="lesson6-title">🏆 Anoma Master</h4>
                    <p data-translate="lesson6-desc">Become an Anoma expert</p>
                    <div class="cost" data-translate="reward-100">Reward: 100 points</div>
                </div>
            </div>
        </div>

        <!-- User Profile -->
        <div id="user-profile" class="user-profile" style="display: none;">
            <h4><span data-translate="welcome-user">Welcome, </span><span id="user-name">Player</span>!</h4>
            <p data-translate="progress-saved">Your progress is automatically saved to your account.</p>
            
            <div class="user-stats">
                <div class="user-stat">
                    <div class="user-stat-value" id="user-points">0</div>
                    <div class="user-stat-label" data-translate="total-points">Total Points</div>
                </div>
                <div class="user-stat">
                    <div class="user-stat-value" id="user-level">1</div>
                    <div class="user-stat-label" data-translate="level">Level</div>
                </div>
                <div class="user-stat">
                    <div class="user-stat-value" id="user-games">0</div>
                    <div class="user-stat-label" data-translate="games-played">Games Played</div>
                </div>
                <div class="user-stat">
                    <div class="user-stat-value" id="user-wins">0</div>
                    <div class="user-stat-label" data-translate="wins">Wins</div>
                </div>
            </div>
            <div style="margin-top: 15px;">
                <button class="demo-button" onclick="addPoints(100)" data-translate="test-points" style="background: var(--success); margin-right: 10px;">+100 Test Points</button>
                <button class="demo-button" onclick="showUserStats()" style="background: var(--warning); margin-right: 10px;">📊 详细统计</button>
                <button class="demo-button" onclick="logout()" data-translate="logout" style="background: var(--danger);">Logout</button>
            </div>
        </div>

        <!-- Intent-Centric Demo Section -->
        <div class="card">
            <h3 data-translate="intent-demo">🎯 Intent-Centric Demo</h3>
            <p data-translate="intent-desc" style="color: var(--muted); margin-bottom: 20px;">
                Experience revolutionary intent-centric trading - express your trading needs in natural language and let AI find the best execution path for you!
            </p>
            
            <div style="background: var(--surface); padding: 25px; border-radius: 15px; margin-bottom: 20px; border: 2px solid var(--anoma-primary);">
                <h4 data-translate="enter-intent" style="color: var(--anoma-primary); margin-bottom: 15px;">💬 Enter Your Trading Intent</h4>
                <input type="text" id="intent-input" data-translate="intent-placeholder" placeholder="e.g., I want to buy ETH with 100 USDC when ETH price is below $2000, then stake it on Lido for 5% APY" 
                       style="width: 100%; padding: 15px; border: 2px solid var(--border); border-radius: 12px; font-size: 16px; background: var(--bg); color: var(--text); margin-bottom: 15px;">
                
                <div style="text-align: center;">
                    <button class="demo-button" onclick="buildIntent()" data-translate="build-intent" style="background: var(--anoma-primary); margin-right: 10px;">Build Intent</button>
                    <button class="demo-button" onclick="simulateExecution()" data-translate="simulate-execution" style="background: var(--success); margin-right: 10px;">Simulate Execution</button>
                    <button class="demo-button" onclick="connectWallet()" data-translate="connect-wallet" style="background: var(--anoma-accent);">Connect Wallet</button>
                </div>
                
                <div id="intent-result" style="margin-top: 20px; padding: 20px; background: var(--bg); border-radius: 12px; display: none; border: 1px solid var(--border);">
                    <h4 data-translate="intent-success" style="color: var(--success); margin-bottom: 15px;">✅ Intent Generated Successfully!</h4>
                    <div id="intent-details"></div>
                </div>
            </div>
        </div>

        <!-- Game Section -->
        <div class="card">
            <h3 data-translate="play-games">🎮 Play Games with Your Points</h3>
            <p data-translate="games-desc" style="color: var(--muted); margin-bottom: 20px;">
                Use your earned points to play games that teach you more about Anoma concepts.
            </p>
            
            <!-- Knowledge Games Category -->
            <div class="game-category">
                <h4 class="category-title category-knowledge" data-translate="knowledge-games">🧠 Knowledge Games</h4>
            <div class="game-section">
                <div class="game-card">
                    <h4 data-translate="anoma-quiz">🧠 Anoma Master Quiz</h4>
                    <p data-translate="anoma-quiz-desc">Advanced knowledge test with comprehensive Anoma concepts</p>
                    <div class="cost" data-translate="cost-50">Cost: 50 points</div>
                    <button class="btn" onclick="playAnomaQuiz()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="intent-matching">🎯 Intent Matching Game</h4>
                    <p data-translate="intent-matching-desc">Match intents with their optimal execution paths</p>
                    <div class="cost" data-translate="cost-20">Cost: 20 points</div>
                    <button class="btn" onclick="playIntentGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="intent-detective">🔍 Intent Detective</h4>
                    <p data-translate="intent-detective-desc">Analyze complex intents and find the best path</p>
                    <div class="cost" data-translate="cost-35">Cost: 35 points</div>
                    <button class="btn" onclick="playDetectiveGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="speed-intent">⚡ Speed Intent</h4>
                    <p data-translate="speed-intent-desc">Express intents as fast as possible</p>
                    <div class="cost" data-translate="cost-25">Cost: 25 points</div>
                    <button class="btn" onclick="playSpeedGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="intent-dice">🎲 Intent Dice</h4>
                    <p data-translate="intent-dice-desc">Roll dice to build intent combinations</p>
                    <div class="cost" data-translate="cost-25">Cost: 25 points</div>
                    <button class="btn" onclick="playDiceGame()" data-translate="play-game">Play Game</button>
                </div>
                </div>
            </div>

            <!-- Puzzle & Visual Games Category -->
            <div class="game-category">
                <h4 class="category-title category-puzzle" data-translate="puzzle-games">🧩 Puzzle & Visual Games</h4>
                <div class="game-section">
                <div class="game-card">
                    <h4 data-translate="privacy-puzzle">🔐 Privacy Puzzle</h4>
                    <p data-translate="privacy-puzzle-desc">Solve puzzles using zero-knowledge concepts</p>
                    <div class="cost" data-translate="cost-30">Cost: 30 points</div>
                    <button class="btn" onclick="playPrivacyGame()" data-translate="play-game">Play Game</button>
                </div>
                        <div class="game-card">
                            <h4 data-translate="privacy-puzzle-visual">🧩 Privacy Puzzle (Visual)</h4>
                            <p data-translate="privacy-puzzle-visual-desc">Drag and drop ZK proof components</p>
                    <div class="cost" data-translate="cost-35">Cost: 35 points</div>
                            <button class="btn" onclick="playPuzzleGame()" data-translate="play-game">Play Game</button>
                        </div>
                        <div class="game-card">
                            <h4 data-translate="anoma-memory">🧠 Anoma Memory</h4>
                            <p data-translate="anoma-memory-desc">Match Anoma concepts and test your memory</p>
                            <div class="cost" data-translate="cost-25">Cost: 25 points</div>
                            <button class="btn" onclick="playMemoryGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="privacy-guardian">🛡️ Privacy Guardian</h4>
                    <p data-translate="privacy-guardian-desc">Protect user data using ZK proofs</p>
                    <div class="cost" data-translate="cost-30">Cost: 30 points</div>
                    <button class="btn" onclick="playGuardianGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="intent-builder">🎯 Intent Builder</h4>
                    <p data-translate="intent-builder-desc">Create complex multi-step intents</p>
                    <div class="cost" data-translate="cost-50">Cost: 50 points</div>
                    <button class="btn" onclick="playBuilderGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="tower-defense">🎮 Intent Tower Defense</h4>
                    <p data-translate="tower-defense-desc">Defend against attacks using Anoma tools</p>
                    <div class="cost" data-translate="cost-60">Cost: 60 points</div>
                    <button class="btn" onclick="playTowerDefense()" data-translate="play-game">Play Game</button>
                </div>
                </div>
            </div>

            <!-- Action & Arcade Games Category -->
            <div class="game-category">
                <h4 class="category-title category-action" data-translate="action-games">🎮 Action & Arcade Games</h4>
                <div class="game-section">
                <div class="game-card">
                    <h4 data-translate="shrimp-jump">🦐 Shrimp Jump Game</h4>
                    <p data-translate="shrimp-jump-desc">Control the shrimp to jump and avoid obstacles</p>
                    <div class="cost" data-translate="cost-30">Cost: 30 points</div>
                    <button class="btn" onclick="playShrimpJumpGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="shrimp-collector">🦐 Shrimp Collector</h4>
                    <p data-translate="shrimp-collector-desc">Collect Anoma shrimps in this fun arcade game</p>
                    <div class="cost" data-translate="cost-20">Cost: 20 points</div>
                    <button class="btn" onclick="playShrimpCollector()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="wizard-coin">🧙 Wizard Coin Game</h4>
                    <p data-translate="wizard-coin-desc">Control wizard to catch falling coins</p>
                    <div class="cost" data-translate="cost-20">Cost: 20 points</div>
                    <button class="btn" onclick="playWizardCoinGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="intent-archery">🎯 Intent Archery</h4>
                    <p data-translate="intent-archery-desc">Shoot intents at targets with precision</p>
                    <div class="cost" data-translate="cost-30">Cost: 30 points</div>
                    <button class="btn" onclick="playArcheryGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="intent-snake">🐍 Intent Snake</h4>
                    <p data-translate="intent-snake-desc">Control the snake to collect Anoma shrimps</p>
                    <div class="cost" data-translate="cost-25">Cost: 25 points</div>
                    <button class="btn" onclick="playSnakeGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="anoma-racing">🏎️ Anoma Racing</h4>
                    <p data-translate="anoma-racing-desc">Race through Anoma's blockchain network and collect tokens</p>
                    <div class="cost" data-translate="cost-40">Cost: 40 points</div>
                    <button class="btn" onclick="playRacingGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card">
                    <h4 data-translate="anoma-tetris">🧩 Anoma Tetris</h4>
                    <p data-translate="anoma-tetris-desc">Classic Tetris with Anoma-themed blocks and blockchain concepts</p>
                    <div class="cost" data-translate="cost-30">Cost: 30 points</div>
                    <button class="btn" onclick="playTetrisGame()" data-translate="play-game">Play Game</button>
                </div>
                <div class="game-card coming-soon">
                    <h4 data-translate="coming-soon-title">🎮 More Games Coming Soon!</h4>
                    <p data-translate="coming-soon-desc">Stay tuned for exciting new Anoma games</p>
                    <div class="cost" data-translate="coming-soon">Coming Soon</div>
                    <button class="btn" onclick="playComingSoon()" style="background: var(--muted);" data-translate="coming-soon">Coming Soon</button>
                </div>
                </div>
            </div>
        </div>


        <!-- Anoma Brand Section -->
        <div class="card">
            <h3 data-translate="about-anoma">⚡ About Anoma</h3>
            <p data-translate="about-anoma-desc" style="color: var(--muted); margin-bottom: 20px;">
                Anoma is the first intent-centric blockchain that enables privacy-preserving cross-chain operations. 
                Learn more about our revolutionary technology and join the future of Web3!
            </p>
            <div class="anoma-features">
                <div class="feature-item">
                    <div class="feature-icon">🎯</div>
                    <div class="feature-text">
                        <h4 data-translate="feature1-title">Intent-Centric</h4>
                        <p data-translate="feature1-desc">Express what you want, not how to do it</p>
                    </div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">🔐</div>
                    <div class="feature-text">
                        <h4 data-translate="feature2-title">Privacy-First</h4>
                        <p data-translate="feature2-desc">Zero-knowledge proofs protect your data</p>
                    </div>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">🌐</div>
                    <div class="feature-text">
                        <h4 data-translate="feature3-title">Cross-Chain</h4>
                        <p data-translate="feature3-desc">Seamless operations across all chains</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Anoma Official Links -->
        <div class="card">
            <h3 data-translate="official-resources">⚡ Official Anoma Resources</h3>
            <p data-translate="official-resources-desc" style="color: var(--muted); margin-bottom: 20px;">
                Connect with the Anoma ecosystem and stay updated with the latest developments!
            </p>
            <div class="anoma-resources">
                <div class="resource-category">
                    <h4>🌐 Official Channels</h4>
            <div class="social-links">
                        <a href="https://anoma.network" target="_blank" class="social-btn official">
                            <span>🏠</span> Official Website
                        </a>
                        <a href="https://twitter.com/anoma" target="_blank" class="social-btn official">
                            <span>🐦</span> Twitter
                        </a>
                        <a href="https://discord.gg/anoma" target="_blank" class="social-btn official">
                            <span>💬</span> Discord
                        </a>
                    </div>
                </div>
                <div class="resource-category">
                    <h4>💻 Developer Resources</h4>
                    <div class="social-links">
                        <a href="https://github.com/anoma" target="_blank" class="social-btn dev">
                            <span>💻</span> GitHub
                        </a>
                        <a href="https://docs.anoma.network" target="_blank" class="social-btn dev">
                            <span>📚</span> Documentation
                        </a>
                        <a href="https://anoma.network/blog" target="_blank" class="social-btn dev">
                            <span>📝</span> Blog
                        </a>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>

    <script>
        // Login and User Management System
        let currentUser = null;
        let userData = {};

        // Check if user is logged in on page load
        window.addEventListener('load', function() {
            checkLoginStatus();
        });

        function checkLoginStatus() {
            const savedUser = localStorage.getItem('anoma-user');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                userData = JSON.parse(localStorage.getItem('anoma-user-data') || '{}');
                showUserProfile();
                updateUserStats();
            } else {
                showLoginModal();
            }
        }

        function showLoginModal() {
            document.getElementById('login-modal').style.display = 'flex';
        }

        function hideLoginModal() {
            document.getElementById('login-modal').style.display = 'none';
        }

        function login() {
            const username = document.getElementById('username-input').value.trim();
            const email = document.getElementById('email-input').value.trim();
            
            if (!username) {
                alert('请输入用户名！');
                return;
            }

            // Check if user already exists
            const existingUser = Object.values(userData).find(user => user.username === username);
            if (existingUser) {
                // Find the user ID
                const userId = Object.keys(userData).find(id => userData[id].username === username);
                currentUser = {
                    username: username,
                    email: email,
                    id: userId,
                    joinDate: existingUser.joinDate || new Date().toISOString()
                };
            } else {
                // Create new user account
                currentUser = {
                    username: username,
                    email: email,
                    id: Date.now().toString(),
                    joinDate: new Date().toISOString()
                };

                // Initialize user data for new user
                userData[currentUser.id] = {
                    points: 1000,  // 初始积分
                    level: 1,
                    gamesPlayed: 0,
                    wins: 0,
                    achievements: [],
                    gameHistory: []
                };
            }

            // Save to localStorage
            localStorage.setItem('anoma-user', JSON.stringify(currentUser));
            localStorage.setItem('anoma-user-data', JSON.stringify(userData));

            hideLoginModal();
            showUserProfile();
            updateUserStats();
            
            alert(`欢迎来到 Anoma Academy, ${username}! 您的进度将自动保存。`);
        }

        function guestLogin() {
            currentUser = {
                username: '游客玩家',
                email: '',
                id: 'guest',
                joinDate: new Date().toISOString()
            };

            userData = {
                'guest': {
                    points: 1000,
                    level: 1,
                    gamesPlayed: 0,
                    wins: 0,
                    achievements: [],
                    gameHistory: []
                }
            };

            hideLoginModal();
            showUserProfile();
            updateUserStats();
            
            alert('以游客身份游戏。您的进度仅在此会话中保存。');
        }

        function showUserProfile() {
            document.getElementById('user-profile').style.display = 'block';
            document.getElementById('user-name').textContent = currentUser.username;
        }

        function updateUserStats() {
            if (!currentUser || !userData[currentUser.id]) return;

            const user = userData[currentUser.id];
            document.getElementById('user-points').textContent = user.points;
            document.getElementById('user-level').textContent = user.level;
            document.getElementById('user-games').textContent = user.gamesPlayed;
            document.getElementById('user-wins').textContent = user.wins;

            // Update main stats display
            document.getElementById('points').textContent = user.points;
            document.getElementById('level').textContent = user.level;
            document.getElementById('games-played').textContent = user.gamesPlayed;
            document.getElementById('wins').textContent = user.wins;
        }

        function saveUserProgress(pointsEarned = 0, gameWon = false) {
            if (!currentUser || !userData[currentUser.id]) return;

            const user = userData[currentUser.id];
            const oldPoints = user.points;
            user.points += pointsEarned;
            user.gamesPlayed += 1;
            if (gameWon) user.wins += 1;

            // Level up calculation
            const newLevel = Math.floor(user.points / 1000) + 1;
            if (newLevel > user.level) {
                user.level = newLevel;
                alert(`🎉 升级了！您现在等级 ${user.level}！`);
            }

            // Save to localStorage
            localStorage.setItem('anoma-user-data', JSON.stringify(userData));
            updateUserStats();
            
            // Show points earned notification
            if (pointsEarned > 0) {
                showPointsNotification(pointsEarned, user.points);
            }
        }

        function showPointsNotification(pointsEarned, totalPoints) {
            // Create a floating notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(45deg, #00d4ff, #10b981);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
                animation: slideInRight 0.5s ease;
            `;
            notification.innerHTML = `+${pointsEarned} 积分！<br>总计: ${totalPoints}`;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        function logout() {
            currentUser = null;
            userData = {};
            document.getElementById('user-profile').style.display = 'none';
            showLoginModal();
        }

        // Add points directly to user account
        function addPoints(points) {
            if (!currentUser || !userData[currentUser.id]) return;
            
            const user = userData[currentUser.id];
            user.points += points;
            
            // Level up calculation
            const newLevel = Math.floor(user.points / 1000) + 1;
            if (newLevel > user.level) {
                user.level = newLevel;
                alert(`🎉 升级了！您现在等级 ${user.level}！`);
            }
            
            // Save to localStorage
            localStorage.setItem('anoma-user-data', JSON.stringify(userData));
            updateUserStats();
            
            // Show points notification
            showPointsNotification(points, user.points);
        }


        // Close modal function
        function closeModal() {
            const modals = document.querySelectorAll('.modal, .requirements-modal');
            modals.forEach(modal => modal.remove());
        }

        // Intent-Centric Trading Functions
        function buildIntent() {
            const input = document.getElementById('intent-input').value;
            if (!input.trim()) {
                const isChinese = currentLanguage === 'zh';
                const message = isChinese ? '请输入您的交易意图！' : 'Please enter your trading intent!';
                alert(message);
                return;
            }

            // Simulate AI processing
            const intent = {
                originalText: input,
                action: extractAction(input),
                tokens: extractTokens(input),
                protocols: extractProtocols(input),
                conditions: extractConditions(input),
                confidence: calculateConfidence(input),
                estimatedGas: calculateGasEstimate(input),
                riskLevel: assessRisk(input),
                executionPath: generateExecutionPath(input)
            };

            displayIntentResult(intent);
            document.getElementById('intent-result').style.display = 'block';
        }

        function extractAction(text) {
            const lowerText = text.toLowerCase();
            if (lowerText.includes('swap') || lowerText.includes('exchange') || lowerText.includes('购买') || lowerText.includes('交换')) return 'swap';
            if (lowerText.includes('stake') || lowerText.includes('质押')) return 'stake';
            if (lowerText.includes('lend') || lowerText.includes('supply') || lowerText.includes('借贷')) return 'lend';
            if (lowerText.includes('borrow') || lowerText.includes('借款')) return 'borrow';
            if (lowerText.includes('provide') || lowerText.includes('add liquidity') || lowerText.includes('提供流动性')) return 'provide';
            if (lowerText.includes('withdraw') || lowerText.includes('提取')) return 'withdraw';
            if (lowerText.includes('bridge') || lowerText.includes('跨链')) return 'bridge';
            return 'complex_trading';
        }

        function extractTokens(text) {
            const tokens = [];
            const tokenMap = {
                'USDC': ['usdc', 'usd coin'],
                'ETH': ['eth', 'ethereum', '以太坊'],
                'USDT': ['usdt', 'tether'],
                'DAI': ['dai', 'dai stablecoin'],
                'WBTC': ['wbtc', 'wrapped bitcoin']
            };
            
            Object.entries(tokenMap).forEach(([token, keywords]) => {
                if (keywords.some(keyword => text.toLowerCase().includes(keyword))) {
                    tokens.push(token);
                }
            });
            
            return tokens;
        }

        function extractProtocols(text) {
            const protocols = [];
            const protocolMap = {
                'Uniswap': ['uniswap', 'uni'],
                'SushiSwap': ['sushiswap', 'sushi'],
                'Aave': ['aave', 'lending', '借贷'],
                'Compound': ['compound', 'comp'],
                'Lido': ['lido', 'stake', '质押'],
                'Curve': ['curve', 'crv']
            };
            
            Object.entries(protocolMap).forEach(([protocol, keywords]) => {
                if (keywords.some(keyword => text.toLowerCase().includes(keyword))) {
                    protocols.push(protocol);
                }
            });
            
            return protocols;
        }

        function extractConditions(text) {
            const conditions = [];
            const lowerText = text.toLowerCase();
            
            // Price conditions
            const priceRegex = /(?:when|if|当|如果)\s+(?:price|cost|价格|成本)\s+(?:is|drops?|rises?|goes?|是|低于|高于|超过)\s+(\$?)(\d+(?:\.\d+)?)/gi;
            const priceMatches = text.match(priceRegex);
            
            if (priceMatches) {
                priceMatches.forEach(match => {
                    const valueMatch = match.match(/(\d+(?:\.\d+)?)/);
                    if (valueMatch) {
                        conditions.push({
                            type: 'price',
                            operator: match.includes('below') || match.includes('under') || match.includes('低于') ? 'less_than' : 'greater_than',
                            value: parseFloat(valueMatch[1]),
                            description: match.trim()
                        });
                    }
                });
            }
            
            return conditions;
        }

        function calculateConfidence(text) {
            let confidence = 0;
            const lowerText = text.toLowerCase();
            
            if (lowerText.includes('swap') || lowerText.includes('stake') || lowerText.includes('lend') || lowerText.includes('购买') || lowerText.includes('质押')) confidence += 20;
            if (lowerText.includes('usdc') || lowerText.includes('eth') || lowerText.includes('usdt') || lowerText.includes('以太坊')) confidence += 20;
            if (/\d+/.test(text)) confidence += 20;
            if (lowerText.includes('uniswap') || lowerText.includes('aave') || lowerText.includes('lido')) confidence += 20;
            if (lowerText.includes('when') || lowerText.includes('if') || lowerText.includes('below') || lowerText.includes('above') || lowerText.includes('当') || lowerText.includes('如果') || lowerText.includes('低于') || lowerText.includes('高于')) confidence += 20;
            
            return Math.min(confidence, 100);
        }

        function calculateGasEstimate(text) {
            let baseGas = 100000;
            const lowerText = text.toLowerCase();
            
            if (lowerText.includes('swap') || lowerText.includes('购买')) baseGas += 100000;
            if (lowerText.includes('stake') || lowerText.includes('质押')) baseGas += 150000;
            if (lowerText.includes('lend') || lowerText.includes('借贷')) baseGas += 200000;
            if (lowerText.includes('bridge') || lowerText.includes('跨链')) baseGas += 250000;
            if (lowerText.includes('when') || lowerText.includes('if') || lowerText.includes('当') || lowerText.includes('如果')) baseGas += 50000;
            
            const protocolCount = (lowerText.match(/uniswap|aave|lido|compound|curve/g) || []).length;
            baseGas += protocolCount * 30000;
            
            return (baseGas / 1000000).toFixed(4) + ' ETH';
        }

        function assessRisk(text) {
            let riskScore = 0;
            const lowerText = text.toLowerCase();
            
            if (lowerText.includes('bridge') || lowerText.includes('跨链')) riskScore += 3;
            if (lowerText.includes('borrow') || lowerText.includes('借款')) riskScore += 2;
            if (lowerText.includes('when') || lowerText.includes('if') || lowerText.includes('当') || lowerText.includes('如果')) riskScore += 2;
            if (lowerText.includes('automatically') || lowerText.includes('auto') || lowerText.includes('自动')) riskScore += 2;
            
            const protocolCount = (lowerText.match(/uniswap|aave|lido|compound|curve/g) || []).length;
            if (protocolCount > 2) riskScore += 2;
            
            if (riskScore <= 2) return 'low';
            if (riskScore <= 5) return 'medium';
            return 'high';
        }

        function generateExecutionPath(text) {
            const steps = [];
            const lowerText = text.toLowerCase();
            
            if (lowerText.includes('swap') || lowerText.includes('购买')) {
                steps.push('批准代币用于交换');
                steps.push('在DEX上执行交换');
            }
            
            if (lowerText.includes('stake') || lowerText.includes('质押')) {
                steps.push('批准代币用于质押');
                steps.push('在协议上质押代币');
            }
            
            if (lowerText.includes('lend') || lowerText.includes('借贷')) {
                steps.push('批准代币用于借贷');
                steps.push('向借贷协议提供代币');
            }
            
            if (lowerText.includes('bridge') || lowerText.includes('跨链')) {
                steps.push('批准代币用于跨链桥');
                steps.push('执行跨链桥交易');
            }
            
            if (lowerText.includes('when') || lowerText.includes('if') || lowerText.includes('当') || lowerText.includes('如果')) {
                steps.push('监控市场条件');
                steps.push('条件满足时执行');
            }
            
            return steps;
        }

        function displayIntentResult(intent) {
            const resultDiv = document.getElementById('intent-details');
            const isChinese = currentLanguage === 'zh';
            
            resultDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div><strong>${isChinese ? '动作' : 'Action'}:</strong> <span style="color: var(--anoma-primary);">${intent.action}</span></div>
                    <div><strong>${isChinese ? '置信度' : 'Confidence'}:</strong> <span style="color: var(--success);">${intent.confidence}%</span></div>
                    <div><strong>${isChinese ? '风险等级' : 'Risk Level'}:</strong> <span style="color: var(--warning);">${intent.riskLevel}</span></div>
                    <div><strong>${isChinese ? 'Gas估算' : 'Gas Estimate'}:</strong> <span style="color: var(--anoma-accent);">${intent.estimatedGas}</span></div>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>${isChinese ? '代币' : 'Tokens'}:</strong> ${intent.tokens.join(', ') || (isChinese ? '自动检测' : 'Auto-detected')}
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>${isChinese ? '协议' : 'Protocols'}:</strong> ${intent.protocols.join(', ') || (isChinese ? '自动选择' : 'Auto-selected')}
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>${isChinese ? '条件' : 'Conditions'}:</strong> ${intent.conditions.length} ${isChinese ? '个条件已检测' : 'conditions detected'}
                </div>
                <div>
                    <strong>${isChinese ? '执行路径' : 'Execution Path'}:</strong> ${intent.executionPath.join(' → ')}
                </div>
            `;
        }

        function simulateExecution() {
            const isChinese = currentLanguage === 'zh';
            const message = isChinese ? 
                '🚀 模拟意图执行...\n\n在真实实现中，这将在选定的区块链网络上执行您的意图。' :
                '🚀 Simulating intent execution...\n\nIn a real implementation, this would execute your intent on the selected blockchain network.';
            alert(message);
        }

        function connectWallet() {
            const isChinese = currentLanguage === 'zh';
            const message = isChinese ? 
                '💼 连接钱包...\n\n在真实实现中，这将连接到您的MetaMask或其他钱包。' :
                '💼 Connecting wallet...\n\nIn a real implementation, this would connect to your MetaMask or other wallet.';
            alert(message);
        }

        // User Statistics Modal
        function showUserStats() {
            if (!currentUser || !userData[currentUser.id]) return;
            
            const user = userData[currentUser.id];
            const isChinese = currentLanguage === 'zh';
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.background = 'rgba(0, 0, 0, 0.9)';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '10000';
            modal.style.backdropFilter = 'blur(10px)';
            modal.innerHTML = `
                <div style="background: var(--bg); border-radius: 20px; padding: 40px; max-width: 900px; width: 95%; max-height: 90vh; overflow-y: auto; border: 2px solid var(--anoma-primary); box-shadow: 0 20px 60px rgba(0, 212, 255, 0.3);">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <h2 style="color: var(--anoma-primary); font-size: 2.5rem; margin-bottom: 10px; background: var(--anoma-gradient); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;">📊 ${isChinese ? '用户详细统计' : 'User Detailed Statistics'}</h2>
                        <p style="color: var(--muted);">${isChinese ? '您的学习进度和游戏成就' : 'Your learning progress and game achievements'}</p>
                    </div>

                    <div style="margin-bottom: 30px; padding: 25px; background: var(--surface); border-radius: 15px; border-left: 4px solid var(--anoma-primary);">
                        <h3 style="color: var(--anoma-primary); font-size: 1.5rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">🎯 ${isChinese ? '学习进度' : 'Learning Progress'}</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                            <div style="background: var(--bg); padding: 15px; border-radius: 10px; border: 1px solid var(--border);">
                                <h4 style="color: var(--success); margin-bottom: 10px;">${isChinese ? '已完成课程' : 'Completed Lessons'}</h4>
                                <div style="font-size: 2rem; font-weight: bold; color: var(--anoma-primary);">${user.lessonsCompleted || 0}/6</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">${isChinese ? '课程完成率' : 'Completion Rate'}: ${Math.round((user.lessonsCompleted || 0) / 6 * 100)}%</div>
                            </div>
                            <div style="background: var(--bg); padding: 15px; border-radius: 10px; border: 1px solid var(--border);">
                                <h4 style="color: var(--warning); margin-bottom: 10px;">${isChinese ? '游戏成就' : 'Game Achievements'}</h4>
                                <div style="font-size: 2rem; font-weight: bold; color: var(--anoma-accent);">${user.achievements?.length || 0}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">${isChinese ? '获得成就' : 'Achievements Unlocked'}</div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px; padding: 25px; background: var(--surface); border-radius: 15px; border-left: 4px solid var(--anoma-primary);">
                        <h3 style="color: var(--anoma-primary); font-size: 1.5rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">🎮 ${isChinese ? '游戏统计' : 'Game Statistics'}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                            <div style="background: var(--bg); padding: 15px; border-radius: 10px; border: 1px solid var(--border); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--success);">${user.gamesPlayed || 0}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">${isChinese ? '总游戏次数' : 'Total Games'}</div>
                            </div>
                            <div style="background: var(--bg); padding: 15px; border-radius: 10px; border: 1px solid var(--border); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--warning);">${user.wins || 0}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">${isChinese ? '胜利次数' : 'Wins'}</div>
                            </div>
                            <div style="background: var(--bg); padding: 15px; border-radius: 10px; border: 1px solid var(--border); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--anoma-primary);">${user.points || 0}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">${isChinese ? '总积分' : 'Total Points'}</div>
                            </div>
                            <div style="background: var(--bg); padding: 15px; border-radius: 10px; border: 1px solid var(--border); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--anoma-accent);">${user.level || 1}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">${isChinese ? '当前等级' : 'Current Level'}</div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px; padding: 25px; background: var(--surface); border-radius: 15px; border-left: 4px solid var(--anoma-primary);">
                        <h3 style="color: var(--anoma-primary); font-size: 1.5rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">🏆 ${isChinese ? '最近成就' : 'Recent Achievements'}</h3>
                        <div style="margin: 20px 0;">
                            ${(user.achievements || []).length > 0 ? 
                                (user.achievements || []).map(achievement => `
                                    <div style="background: var(--bg); padding: 10px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                                        <span style="font-size: 1.2rem;">🏆</span>
                                        <span>${achievement}</span>
                                    </div>
                                `).join('') :
                                `<div style="text-align: center; color: var(--muted); padding: 20px;">
                                    ${isChinese ? '还没有获得成就，继续努力！' : 'No achievements yet, keep playing!'}
                                </div>`
                            }
                        </div>
                    </div>

                    <div style="text-align: center; margin-top: 30px;">
                        <button class="demo-button" onclick="closeModal()" style="background: var(--anoma-primary);">
                            ${isChinese ? '关闭' : 'Close'}
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
        }

        // Language switching functionality
        let currentLanguage = 'en'; // Default English
        
        // English and Chinese text content
        const translations = {
            en: {
                'play-games': '🎮 Play Games with Your Points',
                'games-desc': 'Use your earned points to play games that teach you more about Anoma concepts.',
                'knowledge-games': '🧠 Knowledge Games',
                'puzzle-games': '🧩 Puzzle Games',
                'action-games': '⚡ Action Games',
                'play': 'Play',
                'cost': 'Cost',
                'points': 'points',
                'welcome': 'Welcome to Anoma Academy!',
                'login-desc': 'Create an account to save your progress and compete with other players!',
                'username': 'Enter username',
                'email': 'Enter email (optional)',
                'login-register': 'Login / Register',
                'guest-mode': 'Guest Mode',
                'welcome-user': 'Welcome, ',
                'progress-saved': 'Your progress is automatically saved to your account.',
                'total-points': 'Total Points',
                'level': 'Level',
                'games-played': 'Games Played',
                'wins': 'Wins',
                'test-points': '+100 Test Points',
                'logout': 'Logout',
                'intent-demo': '🎯 Intent-Centric Demo',
                'intent-desc': 'Experience revolutionary intent-centric trading - express your trading needs in natural language and let AI find the best execution path for you!',
                'enter-intent': '💬 Enter Your Trading Intent',
                'intent-placeholder': 'e.g., I want to buy ETH with 100 USDC when ETH price is below $2000, then stake it on Lido for 5% APY',
                'build-intent': 'Build Intent',
                'simulate-execution': 'Simulate Execution',
                'connect-wallet': 'Connect Wallet',
                'intent-success': '✅ Intent Generated Successfully!',
                'action': 'Action',
                'confidence': 'Confidence',
                'risk-level': 'Risk Level',
                'gas-estimate': 'Gas Estimate',
                'tokens': 'Tokens',
                'protocols': 'Protocols',
                'conditions': 'Conditions',
                'execution-path': 'Execution Path',
                'close': 'Close',
                'learn-concepts': '🎓 Learn Anoma Concepts',
                'learn-desc': 'Complete lessons to earn points and unlock games. Each lesson teaches you about Anoma\'s core concepts.',
                'lesson1-title': '🌱 What is Anoma?',
                'lesson1-desc': 'Learn the basics of intent-centric blockchain',
                'lesson2-title': '⚡ Intent System',
                'lesson2-desc': 'Understand how intents work in Anoma',
                'lesson3-title': '🔐 Privacy & ZK',
                'lesson3-desc': 'Learn about zero-knowledge proofs',
                'lesson4-title': '🌐 Cross-Chain',
                'lesson4-desc': 'Understand cross-chain operations',
                'lesson5-title': '🎯 Advanced Intents',
                'lesson5-desc': 'Master complex intent strategies',
                'lesson6-title': '🏆 Anoma Master',
                'lesson6-desc': 'Become an Anoma expert',
                'reward-50': 'Reward: 50 points',
                'reward-100': 'Reward: 100 points',
                'play-game': 'Play Game',
                'cost-20': 'Cost: 20 points',
                'cost-25': 'Cost: 25 points',
                'cost-30': 'Cost: 30 points',
                'cost-35': 'Cost: 35 points',
                'cost-50': 'Cost: 50 points',
                'cost-60': 'Cost: 60 points',
                'anoma-quiz': '🧠 Anoma Quiz',
                'anoma-quiz-desc': 'Test your knowledge about Anoma concepts',
                'intent-matching': '🎯 Intent Matching Game',
                'intent-matching-desc': 'Match intents with their optimal execution paths',
                'intent-detective': '🔍 Intent Detective',
                'intent-detective-desc': 'Analyze complex intents and find the best path',
                'speed-intent': '⚡ Speed Intent',
                'speed-intent-desc': 'Express intents as fast as possible',
                'intent-dice': '🎲 Intent Dice',
                'intent-dice-desc': 'Roll dice to build intent combinations',
                'privacy-puzzle': '🔐 Privacy Puzzle',
                'privacy-puzzle-desc': 'Solve puzzles using zero-knowledge concepts',
                'privacy-puzzle-visual': '🧩 Privacy Puzzle (Visual)',
                'privacy-puzzle-visual-desc': 'Drag and drop ZK proof components',
                'anoma-memory': '🧠 Anoma Memory',
                'anoma-memory-desc': 'Match Anoma concepts and test your memory',
                'privacy-guardian': '🛡️ Privacy Guardian',
                'privacy-guardian-desc': 'Protect user data using ZK proofs',
                'intent-builder': '🎯 Intent Builder',
                'intent-builder-desc': 'Create complex multi-step intents',
                'tower-defense': '🎮 Intent Tower Defense',
                'tower-defense-desc': 'Defend against attacks using Anoma tools',
                'shrimp-jump': '🦐 Shrimp Jump Game',
                'shrimp-jump-desc': 'Control the shrimp to jump and avoid obstacles',
                'shrimp-collector': '🦐 Shrimp Collector',
                'shrimp-collector-desc': 'Collect Anoma shrimps in this fun arcade game',
                'wizard-coin': '🧙 Wizard Coin Game',
                'wizard-coin-desc': 'Control wizard to catch falling coins',
                'intent-archery': '🎯 Intent Archery',
                'intent-archery-desc': 'Shoot intents at targets with precision',
                'tetris': '🧩 Tetris',
                'tetris-desc': 'Classic Tetris with Anoma-themed blocks',
                'snake': '🐍 Snake Game',
                'snake-desc': 'Classic Snake game with Anoma elements',
                'memory': '🧠 Memory Game',
                'memory-desc': 'Match pairs of Anoma concepts',
                'puzzle': '🧩 Puzzle Game',
                'puzzle-desc': 'Solve Anoma-themed puzzles',
            },
            zh: {
                'play-games': '🎮 用积分玩游戏',
                'games-desc': '使用您获得的积分来玩游戏，学习更多关于Anoma概念的知识。',
                'knowledge-games': '🧠 知识游戏',
                'puzzle-games': '🧩 谜题游戏',
                'action-games': '⚡ 动作游戏',
                'play': '开始',
                'cost': '消耗',
                'points': '积分',
                'welcome': '欢迎来到Anoma学院！',
                'login-desc': '创建账户保存您的进度并与其他玩家竞争！',
                'username': '输入用户名',
                'email': '输入邮箱 (可选)',
                'login-register': '登录 / 注册',
                'guest-mode': '游客模式',
                'welcome-user': '欢迎, ',
                'progress-saved': '您的进度已自动保存到您的账户中。',
                'total-points': '总积分',
                'level': '等级',
                'games-played': '游戏次数',
                'wins': '胜利次数',
                'test-points': '+100 测试积分',
                'logout': '退出登录',
                'intent-demo': '🎯 意图中心演示',
                'intent-desc': '体验革命性的意图中心交易 - 用自然语言表达您的交易需求，让AI为您找到最佳执行路径！',
                'enter-intent': '💬 输入您的交易意图',
                'intent-placeholder': '例如：我想在ETH价格低于$2000时用100 USDC购买ETH，然后在Lido上质押获得5%年化收益',
                'build-intent': '构建意图',
                'simulate-execution': '模拟执行',
                'connect-wallet': '连接钱包',
                'intent-success': '✅ 意图生成成功！',
                'action': '动作',
                'confidence': '置信度',
                'risk-level': '风险等级',
                'gas-estimate': 'Gas估算',
                'tokens': '代币',
                'protocols': '协议',
                'conditions': '条件',
                'execution-path': '执行路径',
                'close': '关闭',
                'learn-concepts': '🎓 学习Anoma概念',
                'learn-desc': '完成课程获得积分并解锁游戏。每个课程都教授您Anoma的核心概念。',
                'lesson1-title': '🌱 什么是Anoma？',
                'lesson1-desc': '学习意图中心区块链的基础知识',
                'lesson2-title': '⚡ 意图系统',
                'lesson2-desc': '了解意图在Anoma中如何工作',
                'lesson3-title': '🔐 隐私与零知识',
                'lesson3-desc': '学习零知识证明',
                'lesson4-title': '🌐 跨链',
                'lesson4-desc': '了解跨链操作',
                'lesson5-title': '🎯 高级意图',
                'lesson5-desc': '掌握复杂的意图策略',
                'lesson6-title': '🏆 Anoma大师',
                'lesson6-desc': '成为Anoma专家',
                'reward-50': '奖励：50积分',
                'reward-100': '奖励：100积分',
                'play-game': '开始游戏',
                'cost-20': '消耗：20积分',
                'cost-25': '消耗：25积分',
                'cost-30': '消耗：30积分',
                'cost-35': '消耗：35积分',
                'cost-50': '消耗：50积分',
                'cost-60': '消耗：60积分',
                'anoma-quiz': '🧠 Anoma测验',
                'anoma-quiz-desc': '测试您对Anoma概念的了解',
                'intent-matching': '🎯 意图匹配游戏',
                'intent-matching-desc': '将意图与其最佳执行路径匹配',
                'intent-detective': '🔍 意图侦探',
                'intent-detective-desc': '分析复杂意图并找到最佳路径',
                'speed-intent': '⚡ 快速意图',
                'speed-intent-desc': '尽可能快地表达意图',
                'intent-dice': '🎲 意图骰子',
                'intent-dice-desc': '掷骰子构建意图组合',
                'privacy-puzzle': '🔐 隐私谜题',
                'privacy-puzzle-desc': '使用零知识概念解决谜题',
                'privacy-puzzle-visual': '🧩 隐私谜题（视觉）',
                'privacy-puzzle-visual-desc': '拖拽ZK证明组件',
                'anoma-memory': '🧠 Anoma记忆',
                'anoma-memory-desc': '匹配Anoma概念并测试您的记忆',
                'privacy-guardian': '🛡️ 隐私守护者',
                'privacy-guardian-desc': '使用ZK证明保护用户数据',
                'intent-builder': '🎯 意图构建器',
                'intent-builder-desc': '创建复杂的多步骤意图',
                'tower-defense': '🎮 意图塔防',
                'tower-defense-desc': '使用Anoma工具防御攻击',
                'shrimp-jump': '🦐 虾跳游戏',
                'shrimp-jump-desc': '控制虾跳跃并避开障碍物',
                'shrimp-collector': '🦐 虾收集者',
                'shrimp-collector-desc': '在这个有趣的街机游戏中收集Anoma虾',
                'wizard-coin': '🧙 巫师硬币游戏',
                'wizard-coin-desc': '控制巫师接住掉落的硬币',
                'intent-archery': '🎯 意图射箭',
                'intent-archery-desc': '精确射击意图目标',
                'tetris': '🧩 俄罗斯方块',
                'tetris-desc': '带有Anoma主题方块的经典俄罗斯方块',
                'snake': '🐍 贪吃蛇游戏',
                'snake-desc': '带有Anoma元素的经典贪吃蛇游戏',
                'memory': '🧠 记忆游戏',
                'memory-desc': '匹配Anoma概念对',
                'puzzle': '🧩 谜题游戏',
                'puzzle-desc': '解决Anoma主题谜题',
            }
        };
        // Language switching functions
        function switchLanguage() {
            currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
            updateLanguage();
        }

        function updateLanguage() {
            const elements = document.querySelectorAll('[data-translate]');
            elements.forEach(element => {
                const key = element.getAttribute('data-translate');
                if (translations[currentLanguage][key]) {
                    element.textContent = translations[currentLanguage][key];
                }
            });
            
            // Update language button
            const langButton = document.getElementById('lang-button');
            if (langButton) {
                langButton.textContent = currentLanguage === 'en' ? '中文' : 'English';
            }
            
            // Update modal content if any modals are open
            updateModalLanguage();
        }

        function updateModalLanguage() {
            // Update project requirements modal
            const requirementsModal = document.querySelector('.requirements-modal');
            if (requirementsModal) {
                updateRequirementsModalLanguage();
            }
            
            // Update other modals as needed
            updateGameModalLanguage();
        }


        function updateGameModalLanguage() {
            // Update game modals if they exist
            const gameModals = document.querySelectorAll('.modal');
            gameModals.forEach(modal => {
                const title = modal.querySelector('h3');
                if (title && title.textContent.includes('Game')) {
                    // Update game modal titles and content
                    const isChinese = currentLanguage === 'zh';
                    if (isChinese) {
                        if (title.textContent.includes('Tetris')) title.textContent = '🧩 俄罗斯方块游戏';
                        if (title.textContent.includes('Snake')) title.textContent = '🐍 贪吃蛇游戏';
                        if (title.textContent.includes('Memory')) title.textContent = '🧠 记忆游戏';
                        if (title.textContent.includes('Puzzle')) title.textContent = '🧩 谜题游戏';
                    } else {
                        if (title.textContent.includes('俄罗斯方块')) title.textContent = '🧩 Tetris Game';
                        if (title.textContent.includes('贪吃蛇')) title.textContent = '🐍 Snake Game';
                        if (title.textContent.includes('记忆')) title.textContent = '🧠 Memory Game';
                        if (title.textContent.includes('谜题')) title.textContent = '🧩 Puzzle Game';
                    }
                }
            });
        }

        // Initialize language on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateLanguage();
            
            // Hide loading overlay after page loads
            setTimeout(() => {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 500);
                }
            }, 1500);
        });

        const oldTranslations = {
            en: {
                // Button text
                'theme-text': 'Dark Mode',
                'lang-text': '中文',
                // Main titles
                'academy-title': '🎓 Welcome to Anoma Academy - Your Gateway to Mastering Intent-Centric Blockchain Technology',
                'academy-desc': 'Learn, earn points, and play games while discovering the revolutionary world of Anoma\'s privacy-preserving cross-chain operations. From racing through blockchain networks to solving puzzles, our interactive platform makes complex blockchain concepts accessible and fun for everyone.',
                'interactive-learning': '🎮 Interactive Learning',
                'gamified-education': '🏆 Gamified Education',
                'racing-games': '🏎️ Racing Games',
                'future-ready-skills': '🚀 Future-Ready Skills',
                // Progress section
                'your-progress': '📊 Your Progress',
                'points': 'Points',
                'level': 'Level',
                'lessons-completed': 'Lessons',
                'games-played': 'Games Played',
                'achievements': 'Achievements',
                // Learning section
                'learn-concepts': '🎓 Learn Anoma Concepts',
                'learn-desc': 'Complete lessons to earn points and unlock games. Each lesson teaches you about Anoma\'s core concepts.',
                'intent-fundamentals': 'Intent Fundamentals',
                'intent-desc': 'Learn the basics of intent-centric architecture',
                'privacy-mechanisms': 'Privacy Mechanisms',
                'privacy-desc': 'Understand zero-knowledge proofs and privacy',
                'cross-chain': 'Cross-Chain Operations',
                'cross-chain-desc': 'Master interoperability concepts',
                'complete-lesson': 'Complete Lesson',
                // Control按钮
                'sound-on': '🔊 Sound On',
                'music-on': '🎵 Music On',
                'difficulty': '🎯 Easy',
                // 课程
                'lesson1-title': '🌱 What is Anoma?',
                'lesson1-desc': 'Learn the basics of intent-centric blockchain',
                'lesson2-title': '⚡ Intent System',
                'lesson2-desc': 'Understand how intents work in Anoma',
                'lesson3-title': '🔐 Privacy & ZK',
                'lesson3-desc': 'Learn about zero-knowledge proofs',
                'lesson4-title': '🌐 Cross-Chain',
                'lesson4-desc': 'Understand cross-chain operations',
                'lesson5-title': '🎯 Advanced Intents',
                'lesson5-desc': 'Master complex intent strategies',
                'lesson6-title': '🏆 Anoma Master',
                'lesson6-desc': 'Become an Anoma expert',
                'reward-50': 'Reward: 50 points',
                'reward-100': 'Reward: 100 points',
                // 游戏分类
                'knowledge-games': '🧠 Knowledge Games',
                'action-games': '🏃 Action Games',
                'puzzle-games': '🧩 Puzzle Games',
                'strategy-games': '🎲 Strategy Games',
                // 作者信息
                'development-team': 'Development Team',
                // Coming Soon
                'coming-soon-title': '🎮 More Games Coming Soon!',
                'coming-soon-desc': 'Stay tuned for exciting new Anoma games',
                'coming-soon': 'Coming Soon',
                // About Anoma
                'about-anoma': '⚡ About Anoma',
                'about-anoma-desc': 'Anoma is the first intent-centric blockchain that enables privacy-preserving cross-chain operations. Learn more about our revolutionary technology and join the future of Web3!',
                // Anoma特性
                'feature1-title': 'Intent-Centric',
                'feature1-desc': 'Express what you want, not how to do it',
                'feature2-title': 'Privacy-First',
                'feature2-desc': 'Zero-knowledge proofs protect your data',
                'feature3-title': 'Cross-Chain',
                'feature3-desc': 'Seamless operations across all chains',
                // 官方资源
                'official-resources': '⚡ Official Anoma Resources',
                'official-resources-desc': 'Connect with the Anoma ecosystem and stay updated with the latest developments!',
                // Games section
                'play-games': '🎮 Play Games with Your Points',
                'games-desc': 'Use your earned points to play games that teach you more about Anoma concepts.',
                'shrimp-jump': '🦐 Shrimp Jump',
                'shrimp-jump-desc': 'Control the shrimp to jump and avoid obstacles',
                'shrimp-collector': '🦐 Shrimp Collector',
                'shrimp-collector-desc': 'Collect Anoma shrimps in this fun arcade game',
                'wizard-coin': '🧙 Wizard Coin Game',
                'wizard-coin-desc': 'Control wizard to catch falling coins',
                'intent-archery': '🎯 Intent Archery',
                'intent-archery-desc': 'Shoot intents at targets with precision',
                'intent-snake': '🐍 Intent Snake',
                'intent-snake-desc': 'Control the snake to collect Anoma shrimps',
                'anoma-racing': '🏎️ Anoma Racing',
                'anoma-racing-desc': 'Race through Anoma\'s blockchain network and collect tokens',
                'cost-40': 'Cost: 40 points',
                'wizard-coin-desc': 'Catch coins with the wizard\'s magic',
                'intent-archery': '🎯 Intent Archery',
                'intent-archery-desc': 'Shoot arrows at moving targets',
                'privacy-puzzle': '🔐 Privacy Puzzle',
                'privacy-puzzle-desc': 'Solve puzzles using zero-knowledge concepts',
                'privacy-puzzle-visual': '🧩 Privacy Puzzle (Visual)',
                'privacy-puzzle-visual-desc': 'Drag and drop ZK proof components',
                'anoma-memory': '🧠 Anoma Memory',
                'anoma-memory-desc': 'Match Anoma concepts and test your memory',
                'privacy-guardian-desc': 'Protect user data using ZK proofs',
                'intent-builder': '🎯 Intent Builder',
                'intent-builder-desc': 'Create complex multi-step intents',
                'tower-defense': '🎮 Intent Tower Defense',
                'tower-defense-desc': 'Defend against attacks using Anoma tools',
                'shrimp-jump-desc': 'Jump over obstacles as a shrimp',
                'shrimp-collector-desc': 'Collect shrimp in the ocean',
                'wizard-coin-desc': 'Catch coins as a wizard',
                'archery-desc': 'Shoot arrows at targets',
                'snake-desc': 'Control the snake to eat food',
                'racing-desc': 'Race against other cars',
                'tetris-desc': 'Stack blocks in Tetris',
                'cost-20': 'Cost: 20 points',
                'cost-25': 'Cost: 25 points',
                'cost-30': 'Cost: 30 points',
                'cost-35': 'Cost: 35 points',
                'cost-50': 'Cost: 50 points',
                'cost-60': 'Cost: 60 points',
                'privacy-puzzle-desc': 'Solve puzzles using zero-knowledge concepts',
                'anoma-memory': '🧠 Anoma Memory',
                'anoma-memory-desc': 'Match Anoma concepts and test your memory',
                'privacy-guardian': '🛡️ Privacy Guardian',
                'privacy-guardian-desc': 'Protect user data using ZK proofs',
                'intent-builder': '🎯 Intent Builder',
                'intent-builder-desc': 'Create complex multi-step intents',
                'intent-dice': '🎲 Intent Dice',
                'intent-dice-desc': 'Roll dice to build intent combinations',
                'intent-snake': '🐍 Intent Snake',
                'intent-snake-desc': 'Classic snake game with Anoma shrimps',
                'intent-tower': '🏰 Intent Tower Defense',
                'intent-tower-desc': 'Build towers to defend against enemies',
                'anoma-racing': '🏎️ Anoma Racing',
                'anoma-racing-desc': 'Race through Anoma\'s blockchain network and collect tokens',
                'anoma-tetris': '🧩 Anoma Tetris',
                'anoma-tetris-desc': 'Classic Tetris with Anoma-themed blocks and blockchain concepts',
                // Knowledge Games
                'anoma-quiz': '🧠 Anoma Master Quiz',
                'anoma-quiz-desc': 'Advanced knowledge test with comprehensive Anoma concepts',
                'intent-matching': '🎯 Intent Matching Game',
                'intent-matching-desc': 'Match intents with their optimal execution paths',
                'intent-detective': '🔍 Intent Detective',
                'intent-detective-desc': 'Analyze complex intents and find the best path',
                'speed-intent': '⚡ Speed Intent',
                'speed-intent-desc': 'Express intents as fast as possible',
                // 费用
                'cost-20': 'Cost: 20 points',
                'cost-25': 'Cost: 25 points',
                'cost-30': 'Cost: 30 points',
                'cost-35': 'Cost: 35 points',
                'cost-40': 'Cost: 40 points',
                'cost-50': 'Cost: 50 points',
                'cost-60': 'Cost: 60 points',
                'cost': 'Cost',
                'points': 'points',
                'play-game': 'Play Game',
                // 其他
                'start-race': 'Start Race',
                'score': 'Score',
                'tokens': 'Tokens'
            },
            zh: {
                // Button text
                'theme-text': '深色模式',
                'lang-text': 'English',
                // Main titles
                'academy-title': '🎓 欢迎来到Anoma学院 - 掌握意图中心区块链技术的门户',
                'academy-desc': '在学习Anoma革命性的隐私保护跨链操作世界的同时，学习、赚取积分和玩游戏。从在区块链网络中Car到解决谜题，我们的互动平台让复杂的区块链概念变得易于理解和有趣。',
                'interactive-learning': '🎮 互动学习',
                'gamified-education': '🏆 游戏化教育',
                'racing-games': '🏎️ Car游戏',
                'future-ready-skills': '🚀 面向未来的技能',
                // Progress section
                'your-progress': '📊 你的进度',
                'points': '积分',
                'level': '等级',
                'lessons-completed': '课程',
                'games-played': '已玩游戏',
                'achievements': '成就',
                // Learning section
                'learn-concepts': '🎓 学习Anoma概念',
                'learn-desc': '完成课程赚取积分并解锁游戏。每个课程都教你Anoma的核心概念。',
                'intent-fundamentals': '意图基础',
                'intent-desc': '学习意图中心架构的基础知识',
                'privacy-mechanisms': '隐私机制',
                'privacy-desc': '理解Zero-KnowledgeProof和隐私',
                'cross-chain': '跨链操作',
                'cross-chain-desc': '掌握互操作性概念',
                'complete-lesson': '完成课程',
                // Control按钮
                'sound-on': '🔊 声音开启',
                'music-on': '🎵 音乐开启',
                'difficulty': '🎯 简单',
                // 课程
                'lesson1-title': '🌱 什么是Anoma？',
                'lesson1-desc': '学习意图中心区块链的基础知识',
                'lesson2-title': '⚡ 意图系统',
                'lesson2-desc': '理解意图在Anoma中如何工作',
                'lesson3-title': '🔐 隐私与Zero-Knowledge',
                'lesson3-desc': '学习Zero-KnowledgeProof',
                'lesson4-title': '🌐 跨链',
                'lesson4-desc': '理解跨链操作',
                'lesson5-title': '🎯 高级意图',
                'lesson5-desc': '掌握复杂的意图策略',
                'lesson6-title': '🏆 Anoma大师',
                'lesson6-desc': '成为Anoma专家',
                'reward-50': '奖励：50积分',
                'reward-100': '奖励：100积分',
                // 游戏分类
                'knowledge-games': '🧠 知识游戏',
                'action-games': '🏃 动作游戏',
                'puzzle-games': '🧩 谜题游戏',
                'strategy-games': '🎲 策略游戏',
                // 作者信息
                'development-team': '开发团队',
                // Coming Soon
                'coming-soon-title': '🎮 更多游戏即将推出！',
                'coming-soon-desc': '敬请期待令人兴奋的新Anoma游戏',
                'coming-soon': '即将推出',
                // About Anoma
                'about-anoma': '⚡ 关于Anoma',
                'about-anoma-desc': 'Anoma是第一个意图中心的区块链，支持隐私保护的跨链操作。了解更多关于我们革命性技术的信息，加入Web3的未来！',
                // Anoma特性
                'feature1-title': '意图中心',
                'feature1-desc': '表达你想要什么，而不是如何实现',
                'feature2-title': '隐私优先',
                'feature2-desc': 'Zero-KnowledgeProof保护你的数据',
                'feature3-title': '跨链',
                'feature3-desc': '在所有链上无缝操作',
                // 官方资源
                'official-resources': '⚡ Anoma官方资源',
                'official-resources-desc': '与Anoma生态系统连接，了解最新发展！',
                // Games section
                'play-games': '🎮 用你的积分玩游戏',
                'games-desc': 'Use你赚取的积分来玩游戏，这些游戏会教你更多关于Anoma的概念。',
                'shrimp-jump': '🦐 虾跳游戏',
                'shrimp-jump-desc': '帮助Anoma虾跳过Obstacles',
                'shrimp-collector': '🦐 虾Collect器',
                'shrimp-collector-desc': '在这个快节奏的游戏中Collect掉落的虾',
                'wizard-coin': '🧙 Wizard硬币游戏',
                'wizard-coin-desc': '用Wizard的魔法Catch硬币',
                'intent-archery': '🎯 意图射箭',
                'intent-archery-desc': '射击Move目标',
                'privacy-puzzle': '🔐 隐私谜题',
                'privacy-puzzle-desc': 'UseZero-Knowledge概念解决谜题',
                'anoma-memory': '🧠 Anoma记忆',
                'anoma-memory-desc': '匹配Anoma概念并测试你的记忆力',
                'privacy-guardian': '🛡️ 隐私守护者',
                'privacy-guardian-desc': 'UseZKProof保护用户数据',
                'intent-builder': '🎯 意图构建器',
                'intent-builder-desc': '创建复杂的多步骤意图',
                'intent-dice': '🎲 意图骰子',
                'intent-dice-desc': '掷骰子构建意图组合',
                'intent-snake': '🐍 意图贪吃蛇',
                'intent-snake-desc': '经典的贪吃蛇游戏，带有Anoma虾',
                'intent-tower': '🏰 意图塔防',
                'intent-tower-desc': '建造塔楼防御敌人',
                'anoma-racing': '🏎️ AnomaCar',
                'anoma-racing-desc': '在Anoma的区块链网络中Car并CollectTokens',
                'anoma-tetris': '🧩 Anoma俄罗斯方块',
                'anoma-tetris-desc': '经典俄罗斯方块，带有Anoma主题方块和区块链概念',
                // Knowledge Games
                'anoma-quiz': '🧠 Anoma大师测验',
                'anoma-quiz-desc': '包含全面Anoma概念的高级知识测试',
                'intent-matching': '🎯 意图匹配游戏',
                'intent-matching-desc': '将意图与其最佳执行路径匹配',
                'intent-detective': '🔍 意图侦探',
                'intent-detective-desc': '分析复杂意图并找到最佳路径',
                'speed-intent': '⚡ 速度意图',
                'speed-intent-desc': '尽可能快地表达意图',
                // 费用
                'cost-20': '费用：20积分',
                'cost-25': '费用：25积分',
                'cost-30': '费用：30积分',
                'cost-35': '费用：35积分',
                'cost-40': '费用：40积分',
                'cost-50': '费用：50积分',
                'cost-60': '费用：60积分',
                'cost': '费用',
                'points': '积分',
                'play-game': '玩游戏',
                // 其他
                'start-race': '开始比赛',
                'score': 'Score',
                'tokens': 'Tokens'
            }
        };

        // 主题切换函数
        function switchTheme() {
            const body = document.body;
            const icon = document.getElementById('theme-icon');
            const text = document.getElementById('theme-text');
            
            if (body.classList.contains('dark-theme')) {
                // 切换到浅色主题
                body.classList.remove('dark-theme');
                icon.textContent = '🌙';
                text.textContent = translations[currentLanguage]['theme-text'];
            } else {
                // 切换到深色主题
                body.classList.add('dark-theme');
                icon.textContent = '☀️';
                text.textContent = translations[currentLanguage]['theme-text'];
            }
        }

        // 语言切换函数
        function switchLanguage() {
            currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
            
            // 更新按钮文本
            const langIcon = document.getElementById('lang-icon');
            const langText = document.getElementById('lang-text');
            const themeText = document.getElementById('theme-text');
            
            langText.textContent = translations[currentLanguage]['lang-text'];
            themeText.textContent = translations[currentLanguage]['theme-text'];
            
            // 更新页面内容
            updatePageContent();
            
            // 保存语言设置
            localStorage.setItem('language', currentLanguage);
        }

        // 更新页面内容
        function updatePageContent() {
            const lang = translations[currentLanguage];
            
            // 更新所有带有data-translate属性的元素
            const elementsToTranslate = document.querySelectorAll('[data-translate]');
            elementsToTranslate.forEach(element => {
                const key = element.getAttribute('data-translate');
                if (lang[key]) {
                    element.textContent = lang[key];
                }
            });
            
            // 更新游戏卡片
            updateGameCards();
        }

        // 更新游戏卡片
        function updateGameCards() {
            const lang = translations[currentLanguage];
            const gameCards = document.querySelectorAll('.game-card');
            
            gameCards.forEach(card => {
                const title = card.querySelector('h4');
                const desc = card.querySelector('p');
                const cost = card.querySelector('.cost');
                const button = card.querySelector('.btn');
                
                if (title && desc && cost && button) {
                    const titleText = title.textContent;
                    
                    // 根据游戏标题匹配对应的翻译
                    if (titleText.includes('Shrimp Jump')) {
                        title.textContent = lang['shrimp-jump'];
                        desc.textContent = lang['shrimp-jump-desc'];
                    } else if (titleText.includes('Shrimp Collector')) {
                        title.textContent = lang['shrimp-collector'];
                        desc.textContent = lang['shrimp-collector-desc'];
                    } else if (titleText.includes('Wizard Coin')) {
                        title.textContent = lang['wizard-coin'];
                        desc.textContent = lang['wizard-coin-desc'];
                    } else if (titleText.includes('Intent Archery')) {
                        title.textContent = lang['intent-archery'];
                        desc.textContent = lang['intent-archery-desc'];
                    } else if (titleText.includes('Privacy Puzzle')) {
                        title.textContent = lang['privacy-puzzle'];
                        desc.textContent = lang['privacy-puzzle-desc'];
                    } else if (titleText.includes('Anoma Memory')) {
                        title.textContent = lang['anoma-memory'];
                        desc.textContent = lang['anoma-memory-desc'];
                    } else if (titleText.includes('Privacy Guardian')) {
                        title.textContent = lang['privacy-guardian'];
                        desc.textContent = lang['privacy-guardian-desc'];
                    } else if (titleText.includes('Intent Builder')) {
                        title.textContent = lang['intent-builder'];
                        desc.textContent = lang['intent-builder-desc'];
                    } else if (titleText.includes('Intent Dice')) {
                        title.textContent = lang['intent-dice'];
                        desc.textContent = lang['intent-dice-desc'];
                    } else if (titleText.includes('Intent Snake')) {
                        title.textContent = lang['intent-snake'];
                        desc.textContent = lang['intent-snake-desc'];
                    } else if (titleText.includes('Intent Tower')) {
                        title.textContent = lang['intent-tower'];
                        desc.textContent = lang['intent-tower-desc'];
                    } else if (titleText.includes('Anoma Racing')) {
                        title.textContent = lang['anoma-racing'];
                        desc.textContent = lang['anoma-racing-desc'];
                    }
                    
                    // 更新费用和按钮文本
                    if (cost.textContent.includes('Cost:')) {
                        cost.textContent = `${lang['cost']}: ${cost.textContent.split(':')[1]}`;
                    }
                    button.textContent = lang['play-game'];
                }
            });
        }

        // Theme Management
        function toggleTheme() {
            const body = document.body;
            
            // Update both buttons
            const icon1 = document.querySelector('.theme-toggle .icon');
            const text1 = document.querySelector('.theme-toggle .text');
            const icon2 = document.getElementById('theme-icon');
            const text2 = document.getElementById('theme-text');
            
            if (body.classList.contains('dark-theme')) {
                // Switch to light theme
                body.classList.remove('dark-theme');
                if (icon1) icon1.textContent = '🌙';
                if (text1) text1.textContent = 'Dark Mode';
                if (icon2) icon2.textContent = '🌙';
                if (text2) text2.textContent = 'Dark Mode';
                localStorage.setItem('theme', 'light');
            } else {
                // Switch to dark theme
                body.classList.add('dark-theme');
                if (icon1) icon1.textContent = '☀️';
                if (text1) text1.textContent = 'Light Mode';
                if (icon2) icon2.textContent = '☀️';
                if (text2) text2.textContent = 'Light Mode';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Initialize theme on page load
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.body.classList.add('dark-theme');
                
                // Update both buttons
                const icon1 = document.querySelector('.theme-toggle .icon');
                const text1 = document.querySelector('.theme-toggle .text');
                const icon2 = document.getElementById('theme-icon');
                const text2 = document.getElementById('theme-text');
                
                if (icon1) icon1.textContent = '☀️';
                if (text1) text1.textContent = 'Light Mode';
                if (icon2) icon2.textContent = '☀️';
                if (text2) text2.textContent = 'Light Mode';
            }
        }


        // 页面加载完成
        document.addEventListener('DOMContentLoaded', function() {
            // 主题切换功能已就绪
        });

        // 全局函数
        window.switchTheme = switchTheme;

        // Game State
        let gameState = {
            points: 1000,
            level: 1,
            lessonsCompleted: 0,
            gamesPlayed: 0,
            completedLessons: [],
            achievements: [],
            soundEnabled: true,
            musicEnabled: true,
            difficulty: 'easy', // easy, medium, hard
            gameLevels: {
                'Intent Matching': 1,
                'Privacy Puzzle': 1,
                'Cross-Chain Challenge': 1,
                'Speed Intent': 1,
                'Intent Detective': 1,
                'Privacy Guardian': 1,
                'Intent Dice': 1,
                'Bridge Master': 1,
                'Intent Builder': 1,
                'Tower Defense': 1,
                'Privacy Puzzle (Visual)': 1,
                'Intent Runner': 1
            }
        };

        // Rich Anoma Question Bank System
        const anomaQuestionBank = {
            easy: [
                {
                    question: "What type of blockchain is Anoma?",
                    options: ["Proof of Stake", "Intent-Centric", "Proof of Work", "Delegated Proof of Stake"],
                    correct: 1,
                    explanation: "Anoma is an intent-centric blockchain focused on expressing and executing user intents"
                },
                {
                    question: "How do users express needs in Anoma?",
                    options: ["Use complex transaction code", "Through intent expression", "Send emails", "Make phone calls"],
                    correct: 1,
                    explanation: "Anoma uses an intent system where users only need to express what they want, not how to achieve it"
                },
                {
                    question: "How does Anoma protect user privacy?",
                    options: ["Use passwords", "Zero-Knowledge Proofs", "Hide IP addresses", "Delete data"],
                    correct: 1,
                    explanation: "Anoma uses Zero-Knowledge Proof technology to protect user privacy"
                },
                {
                    question: "What operations does Anoma support?",
                    options: ["Ethereum only", "Bitcoin only", "Cross-chain operations", "DeFi only"],
                    correct: 2,
                    explanation: "Anoma supports cross-chain operations and can connect multiple blockchain ecosystems"
                },
                {
                    question: "What is the advantage of the intent system?",
                    options: ["More complex", "Simpler and easier to use", "More expensive", "Slower"],
                    correct: 1,
                    explanation: "The intent system allows users to just express their needs, and the system automatically finds the best execution path"
                },
                {
                    question: "What does Anoma's AI system do?",
                    options: ["Mining", "Match best execution paths", "Store data", "Verify transactions"],
                    correct: 1,
                    explanation: "AI system analyzes user intents and finds the optimal execution path"
                },
                {
                    question: "What is the purpose of Zero-Knowledge Proofs?",
                    options: ["Increase speed", "Prove something without revealing information", "Reduce costs", "Increase security"],
                    correct: 1,
                    explanation: "Zero-Knowledge Proofs allow proving a statement is true without revealing any additional information"
                },
                {
                    question: "How does Anoma handle cross-chain transactions?",
                    options: ["Manual operation", "Automatic seamless processing", "Requires multiple wallets", "Not supported"],
                    correct: 1,
                    explanation: "Anoma automatically handles cross-chain operations, providing users with a unified experience"
                },
                {
                    question: "Who is the founder of Anoma?",
                    options: ["Vitalik Buterin", "Arianne Flemming", "Charles Hoskinson", "Gavin Wood"],
                    correct: 1,
                    explanation: "Arianne Flemming is the founder of Anoma, who proposed the intent-centric blockchain design philosophy."
                },
                {
                    question: "What is Anoma's native token?",
                    options: ["ANOMA", "NOM", "ANM", "ANOMA Token"],
                    correct: 1,
                    explanation: "NOM is Anoma's native token, used for network governance and transaction fees."
                },
                {
                    question: "What is Anoma's main programming language?",
                    options: ["Solidity", "Rust", "Go", "Python"],
                    correct: 1,
                    explanation: "Anoma is primarily developed using Rust, ensuring high performance and memory safety."
                },
                {
                    question: "What is Anoma's intent language called?",
                    options: ["Solidity", "Rust", "Taiga", "Move"],
                    correct: 2,
                    explanation: "Taiga is Anoma's intent language, specifically designed for expressing and describing user intents."
                }
            ],
            medium: [
                {
                    question: "What is the main function of intent matchers in Anoma?",
                    options: ["Mining", "Match compatible intents", "Store data", "Verify identity"],
                    correct: 1,
                    explanation: "Intent matchers are responsible for finding intent pairs that can satisfy each other"
                },
                {
                    question: "What privacy protection mechanisms does Anoma include?",
                    options: ["Encryption only", "Zero-Knowledge Proofs and mixing", "Anonymity only", "IP hiding only"],
                    correct: 1,
                    explanation: "Anoma uses Zero-Knowledge Proofs and transaction mixing to protect privacy"
                },
                {
                    question: "What is the best practice for expressing intents?",
                    options: ["Describe steps in detail", "Express final goals", "Use technical terms", "Avoid specifics"],
                    correct: 1,
                    explanation: "Should express final goals and let the system find the best implementation method"
                },
                {
                    question: "How does Anoma handle MEV (Maximum Extractable Value)?",
                    options: ["Ignore it", "Reduce through intent system", "Increase fees", "Ban arbitrage"],
                    correct: 1,
                    explanation: "The intent system reduces MEV extraction through optimized matching"
                },
                {
                    question: "What is the advantage of cross-chain intents?",
                    options: ["Cheaper", "Access best liquidity", "Simpler", "More secure"],
                    correct: 1,
                    explanation: "Cross-chain intents can access liquidity across all chains for the best prices"
                },
                {
                    question: "What is Anoma's consensus mechanism?",
                    options: ["PoW", "PoS", "Hybrid consensus", "DPoS"],
                    correct: 2,
                    explanation: "Anoma uses a hybrid consensus mechanism combining multiple consensus algorithms"
                },
                {
                    question: "What happens when intent execution fails?",
                    options: ["Funds lost", "Auto retry", "Transaction rollback", "Manual handling"],
                    correct: 2,
                    explanation: "If intent execution fails, transactions are rolled back and funds are safe"
                },
                {
                    question: "How does Anoma ensure intent privacy?",
                    options: ["Encrypted storage", "Zero-Knowledge Proofs", "Local processing", "All of the above"],
                    correct: 3,
                    explanation: "Anoma uses multiple technologies to ensure intent privacy"
                },
                {
                    question: "What is Anoma's governance mechanism?",
                    options: ["Centralized governance", "PoS governance", "Intent-driven governance", "No governance"],
                    correct: 2,
                    explanation: "Anoma adopts intent-driven governance where users can participate in network decisions by expressing governance intents."
                },
                {
                    question: "How does Anoma handle complex multi-step intents?",
                    options: ["Not supported", "Through intent decomposition", "Through smart contracts", "Through oracles"],
                    correct: 1,
                    explanation: "Anoma can decompose complex multi-step intents into multiple simple sub-intents and execute them in parallel."
                },
                {
                    question: "What is Anoma's Zero-Knowledge Proof system based on?",
                    options: ["Only zk-SNARKs", "Only zk-STARKs", "Only Plonk", "Multiple technologies"],
                    correct: 3,
                    explanation: "Anoma supports multiple Zero-Knowledge Proof systems including zk-SNARKs, zk-STARKs, and Plonk."
                },
                {
                    question: "What principle is Anoma's intent matching algorithm based on?",
                    options: ["Greedy algorithm", "Dynamic programming", "Machine learning", "Game theory"],
                    correct: 3,
                    explanation: "Anoma's intent matching algorithm is based on game theory principles, optimizing intent matching through market mechanisms."
                }
            ],
            hard: [
                {
                    question: "What advanced features does Anoma's Intent Language support?",
                    options: ["Basic swaps only", "Conditional logic and complex intents", "DeFi only", "NFT only"],
                    correct: 1,
                    explanation: "Intent language supports complex conditional logic and compound intents"
                },
                {
                    question: "How does Anoma implement privacy-protected cross-chain arbitrage?",
                    options: ["Impossible", "Use Zero-Knowledge Proofs to hide arbitrage strategies", "Public execution", "Single chain only"],
                    correct: 1,
                    explanation: "Can use Zero-Knowledge Proofs to hide arbitrage strategies while protecting privacy"
                },
                {
                    question: "How does Anoma optimize its intent matching algorithm?",
                    options: ["Random matching", "Use AI and game theory", "Time-based only", "Amount-based only"],
                    correct: 1,
                    explanation: "Uses AI and game theory to optimize intent matching and find optimal solutions"
                },
                {
                    question: "How does Anoma balance privacy protection with verifiability?",
                    options: ["Sacrifice privacy", "Sacrifice verifiability", "Through Zero-Knowledge Proofs", "Through encryption"],
                    correct: 2,
                    explanation: "Anoma uses Zero-Knowledge Proof technology to protect user privacy while maintaining transaction verifiability."
                },
                {
                    question: "How does Anoma's intent decomposer work?",
                    options: ["Decomposition not supported", "Decompose complex intents into simple sub-intents", "Single intent only", "Through smart contracts"],
                    correct: 1,
                    explanation: "Intent decomposer can break down complex multi-step intents into multiple simple sub-intents and execute them in parallel."
                },
                {
                    question: "How does Anoma handle intent conflicts?",
                    options: ["Ignore conflicts", "Resolve through game theory", "Random selection", "Manual user resolution"],
                    correct: 1,
                    explanation: "Anoma uses game theory mechanisms to resolve intent conflicts and find optimal solutions."
                },
                {
                    question: "How does Anoma ensure atomicity of cross-chain intents?",
                    options: ["Cannot guarantee", "Through hash locking", "Through intent coordinator", "Through smart contracts"],
                    correct: 2,
                    explanation: "Anoma uses intent coordinators to ensure atomicity of cross-chain intents - either all succeed or all fail."
                },
                {
                    question: "How to handle atomic execution of intents?",
                    options: ["Ignore", "Use hash time locks", "Manual confirmation", "Batch execution"],
                    correct: 1,
                    explanation: "Use hash time locks and other technologies to ensure atomic execution of intents"
                },
                {
                    question: "How does Anoma extend privacy protection to complex transactions?",
                    options: ["Not supported", "Use recursive Zero-Knowledge Proofs", "Simple transactions only", "Manual handling"],
                    correct: 1,
                    explanation: "Use recursive Zero-Knowledge Proofs to protect privacy of complex transactions"
                },
                {
                    question: "How is the scalability of the intent system guaranteed?",
                    options: ["Add nodes", "Use sharding technology", "Limit users", "All of the above"],
                    correct: 3,
                    explanation: "Ensure scalability of the intent system through multiple technical means"
                },
                {
                    question: "How does Anoma handle intent priority and ordering?",
                    options: ["FIFO", "Fee-based", "Use auction mechanism", "All of the above"],
                    correct: 3,
                    explanation: "Use multiple mechanisms to handle intent priority and ordering"
                },
                {
                    question: "How does Anoma implement privacy-protected governance voting?",
                    options: ["Impossible", "Use Zero-Knowledge Proofs", "Public voting", "Delegated voting"],
                    correct: 1,
                    explanation: "Use Zero-Knowledge Proof technology to implement privacy-protected governance voting"
                }
            ]
        };

        // 题目选择函数
        function getRandomQuestions(difficulty, count = 3) {
            const questions = anomaQuestionBank[difficulty] || anomaQuestionBank.easy;
            const shuffled = [...questions].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        // 生成隐私谜题
        function generatePrivacyPuzzles(difficulty) {
            const puzzleTemplates = {
                easy: [
                    {
                        title: "ZKProof Basics",
                        description: "Arrange basic components of Zero-Knowledge proof",
                        pieces: ["Secret", "Proof", "Verifier", "Prover"],
                        solution: ["Prover", "Secret", "Proof", "Verifier"],
                        explanation: "Prover uses Secret to create Proof, Verifier checks Proof validity"
                    },
                    {
                        title: "Intent Flow",
                        description: "Arrange basic steps of intent execution",
                        pieces: ["Express Intent", "Execute", "Verify", "Settle"],
                        solution: ["Express Intent", "Execute", "Verify", "Settle"],
                        explanation: "User expresses intent → System executes → Verify results → Transaction settlement"
                    }
                ],
                medium: [
                    {
                        title: "Privacy Protection",
                        description: "Arrange Anoma's privacy protection components",
                        pieces: ["Zero-KnowledgeProof", "Transaction Mixing", "Intent Matching", "Privacy Computing"],
                        solution: ["Intent Matching", "Zero-KnowledgeProof", "Transaction Mixing", "Privacy Computing"],
                        explanation: "Intent Matching → Zero-KnowledgeProof → Transaction Mixing → Privacy Computing"
                    },
                    {
                        title: "Cross-Chain Privacy",
                        description: "Arrange cross-chain privacy protection steps",
                        pieces: ["Cross-Chain Intent", "Privacy Proof", "Inter-Chain Verification", "Privacy Settlement"],
                        solution: ["Cross-Chain Intent", "Privacy Proof", "Inter-Chain Verification", "Privacy Settlement"],
                        explanation: "Create cross-chain intent → Generate privacy proof → Inter-chain verification → Privacy settlement"
                    }
                ],
                hard: [
                    {
                        title: "Advanced Privacy Architecture",
                        description: "Arrange complex privacy protection architecture components",
                        pieces: ["Recursive ZK", "Privacy Aggregation", "Zero-Knowledge VM", "Privacy State Machine", "Privacy Consensus"],
                        solution: ["Privacy State Machine", "Recursive ZK", "Zero-Knowledge VM", "Privacy Aggregation", "Privacy Consensus"],
                        explanation: "Privacy State Machine → Recursive ZK → Zero-Knowledge VM → Privacy Aggregation → Privacy Consensus"
                    },
                    {
                        title: "Privacy Governance",
                        description: "Arrange complete privacy governance process",
                        pieces: ["Privacy Voting", "Zero-Knowledge Verification", "Governance Proof", "Privacy Results", "State Update"],
                        solution: ["Privacy Voting", "Zero-Knowledge Verification", "Governance Proof", "Privacy Results", "State Update"],
                        explanation: "Privacy Voting → Zero-Knowledge Verification → Governance Proof → Privacy Results → State Update"
                    }
                ]
            };
            
            const puzzles = puzzleTemplates[difficulty] || puzzleTemplates.easy;
            return [...puzzles].sort(() => 0.5 - Math.random());
        }

        // 生成跨链挑战
        function generateCrossChainChallenges(difficulty) {
            const challengeTemplates = {
                easy: [
                    { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                    { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                    { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 }
                ],
                medium: [
                    { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                    { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                    { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 },
                    { from: 'Arbitrum', to: 'Optimism', method: 'Synapse Protocol', cost: 0.03, time: 4 },
                    { from: 'Ethereum', to: 'BSC', method: 'Binance Bridge', cost: 0.08, time: 8 },
                    { from: 'Polygon', to: 'Avalanche', method: 'Avalanche Bridge', cost: 0.06, time: 6 }
                ],
                hard: [
                    { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                    { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                    { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 },
                    { from: 'Arbitrum', to: 'Optimism', method: 'Synapse Protocol', cost: 0.03, time: 4 },
                    { from: 'Ethereum', to: 'BSC', method: 'Binance Bridge', cost: 0.08, time: 8 },
                    { from: 'Polygon', to: 'Avalanche', method: 'Avalanche Bridge', cost: 0.06, time: 6 },
                    { from: 'Ethereum', to: 'Solana', method: 'Wormhole', cost: 0.12, time: 15 },
                    { from: 'Arbitrum', to: 'Base', method: 'Base Bridge', cost: 0.04, time: 7 },
                    { from: 'Polygon', to: 'Fantom', method: 'Multichain', cost: 0.07, time: 9 }
                ]
            };
            
            const bridges = challengeTemplates[difficulty] || challengeTemplates.easy;
            return [...bridges].sort(() => 0.5 - Math.random());
        }

        // Sound System
        const soundSystem = {
            playSound: function(soundName) {
                if (!gameState.soundEnabled) return;
                
                const sounds = {
                    click: () => this.createTone(800, 0.1, 'sine'),
                    success: () => this.createTone(1200, 0.3, 'sine'),
                    error: () => this.createTone(400, 0.5, 'sawtooth'),
                    jump: () => this.createTone(600, 0.2, 'square'),
                    collect: () => this.createTone(1000, 0.15, 'triangle'),
                    gameStart: () => this.createTone(800, 0.5, 'sine'),
                    gameEnd: () => this.createTone(400, 1, 'sawtooth')
                };
                
                if (sounds[soundName]) {
                    sounds[soundName]();
                }
            },
            
            createTone: function(frequency, duration, type) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }
        };

        // Background Music System
        const musicSystem = {
            isPlaying: false,
            audioContext: null,
            oscillators: [],
            
            startMusic: function() {
                if (!gameState.musicEnabled || this.isPlaying) return;
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.isPlaying = true;
                this.playMelody();
            },
            
            stopMusic: function() {
                this.isPlaying = false;
                this.oscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
                this.oscillators = [];
            },
            
            playMelody: function() {
                if (!this.isPlaying) return;
                
                // Anoma Academy Theme - Simple melody
                const melody = [
                    {freq: 523.25, duration: 0.5}, // C5
                    {freq: 659.25, duration: 0.5}, // E5
                    {freq: 783.99, duration: 0.5}, // G5
                    {freq: 659.25, duration: 0.5}, // E5
                    {freq: 523.25, duration: 0.5}, // C5
                    {freq: 440.00, duration: 0.5}, // A4
                    {freq: 523.25, duration: 1.0}, // C5
                ];
                
                let time = this.audioContext.currentTime;
                
                melody.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(note.freq, time);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, time);
                    gainNode.gain.linearRampToValueAtTime(0.05, time + 0.01);
                    gainNode.gain.linearRampToValueAtTime(0, time + note.duration);
                    
                    oscillator.start(time);
                    oscillator.stop(time + note.duration);
                    
                    this.oscillators.push(oscillator);
                    time += note.duration;
                });
                
                // Loop the melody
                setTimeout(() => {
                    if (this.isPlaying) {
                        this.playMelody();
                    }
                }, time * 1000);
            }
        };

        // Particle System
        const particleSystem = {
            particles: [],
            
            createParticle: function(x, y, type = 'sparkle') {
                const particle = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0,
                    decay: 0.02,
                    size: Math.random() * 4 + 2,
                    type: type,
                    color: this.getParticleColor(type)
                };
                this.particles.push(particle);
            },
            
            getParticleColor: function(type) {
                const colors = {
                    sparkle: ['#00d4ff', '#ff6b6b', '#4ecdc4', '#45b7d1'],
                    collect: ['#ffd700', '#ffed4e', '#fbbf24'],
                    jump: ['#8b5cf6', '#a78bfa', '#c4b5fd'],
                    success: ['#10b981', '#34d399', '#6ee7b7'],
                    error: ['#ef4444', '#f87171', '#fca5a5']
                };
                const colorSet = colors[type] || colors.sparkle;
                return colorSet[Math.floor(Math.random() * colorSet.length)];
            },
            
            update: function() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    particle.vy += 0.1; // gravity
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },
            
            render: function(context) {
                this.particles.forEach(particle => {
                    context.save();
                    context.globalAlpha = particle.life;
                    context.fillStyle = particle.color;
                    context.shadowBlur = 10;
                    context.shadowColor = particle.color;
                    context.beginPath();
                    context.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    context.fill();
                    context.restore();
                });
            },
            
            createExplosion: function(x, y, count = 20) {
                for (let i = 0; i < count; i++) {
                    this.createParticle(x, y, 'sparkle');
                }
            },
            
            createCollectEffect: function(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.createParticle(x, y, 'collect');
                }
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateStats();
            showToast('🏛️ Welcome to Anoma Academy! Start learning to earn points!', 'info');
            
            // Add mascot click events
            document.querySelectorAll('.mascot-shrimp').forEach(shrimp => {
                shrimp.addEventListener('click', function() {
                    this.classList.add('clicked');
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(this.offsetLeft + 20, this.offsetTop + 20, 20);
                    showToast('🦐 Anoma Shrimp says: Keep learning!', 'success');
                    
                    setTimeout(() => {
                        this.classList.remove('clicked');
                    }, 600);
                });
            });
            
            // Start background music after a short delay
            setTimeout(() => {
                if (gameState.musicEnabled) {
                    musicSystem.startMusic();
                }
            }, 1000);
        });

        // Update stats
        function updateStats() {
            document.getElementById('points').textContent = gameState.points;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('lessons-completed').textContent = `${gameState.lessonsCompleted}/6`;
            document.getElementById('games-played').textContent = gameState.gamesPlayed;
        }

        // Sound control functions
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const btn = document.getElementById('sound-btn');
            btn.textContent = gameState.soundEnabled ? '🔊 Sound On' : '🔇 Sound Off';
            btn.style.background = gameState.soundEnabled ? 'var(--success)' : 'var(--danger)';
            soundSystem.playSound('click');
        }

        function toggleMusic() {
            gameState.musicEnabled = !gameState.musicEnabled;
            const btn = document.getElementById('music-btn');
            btn.textContent = gameState.musicEnabled ? '🎵 Music On' : '🔇 Music Off';
            btn.style.background = gameState.musicEnabled ? 'var(--accent)' : 'var(--danger)';
            soundSystem.playSound('click');
            
            if (gameState.musicEnabled) {
                musicSystem.startMusic();
            } else {
                musicSystem.stopMusic();
            }
        }

        function showDifficultySelector() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Select Difficulty</h3>
                    <div style="margin: 30px 0;">
                        <div class="difficulty-option" onclick="setDifficulty('easy')" style="padding: 20px; margin: 10px 0; background: var(--surface); border-radius: 10px; cursor: pointer; border: 2px solid ${gameState.difficulty === 'easy' ? 'var(--success)' : 'var(--border)'};">
                            <h4 style="color: var(--success);">🟢 Easy</h4>
                            <p>Perfect for beginners. Slower pace, more hints.</p>
                        </div>
                        <div class="difficulty-option" onclick="setDifficulty('medium')" style="padding: 20px; margin: 10px 0; background: var(--surface); border-radius: 10px; cursor: pointer; border: 2px solid ${gameState.difficulty === 'medium' ? 'var(--warning)' : 'var(--border)'};">
                            <h4 style="color: var(--warning);">🟡 Medium</h4>
                            <p>Balanced challenge. Normal pace, some hints.</p>
                        </div>
                        <div class="difficulty-option" onclick="setDifficulty('hard')" style="padding: 20px; margin: 10px 0; background: var(--surface); border-radius: 10px; cursor: pointer; border: 2px solid ${gameState.difficulty === 'hard' ? 'var(--danger)' : 'var(--border)'};">
                            <h4 style="color: var(--danger);">🔴 Hard</h4>
                            <p>Expert level. Fast pace, no hints.</p>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            const btn = document.getElementById('difficulty-btn');
            const colors = { easy: 'var(--success)', medium: 'var(--warning)', hard: 'var(--danger)' };
            const icons = { easy: '🟢', medium: '🟡', hard: '🔴' };
            
            btn.textContent = `${icons[difficulty]} ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`;
            btn.style.background = colors[difficulty];
            
            soundSystem.playSound('success');
            showToast(`Difficulty set to ${difficulty}!`, 'success');
            closeModal();
        }

        // Achievement System
        function checkAchievements() {
            const newAchievements = [];
            
            // First game achievement
            if (gameState.gamesPlayed === 1 && !gameState.achievements.includes('first_game')) {
                newAchievements.push({ id: 'first_game', name: '🎮 First Game', description: 'Played your first game!' });
            }
            
            // Points achievements
            if (gameState.points >= 500 && !gameState.achievements.includes('points_500')) {
                newAchievements.push({ id: 'points_500', name: '💰 Point Collector', description: 'Earned 500 points!' });
            }
            
            if (gameState.points >= 1000 && !gameState.achievements.includes('points_1000')) {
                newAchievements.push({ id: 'points_1000', name: '💎 Point Master', description: 'Earned 1000 points!' });
            }
            
            // Lesson achievements
            if (gameState.lessonsCompleted >= 3 && !gameState.achievements.includes('lessons_3')) {
                newAchievements.push({ id: 'lessons_3', name: '📚 Student', description: 'Completed 3 lessons!' });
            }
            
            if (gameState.lessonsCompleted >= 6 && !gameState.achievements.includes('lessons_all')) {
                newAchievements.push({ id: 'lessons_all', name: '🎓 Graduate', description: 'Completed all lessons!' });
            }
            
            // Game achievements
            if (gameState.gamesPlayed >= 5 && !gameState.achievements.includes('games_5')) {
                newAchievements.push({ id: 'games_5', name: '🎯 Gamer', description: 'Played 5 games!' });
            }
            
            if (gameState.gamesPlayed >= 10 && !gameState.achievements.includes('games_10')) {
                newAchievements.push({ id: 'games_10', name: '🏆 Game Master', description: 'Played 10 games!' });
            }
            
            // Add new achievements
            newAchievements.forEach(achievement => {
                gameState.achievements.push(achievement.id);
                showAchievement(achievement);
            });
        }

        function showAchievement(achievement) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 400px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h2 class="animated-bounce">🏆 Achievement Unlocked!</h2>
                    <div style="font-size: 3rem; margin: 20px 0;">${achievement.name}</div>
                    <p style="font-size: 1.2rem; margin: 20px 0;">${achievement.description}</p>
                    <button class="btn" onclick="closeModal()" style="background: var(--accent);">Awesome!</button>
                </div>
            `;
            document.body.appendChild(modal);
            
            soundSystem.playSound('success');
            particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
        }

        // Start lesson
        function startLesson(lessonNumber) {
            if (gameState.completedLessons.includes(lessonNumber)) {
                showToast('You already completed this lesson!', 'error');
                soundSystem.playSound('error');
                return;
            }

            if (lessonNumber > 1 && !gameState.completedLessons.includes(lessonNumber - 1)) {
                showToast('Complete the previous lesson first!', 'error');
                soundSystem.playSound('error');
                return;
            }

            soundSystem.playSound('click');
            showLessonModal(lessonNumber);
        }

        // Show lesson modal with 10-second learning requirement
        function showLessonModal(lessonNumber) {
            const lessons = {
                1: {
                    title: "🌱 What is Anoma?",
                    content: `
                        <h3>What is Anoma?</h3>
                        <p>Anoma is a revolutionary blockchain protocol that introduces <strong>intent-centric interactions</strong>.</p>
                        <p>Instead of telling the system HOW to do something, you tell it WHAT you want to achieve.</p>
                        <br>
                        <h4>Key Concepts:</h4>
                        <ul>
                            <li><strong>Intent System:</strong> Express what you want, not how to do it</li>
                            <li><strong>Privacy First:</strong> Zero-knowledge proofs protect your data</li>
                            <li><strong>Cross-Chain:</strong> Works across multiple blockchains</li>
                            <li><strong>AI-Powered:</strong> Smart matching finds the best execution path</li>
                        </ul>
                        <br>
                        <h4>Example:</h4>
                        <p>Instead of: "Execute ETH/USDC swap on Uniswap V3"</p>
                        <p>You say: "I want to swap 1 ETH for the best possible amount of USDC"</p>
                    `
                },
                2: {
                    title: "⚡ Intent System",
                    content: `
                        <h3>How Intents Work</h3>
                        <p>Anoma's intent system processes your requests in three steps:</p>
                        <br>
                        <h4>1. Express Intent</h4>
                        <p>Tell the system what you want to achieve</p>
                        <br>
                        <h4>2. AI Analysis</h4>
                        <p>The system finds the best execution path across all available options</p>
                        <br>
                        <h4>3. Execute</h4>
                        <p>Your intent is automatically executed with optimal results</p>
                    `
                },
                3: {
                    title: "🔐 Privacy & ZK",
                    content: `
                        <h3>Zero-Knowledge Proofs</h3>
                        <p>Anoma uses zero-knowledge proofs to protect your privacy while maintaining security.</p>
                        <br>
                        <h4>How it works:</h4>
                        <ul>
                            <li>Prove you have the right to do something</li>
                            <li>Without revealing what that something is</li>
                            <li>Maintain complete privacy</li>
                        </ul>
                    `
                },
                4: {
                    title: "🌐 Cross-Chain",
                    content: `
                        <h3>Cross-Chain Operations</h3>
                        <p>Anoma works across multiple blockchains seamlessly.</p>
                        <br>
                        <h4>Benefits:</h4>
                        <ul>
                            <li>Access to all blockchain ecosystems</li>
                            <li>Best execution across chains</li>
                            <li>Unified experience</li>
                        </ul>
                    `
                },
                5: {
                    title: "🎯 Advanced Intents",
                    content: `
                        <h3>Complex Intent Strategies</h3>
                        <p>Learn to create sophisticated multi-step intents.</p>
                        <br>
                        <h4>Advanced Features:</h4>
                        <ul>
                            <li>Multi-step transactions</li>
                            <li>Conditional logic</li>
                            <li>Cross-chain arbitrage</li>
                        </ul>
                    `
                },
                6: {
                    title: "🏆 Anoma Master",
                    content: `
                        <h3>Congratulations!</h3>
                        <p>You've mastered the core concepts of Anoma!</p>
                        <br>
                        <h4>You now understand:</h4>
                        <ul>
                            <li>Intent-centric interactions</li>
                            <li>Privacy protection with ZK</li>
                            <li>Cross-chain operations</li>
                            <li>Advanced strategies</li>
                        </ul>
                    `
                }
            };

            const lesson = lessons[lessonNumber];
            if (!lesson) return;

            let timeLeft = 10; // 10 seconds required
            let canComplete = false;
            let timerInterval;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>${lesson.title}</h3>
                    <div style="margin: 20px 0; line-height: 1.8;">
                        ${lesson.content}
                    </div>
                    <div style="text-align: center; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px; border: 2px solid var(--border);">
                        <div style="font-size: 1.2rem; margin-bottom: 10px; color: var(--accent);">
                            ⏰ Learning Time Required: <span id="lesson-timer">${timeLeft}</span> seconds
                        </div>
                        <div style="font-size: 0.9rem; color: var(--muted);">
                            Please read the lesson content carefully. You can complete the lesson after the time is up.
                        </div>
                        <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; margin-top: 10px; overflow: hidden;">
                            <div id="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--accent), var(--success)); border-radius: 4px; transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 30px;">
                        <button id="complete-btn" class="btn" onclick="completeLesson(${lessonNumber})" disabled style="background: var(--muted); cursor: not-allowed; opacity: 0.6;">
                            Complete Lesson (Need <span id="complete-timer">${timeLeft}</span> more seconds)
                        </button>
                        <button class="btn" onclick="closeModal()" style="background: var(--muted);">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Start timer
            timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('lesson-timer').textContent = timeLeft;
                document.getElementById('complete-timer').textContent = timeLeft;
                
                // Update progress bar
                const progress = ((10 - timeLeft) / 10) * 100;
                document.getElementById('progress-bar').style.width = progress + '%';
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    canComplete = true;
                    
                    // Enable complete button
                    const completeBtn = document.getElementById('complete-btn');
                    completeBtn.disabled = false;
                    completeBtn.style.background = 'var(--success)';
                    completeBtn.style.cursor = 'pointer';
                    completeBtn.style.opacity = '1';
                    completeBtn.innerHTML = '✅ Complete Lesson';
                    
                    // Update timer display
                    document.getElementById('lesson-timer').textContent = '0';
                    document.getElementById('complete-timer').textContent = '0';
                    
                    // Show completion message
                    showToast('🎉 Learning time completed! You can now complete the lesson!', 'success');
                }
            }, 1000);
            
            // Store timer interval for cleanup
            modal.timerInterval = timerInterval;
        }

        // Complete lesson
        function completeLesson(lessonNumber) {
            // Check if learning time is complete
            const completeBtn = document.getElementById('complete-btn');
            if (completeBtn && completeBtn.disabled) {
                showToast('⏰ Please complete 10 seconds of learning time first!', 'error');
                return;
            }
            
            if (!gameState.completedLessons.includes(lessonNumber)) {
                gameState.completedLessons.push(lessonNumber);
                gameState.lessonsCompleted++;
                gameState.points += lessonNumber === 6 ? 100 : 50;
                gameState.level = Math.floor(gameState.lessonsCompleted / 2) + 1;
                
                updateStats();
                showToast(`Lesson ${lessonNumber} completed! +${lessonNumber === 6 ? 100 : 50} points`, 'success');
                
                // Unlock next lesson
                if (lessonNumber < 6) {
                    const nextLesson = document.querySelector(`[onclick="startLesson(${lessonNumber + 1})"]`);
                    if (nextLesson) {
                        nextLesson.classList.add('unlocked');
                    }
                }
            }
            closeModal();
        }

        // Game functions
        function playIntentGame() {
            if (!currentUser || !userData[currentUser.id]) {
                alert('请先登录！');
                return;
            }
            
            const user = userData[currentUser.id];
            if (user.points < 20) {
                showToast('积分不足！', 'error');
                return;
            }
            
            user.points -= 20;
            user.gamesPlayed++;
            localStorage.setItem('anoma-user-data', JSON.stringify(userData));
            updateUserStats();
            showIntentGame();
        }

        function showIntentGame() {
            // Get random questions based on current difficulty
            const questions = getRandomQuestions(gameState.difficulty, 5);
            let currentQuestion = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Matching Game</h3>
                    <div style="text-align: center; margin: 10px 0; color: var(--accent);">
                        <strong>Difficulty: ${gameState.difficulty.toUpperCase()} | Questions: ${questions.length}</strong>
                    </div>
                    <div id="intent-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Question ${currentQuestion + 1}/${questions.length}</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>${questions[0].question}</strong>
                            </div>
                            <div id="intent-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${questions[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectIntentOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="intent-score">Score: 0/${questions.length}</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectIntentOption = function(selectedIndex) {
                const correct = questions[currentQuestion].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct!', 'success');
                } else {
                    showToast('❌ Wrong!', 'error');
                }

                currentQuestion++;
                if (currentQuestion < questions.length) {
                    document.querySelector('h4').textContent = `Question ${currentQuestion + 1}/3`;
                    document.querySelector('#intent-game-content strong').textContent = questions[currentQuestion].question;
                    document.getElementById('intent-options').innerHTML = questions[currentQuestion].options.map((option, index) => 
                        `<button class="btn" onclick="selectIntentOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('intent-score').textContent = `Score: ${score}/${currentQuestion}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 10);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('intent-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/3</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playPuzzleGame() {
            if (!currentUser || !userData[currentUser.id]) {
                alert('请先登录！');
                return;
            }
            
            const user = userData[currentUser.id];
            if (user.points < 35) {
                showToast('积分不足！', 'error');
                return;
            }
            
            user.points -= 35;
            user.gamesPlayed++;
            localStorage.setItem('anoma-user-data', JSON.stringify(userData));
            updateUserStats();
            showPrivacyGame();
        }

        function playPrivacyGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showPrivacyGame();
        }

        function showPrivacyGame() {
            // Generate different puzzles based on difficulty
            const puzzles = generatePrivacyPuzzles(gameState.difficulty);

            let currentPuzzle = 0;
            let score = 0;
            let selectedPieces = [];
            let placedPieces = [];

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Privacy Puzzle Game</h3>
                    <div style="text-align: center; margin: 10px 0; color: var(--accent);">
                        <strong>Difficulty: ${gameState.difficulty.toUpperCase()} | Puzzles: ${puzzles.length}</strong>
                    </div>
                    <div id="puzzle-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>${puzzles[0].title}</h4>
                            <p>${puzzles[0].description}</p>
                            <div id="puzzle-board" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; min-height: 200px;">
                                ${puzzles[0].pieces.map((piece, index) => 
                                    `<div class="puzzle-piece" onclick="selectPuzzlePiece(${index})" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s ease;">${piece}</div>`
                                ).join('')}
                            </div>
                            <div id="puzzle-solution" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; min-height: 200px; background: rgba(0, 212, 255, 0.1); border-radius: 10px; padding: 20px;">
                                <div style="grid-column: 1/-1; text-align: center; color: var(--muted);">Drop pieces here in correct order</div>
                            </div>
                            <button class="btn" onclick="checkPuzzle()" style="background: var(--success);">Check Solution</button>
                            <div id="puzzle-score">Score: 0/2</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectPuzzlePiece = function(index) {
                if (selectedPieces.includes(index)) return;
                
                selectedPieces.push(index);
                const piece = puzzles[currentPuzzle].pieces[index];
                placedPieces.push(piece);
                
                updatePuzzleDisplay();
            };

            window.checkPuzzle = function() {
                const solution = puzzles[currentPuzzle].solution;
                const isCorrect = JSON.stringify(placedPieces) === JSON.stringify(solution);
                
                if (isCorrect) {
                    score++;
                    showToast('✅ Puzzle solved!', 'success');
                    
                    document.getElementById('puzzle-solution').innerHTML = `
                        <div style="grid-column: 1/-1; text-align: center;">
                            <h4>Correct! 🎉</h4>
                            <p>${puzzles[currentPuzzle].explanation}</p>
                        </div>
                    `;
                    
                    setTimeout(() => {
                        currentPuzzle++;
                        if (currentPuzzle < puzzles.length) {
                            loadPuzzle(currentPuzzle);
                        } else {
                            endPuzzleGame();
                        }
                    }, 2000);
                } else {
                    showToast('❌ Try again!', 'error');
                    selectedPieces = [];
                    placedPieces = [];
                    loadPuzzle(currentPuzzle);
                }
            };

            function loadPuzzle(index) {
                selectedPieces = [];
                placedPieces = [];
                
                document.querySelector('h4').textContent = puzzles[index].title;
                document.querySelector('p').textContent = puzzles[index].description;
                
                document.getElementById('puzzle-board').innerHTML = puzzles[index].pieces.map((piece, i) => 
                    `<div class="puzzle-piece" onclick="selectPuzzlePiece(${i})" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s ease;">${piece}</div>`
                ).join('');
                
                document.getElementById('puzzle-solution').innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--muted);">Drop pieces here in correct order</div>';
            }

            function updatePuzzleDisplay() {
                document.getElementById('puzzle-solution').innerHTML = placedPieces.map(piece => 
                    `<div style="background: var(--accent); color: white; border-radius: 8px; padding: 15px; text-align: center;">${piece}</div>`
                ).join('');
            }

            function endPuzzleGame() {
                const pointsEarned = Math.floor(score * 15);
                
                // 给用户添加积分
                if (currentUser && userData[currentUser.id]) {
                    const user = userData[currentUser.id];
                    user.points += pointsEarned;
                    user.wins += 1;
                    localStorage.setItem('anoma-user-data', JSON.stringify(userData));
                    updateUserStats();
                    showPointsNotification(pointsEarned, user.points);
                }
                
                document.getElementById('puzzle-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 All Puzzles Solved!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${score}/2</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playCrossChainGame() {
            if (gameState.points < 40) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 40;
            gameState.gamesPlayed++;
            updateStats();
            showCrossChainGame();
        }

        function playDetectiveGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showDetectiveGame();
        }

        function playGuardianGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showGuardianGame();
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPuzzleGame();
        }

        function showCrossChainGame() {
            // Generate different cross-chain challenges based on difficulty
            const bridges = generateCrossChainChallenges(gameState.difficulty);

            let currentBridge = 0;
            let score = 0;
            let timeLeft = 60;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🌉 Bridge Master Game</h3>
                    <div id="bridge-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Connect different blockchains efficiently</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; color: var(--warning);">
                                Time Left: <span id="bridge-time-left">${timeLeft}</span>s
                            </div>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Bridge from ${bridges[0].from} to ${bridges[0].to}</strong>
                            </div>
                            <div id="bridge-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${bridges.map((bridge, index) => 
                                    `<button class="btn" onclick="selectBridge(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${bridge.method} (${bridge.cost} ETH, ${bridge.time}min)</button>`
                                ).join('')}
                            </div>
                            <div id="bridge-score">Score: 0</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('bridge-time-left').textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endBridgeGame(score);
                }
            }, 1000);

            window.selectBridge = function(bridgeIndex) {
                const selectedBridge = bridges[bridgeIndex];
                const currentTarget = bridges[currentBridge];
                
                if (selectedBridge.from === currentTarget.from && selectedBridge.to === currentTarget.to) {
                    score++;
                    currentBridge = (currentBridge + 1) % bridges.length;
                    document.querySelector('#bridge-game-content strong').textContent = `Bridge from ${bridges[currentBridge].from} to ${bridges[currentBridge].to}`;
                    document.getElementById('bridge-score').textContent = `Score: ${score}`;
                    showToast('✅ Correct bridge!', 'success');
                } else {
                    showToast('❌ Wrong bridge!', 'error');
                }
            };

            function endBridgeGame(finalScore) {
                clearInterval(timer);
                const pointsEarned = Math.floor(finalScore * 25);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('bridge-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playSpeedGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showSpeedGame();
        }

        function showSpeedGame() {
            const intentChallenges = [
                {
                    scenario: "You want to swap 1 ETH for USDC at the best rate",
                    options: [
                        "I want 1 ETH → USDC at best rate",
                        "Execute swap on Uniswap",
                        "Check ETH price first",
                        "Wait for better rate"
                    ],
                    correct: 0,
                    explanation: "Express your intent, not the method!"
                },
                {
                    scenario: "You need to bridge 100 USDC from Ethereum to Polygon",
                    options: [
                        "I want 100 USDC on Polygon",
                        "Use Polygon bridge",
                        "Convert to MATIC first",
                        "Wait for lower fees"
                    ],
                    correct: 0,
                    explanation: "Anoma finds the best bridge automatically!"
                },
                {
                    scenario: "You want to stake 10 ATOM and earn rewards",
                    options: [
                        "I want to earn staking rewards on 10 ATOM",
                        "Delegate to validator X",
                        "Check validator commission",
                        "Wait for better rates"
                    ],
                    correct: 0,
                    explanation: "Express the goal, not the validator choice!"
                },
                {
                    scenario: "You want to vote on a governance proposal",
                    options: [
                        "I want to vote YES on proposal #123",
                        "Connect wallet to governance",
                        "Read proposal details",
                        "Wait for more info"
                    ],
                    correct: 0,
                    explanation: "Intent system handles the voting process!"
                },
                {
                    scenario: "You want to provide liquidity and earn fees",
                    options: [
                        "I want to earn fees from ETH/USDC liquidity",
                        "Add liquidity to Uniswap V3",
                        "Choose fee tier first",
                        "Wait for better APR"
                    ],
                    correct: 0,
                    explanation: "Express your earning intent, not the platform!"
                }
            ];

            let currentChallenge = 0;
            let score = 0;
            let timeLeft = 45;
            let gameRunning = false;
            let streak = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>⚡ Speed Intent Challenge</h3>
                    <div id="speed-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Choose the best intent expression!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                                <div style="font-size: 1.2rem; color: var(--warning);">
                                    ⏰ Time: <span id="speed-time-left">${timeLeft}</span>s
                            </div>
                                <div style="font-size: 1.2rem; color: var(--success);">
                                    🎯 Score: <span id="speed-score">${score}</span>
                            </div>
                                <div style="font-size: 1.2rem; color: var(--accent);">
                                    🔥 Streak: <span id="streak">${streak}</span>
                                </div>
                            </div>
                            
                            <div style="background: var(--bg); padding: 20px; border-radius: 15px; margin: 20px 0; border: 2px solid var(--border);">
                                <h4 style="color: var(--accent); margin-bottom: 15px;">Scenario:</h4>
                                <p id="scenario-text" style="font-size: 1.1rem; line-height: 1.5; margin-bottom: 20px;">${intentChallenges[0].scenario}</p>
                                
                                <h4 style="color: var(--success); margin-bottom: 15px;">Which is the best intent expression?</h4>
                                <div id="options-container" style="display: grid; gap: 10px;">
                                    ${intentChallenges[0].options.map((option, index) => `
                                        <button class="btn option-btn" onclick="selectOption(${index})" disabled
                                                style="background: var(--surface); color: var(--text); border: 2px solid var(--border); 
                                                       padding: 15px; text-align: left; border-radius: 8px; transition: all 0.3s ease;
                                                       opacity: 0.6; cursor: not-allowed;">
                                            ${option}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startSpeedGame()" id="start-speed-btn" 
                                        style="background: var(--success); font-size: 1.2rem; padding: 15px 30px;">
                                    🚀 Start Challenge
                                </button>
                            </div>
                            
                            <div id="feedback" style="margin: 20px 0; padding: 15px; border-radius: 8px; display: none;"></div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startSpeedGame = function() {
                console.log('Speed Intent game starting...');
                gameRunning = true;
                document.getElementById('start-speed-btn').style.display = 'none';
                
                // Enable option buttons
                document.querySelectorAll('.option-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
                
                // Timer
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('speed-time-left').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endSpeedGame(score);
                    }
                }, 1000);

                showToast('Challenge started! Choose the best intent expression!', 'info');
            };

            window.selectOption = function(selectedIndex) {
                if (!gameRunning) return;
                
                const challenge = intentChallenges[currentChallenge];
                const isCorrect = selectedIndex === challenge.correct;
                const feedback = document.getElementById('feedback');
                
                if (isCorrect) {
                    score += 10 + (streak * 2);
                    streak++;
                    feedback.style.background = 'rgba(16, 185, 129, 0.2)';
                    feedback.style.border = '2px solid var(--success)';
                    feedback.style.color = 'var(--success)';
                    feedback.innerHTML = `✅ Correct! ${challenge.explanation}`;
                    showToast('Great intent expression!', 'success');
                } else {
                    streak = 0;
                    feedback.style.background = 'rgba(239, 68, 68, 0.2)';
                    feedback.style.border = '2px solid var(--danger)';
                    feedback.style.color = 'var(--danger)';
                    feedback.innerHTML = `❌ Wrong! ${challenge.explanation}`;
                    showToast('Try again!', 'error');
                }
                
                feedback.style.display = 'block';
                
                // Update score display
                document.getElementById('speed-score').textContent = score;
                document.getElementById('streak').textContent = streak;
                
                // Move to next challenge after delay
                setTimeout(() => {
                    currentChallenge = (currentChallenge + 1) % intentChallenges.length;
                    if (currentChallenge === 0) {
                        // Shuffle challenges
                        intentChallenges.sort(() => Math.random() - 0.5);
                    }
                    loadNextChallenge();
                }, 2000);
            };

            window.loadNextChallenge = function() {
                const challenge = intentChallenges[currentChallenge];
                document.getElementById('scenario-text').textContent = challenge.scenario;
                
                const optionsContainer = document.getElementById('options-container');
                optionsContainer.innerHTML = challenge.options.map((option, index) => `
                    <button class="btn option-btn" onclick="selectOption(${index})" 
                            style="background: var(--surface); color: var(--text); border: 2px solid var(--border); 
                                   padding: 15px; text-align: left; border-radius: 8px; transition: all 0.3s ease;
                                   opacity: ${gameRunning ? '1' : '0.6'}; cursor: ${gameRunning ? 'pointer' : 'not-allowed'};"
                            ${!gameRunning ? 'disabled' : ''}>
                        ${option}
                    </button>
                `).join('');
                
                document.getElementById('feedback').style.display = 'none';
            };

            window.endSpeedGame = function(finalScore) {
                gameRunning = false;
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('speed-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Challenge Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0; color: var(--accent);">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0; color: var(--success);">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0; color: var(--muted);">
                            You've mastered the art of expressing intents! 🎯
                        </div>
                        <button class="btn" onclick="closeModal()" style="background: var(--accent); font-size: 1.1rem; padding: 15px 30px;">
                            Close
                        </button>
                    </div>
                `;
            };
        }

        function playDetectiveGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showDetectiveGame();
        }

        function showDetectiveGame() {
            const scenarios = [
                {
                    situation: "User wants to swap 100 USDC for ETH with maximum privacy",
                    options: [
                        "Use public DEX with high fees",
                        "Use Anoma intent system with ZK proofs",
                        "Use centralized exchange",
                        "Use multiple small transactions"
                    ],
                    correct: 1,
                    explanation: "Anoma's intent system with ZK proofs provides maximum privacy while maintaining efficiency"
                },
                {
                    situation: "User wants to vote on governance without revealing their choice",
                    options: [
                        "Vote publicly",
                        "Use zero-knowledge proof voting",
                        "Skip voting",
                        "Use email verification"
                    ],
                    correct: 1,
                    explanation: "ZK proof voting allows participation while maintaining privacy"
                }
            ];

            let currentScenario = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🔍 Intent Detective Game</h3>
                    <div id="detective-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Analyze complex intents and find the best solution</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Situation:</strong> ${scenarios[0].situation}
                            </div>
                            <div id="detective-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${scenarios[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="detective-score">Score: 0/2</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectDetectiveOption = function(selectedIndex) {
                const correct = scenarios[currentScenario].correct;
                
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct analysis!', 'success');
                } else {
                    showToast('❌ Wrong analysis!', 'error');
                }

                currentScenario++;
                if (currentScenario < scenarios.length) {
                    document.querySelector('#detective-game-content strong').textContent = `Situation: ${scenarios[currentScenario].situation}`;
                    document.getElementById('detective-options').innerHTML = scenarios[currentScenario].options.map((option, index) => 
                        `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('detective-score').textContent = `Score: ${score}/${currentScenario}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 20);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('detective-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/2</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function showGuardianGame() {
            const scenarios = [
                {
                    situation: "User wants to make a private transaction",
                    options: [
                        "Use public blockchain",
                        "Use zero-knowledge proof + private execution",
                        "Use centralized exchange",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "ZK proofs enable private transactions while maintaining blockchain security"
                },
                {
                    situation: "User wants to prove they own an NFT without showing which one",
                    options: [
                        "Show the NFT publicly",
                        "Use selective disclosure with ZK proof",
                        "Use email verification",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "Selective disclosure allows proving ownership without revealing specific details"
                }
            ];

            let currentScenario = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🛡️ Privacy Guardian Game</h3>
                    <div id="guardian-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Protect user privacy using Anoma's ZK technology</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Situation:</strong> ${scenarios[0].situation}
                            </div>
                            <div id="guardian-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${scenarios[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="guardian-score">Score: 0/2</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectGuardianOption = function(selectedIndex) {
                const correct = scenarios[currentScenario].correct;
                
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct protection!', 'success');
                } else {
                    showToast('❌ Wrong protection!', 'error');
                }

                currentScenario++;
                if (currentScenario < scenarios.length) {
                    document.querySelector('#guardian-game-content strong').textContent = `Situation: ${scenarios[currentScenario].situation}`;
                    document.getElementById('guardian-options').innerHTML = scenarios[currentScenario].options.map((option, index) => 
                        `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('guardian-score').textContent = `Score: ${score}/${currentScenario}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 20);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('guardian-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/2</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function showPuzzleGame() {
            const puzzles = [
                {
                    title: "ZK Proof Components",
                    description: "Drag and drop to arrange ZK proof components in correct order",
                    pieces: ["Secret Input", "Proof Generation", "Verification", "Public Output"],
                    solution: ["Secret Input", "Proof Generation", "Verification", "Public Output"]
                }
            ];

            let currentPuzzle = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Privacy Puzzle (Visual)</h3>
                    <div id="puzzle-visual-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>${puzzles[0].title}</h4>
                            <p>${puzzles[0].description}</p>
                            <div id="puzzle-drop-zone" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 20px 0; min-height: 200px; border: 2px dashed var(--border); border-radius: 10px; padding: 20px;">
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                                <div class="drop-slot" style="background: var(--surface); border: 2px solid var(--border); border-radius: 8px; padding: 20px; text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center; color: var(--muted);">Drop here</div>
                            </div>
                            <div id="puzzle-pieces" style="display: flex; gap: 10px; justify-content: center; margin: 20px 0;">
                                ${puzzles[0].pieces.map((piece, index) => 
                                    `<div class="puzzle-piece" draggable="true" data-piece="${piece}" style="background: var(--accent); color: white; padding: 10px 20px; border-radius: 5px; cursor: grab; user-select: none;">${piece}</div>`
                                ).join('')}
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="checkPuzzleSolution()">Check Solution</button>
                                <button class="btn" onclick="resetPuzzle()" style="background: var(--danger);">Reset</button>
                            </div>
                            <div id="puzzle-score">Score: 0</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Add drag and drop functionality
            const pieces = document.querySelectorAll('.puzzle-piece');
            const slots = document.querySelectorAll('.drop-slot');

            pieces.forEach(piece => {
                piece.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', this.dataset.piece);
                    this.style.opacity = '0.5';
                });

                piece.addEventListener('dragend', function(e) {
                    this.style.opacity = '1';
                });
            });

            slots.forEach(slot => {
                slot.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.background = 'var(--accent)';
                });

                slot.addEventListener('dragleave', function(e) {
                    this.style.background = 'var(--surface)';
                });

                slot.addEventListener('drop', function(e) {
                    e.preventDefault();
                    const piece = e.dataTransfer.getData('text/plain');
                    this.textContent = piece;
                    this.dataset.piece = piece;
                    this.style.background = 'var(--success)';
                    this.style.color = 'white';
                });
            });

            window.checkPuzzleSolution = function() {
                const placedPieces = Array.from(slots).map(slot => slot.dataset.piece);
                const solution = puzzles[currentPuzzle].solution;
                
                let correct = 0;
                placedPieces.forEach((piece, index) => {
                    if (piece === solution[index]) {
                        correct++;
                    }
                });

                if (correct === solution.length) {
                    score++;
                    showToast('🎉 Puzzle solved!', 'success');
                    document.getElementById('puzzle-score').textContent = `Score: ${score}`;
                } else {
                    showToast('❌ Try again!', 'error');
                }
            };

            window.resetPuzzle = function() {
                slots.forEach(slot => {
                    slot.textContent = 'Drop here';
                    slot.dataset.piece = '';
                    slot.style.background = 'var(--surface)';
                    slot.style.color = 'var(--muted)';
                });
            };
        }

        function showAnomaRunner() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            
            let score = 0;
            let timeLeft = 30;
            let gameRunning = true;
            let playerX = 50;
            let playerY = 200;
            let obstacles = [];
            let tokens = [];
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏃 Anoma Runner Game</h3>
                    <div id="runner-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Run and collect Anoma tokens!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="runner-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="runner-score">${score}</span></div>
                            </div>
                            <div id="runner-board" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden;">
                                <div id="runner-player" style="position: absolute; left: ${playerX}px; top: ${playerY}px; width: 30px; height: 30px; background: var(--accent); border-radius: 50%; font-size: 1.5rem; display: flex; align-items: center; justify-content: center;">🏃</div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startRunnerGame()" id="start-runner-btn" style="background: var(--success);">Start Game</button>
                                <button class="btn" onclick="jump()" id="jump-btn" disabled style="background: var(--accent);">Jump (Space)</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                Use Space key or click Jump to avoid obstacles and collect intent pieces!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            function startRunnerGame() {
                gameRunning = true;
                document.getElementById('start-runner-btn').disabled = true;
                document.getElementById('jump-btn').disabled = false;
                
                // Timer
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('runner-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endRunnerGame(score);
                    }
                }, 1000);

                // Game loop
                const gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    
                    moveObstacles();
                    checkCollisions();
                }, 50);

                // Keyboard controls
                document.addEventListener('keydown', handleKeyPress);
            }

            function handleKeyPress(e) {
                if (e.code === 'Space' && gameRunning) {
                    e.preventDefault();
                    jump();
                }
            }

            function jump() {
                if (!gameRunning) return;
                playerY = Math.max(50, playerY - 50);
                setTimeout(() => {
                    playerY = Math.min(350, playerY + 50);
                }, 300);
                soundSystem.playSound('jump');
            }

            function moveObstacles() {
                // Move existing obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 3;
                    if (obstacle.x < -50) {
                        obstacles.splice(index, 1);
                    }
                });

                // Spawn new obstacles
                if (Math.random() < 0.02) {
                    obstacles.push({
                        x: 600,
                        y: 300,
                        width: 30,
                        height: 50
                    });
                }

                // Spawn tokens
                if (Math.random() < 0.03) {
                    tokens.push({
                        x: 600,
                        y: Math.random() * 300 + 50,
                        type: Math.random() < 0.5 ? '🦐' : '💎'
                    });
                }

                // Move tokens
                tokens.forEach((token, index) => {
                    token.x -= 2;
                    if (token.x < -50) {
                        tokens.splice(index, 1);
                    }
                });

                // Check collisions
                checkCollisions();
                
                // Render
                renderRunnerGame();
            }

            function checkCollisions() {
                const playerX = 50;
                const playerWidth = 30;
                const playerHeight = 30;

                // Check obstacle collisions
                obstacles.forEach((obstacle, index) => {
                    const obstacleX = obstacle.x;
                    const obstacleY = 300 - obstacle.height;
                    const obstacleWidth = 30;
                    const obstacleHeight = obstacle.height;

                    if (playerX < obstacleX + obstacleWidth &&
                        playerX + playerWidth > obstacleX &&
                        playerY + playerHeight > obstacleY) {
                        // Collision detected
                        endRunnerGame(score);
                        return;
                    }
                });

                // Check token collisions
                tokens.forEach((token, index) => {
                    const itemX = token.x;
                    const itemY = token.y;
                    const itemSize = 20;

                    if (playerX < itemX + itemSize &&
                        playerX + playerWidth > itemX &&
                        playerY < itemY + itemSize &&
                        playerY + playerHeight > itemY) {
                        // Item collected
                        tokens.splice(index, 1);
                        score += 50;
                        soundSystem.playSound('collect');
                        particleSystem.createCollectEffect(itemX + itemSize/2, itemY + itemSize/2);
                        showToast('💎 Token collected!', 'success');
                    }
                });
            }

            function renderRunnerGame() {
                const board = document.getElementById('runner-board');
                const player = document.getElementById('runner-player');
                
                if (player) {
                    player.style.left = playerX + 'px';
                    player.style.top = playerY + 'px';
                }

                // Clear existing elements
                const existingObstacles = board.querySelectorAll('.runner-obstacle');
                const existingTokens = board.querySelectorAll('.runner-token');
                existingObstacles.forEach(el => el.remove());
                existingTokens.forEach(el => el.remove());
                
                // Render obstacles
                obstacles.forEach(obstacle => {
                    const obstacleEl = document.createElement('div');
                    obstacleEl.className = 'runner-obstacle';
                    obstacleEl.style.position = 'absolute';
                    obstacleEl.style.left = obstacle.x + 'px';
                    obstacleEl.style.top = (300 - obstacle.height) + 'px';
                    obstacleEl.style.width = obstacle.width + 'px';
                    obstacleEl.style.height = obstacle.height + 'px';
                    obstacleEl.style.background = 'var(--danger)';
                    obstacleEl.style.borderRadius = '5px';
                    board.appendChild(obstacleEl);
                });

                // Render tokens
                tokens.forEach(token => {
                    const tokenEl = document.createElement('div');
                    tokenEl.className = 'runner-token';
                    tokenEl.style.position = 'absolute';
                    tokenEl.style.left = token.x + 'px';
                    tokenEl.style.top = token.y + 'px';
                    tokenEl.style.fontSize = '1.5rem';
                    tokenEl.style.animation = 'float 1s ease-in-out infinite';
                    tokenEl.textContent = token.type;
                    board.appendChild(tokenEl);
                });

                // Update score
                document.getElementById('runner-score').textContent = score;
            }

            function endRunnerGame(finalScore) {
                gameRunning = false;
                clearInterval(gameLoop);
                clearInterval(timer);
                
                const pointsEarned = Math.floor(finalScore * 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('runner-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playAnomaRunner() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showAnomaRunner();
        }

        function showAnomaRunner() {
            const cases = [
                {
                    scenario: "User wants to swap 1 ETH for USDC but gas fees are too high",
                    options: [
                        "Wait for lower gas fees",
                        "Use Anoma intent system to find optimal path",
                        "Use centralized exchange",
                        "Skip the transaction"
                    ],
                    correct: 1,
                    explanation: "Anoma's intent system finds the most cost-effective execution path across all available options"
                },
                {
                    scenario: "User needs to vote on governance but wants to keep their choice private",
                    options: [
                        "Vote publicly",
                        "Use zero-knowledge proof voting",
                        "Skip voting",
                        "Use email verification"
                    ],
                    correct: 1,
                    explanation: "ZK proofs allow proving you voted without revealing your choice"
                },
                {
                    scenario: "User wants to bridge assets from Ethereum to Polygon with minimal slippage",
                    options: [
                        "Use direct bridge contract",
                        "Use Anoma cross-chain intent",
                        "Use centralized exchange",
                        "Wait for better rates"
                    ],
                    correct: 1,
                    explanation: "Anoma's cross-chain intents find the best bridge with optimal execution"
                }
            ];

            let currentCase = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🔍 Intent Detective Game</h3>
                    <div id="detective-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Case ${currentCase + 1}/3</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>${cases[0].scenario}</strong>
                            </div>
                            <div id="detective-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${cases[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="detective-score">Score: 0/3</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectDetectiveOption = function(selectedIndex) {
                const correct = cases[currentCase].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct solution!', 'success');
                } else {
                    showToast('❌ Wrong approach!', 'error');
                }

                currentCase++;
                if (currentCase < cases.length) {
                    document.querySelector('h4').textContent = `Case ${currentCase + 1}/3`;
                    document.querySelector('#detective-game-content strong').textContent = cases[currentCase].scenario;
                    document.getElementById('detective-options').innerHTML = cases[currentCase].options.map((option, index) => 
                        `<button class="btn" onclick="selectDetectiveOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('detective-score').textContent = `Score: ${score}/${currentCase}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 20);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('detective-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 All Cases Solved!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/3</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playGuardianGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showGuardianGame();
        }

        function showGuardianGame() {
            const scenarios = [
                {
                    situation: "User wants to vote on a governance proposal privately",
                    options: [
                        "Use public voting",
                        "Use zero-knowledge proof",
                        "Use email verification",
                        "Skip verification"
                    ],
                    correct: 1,
                    explanation: "Zero-knowledge proofs allow proving possession of voting rights without revealing identity"
                },
                {
                    situation: "User wants to make a private transaction",
                    options: [
                        "Use public blockchain",
                        "Use zero-knowledge proof + private execution",
                        "Use centralized exchange",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "ZK proofs enable private transactions while maintaining blockchain security"
                },
                {
                    situation: "User wants to prove they own an NFT without showing which one",
                    options: [
                        "Show the NFT publicly",
                        "Use selective disclosure with ZK proof",
                        "Use email verification",
                        "Use social media"
                    ],
                    correct: 1,
                    explanation: "Selective disclosure allows proving ownership without revealing specific details"
                }
            ];

            let currentScenario = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🛡️ Privacy Guardian Game</h3>
                    <div id="guardian-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Protect user privacy using Anoma's ZK technology</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Situation:</strong> ${scenarios[0].situation}
                            </div>
                            <div id="guardian-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${scenarios[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="guardian-score">Score: 0/3</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectGuardianOption = function(selectedIndex) {
                const correct = scenarios[currentScenario].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct privacy solution!', 'success');
                } else {
                    showToast('❌ Wrong approach!', 'error');
                }

                currentScenario++;
                if (currentScenario < scenarios.length) {
                    document.querySelector('#guardian-game-content strong').textContent = scenarios[currentScenario].situation;
                    document.getElementById('guardian-options').innerHTML = scenarios[currentScenario].options.map((option, index) => 
                        `<button class="btn" onclick="selectGuardianOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('guardian-score').textContent = `Score: ${score}/${currentScenario}`;
                } else {
                    // Game finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 15);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('guardian-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/3</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playBridgeGame() {
            if (gameState.points < 40) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 40;
            gameState.gamesPlayed++;
            updateStats();
            showBridgeGame();
        }

        function showBridgeGame() {
            const bridges = [
                { from: 'Ethereum', to: 'Polygon', method: 'Polygon Bridge', cost: 0.1, time: 10 },
                { from: 'Ethereum', to: 'Arbitrum', method: 'Arbitrum Bridge', cost: 0.05, time: 5 },
                { from: 'Polygon', to: 'Arbitrum', method: 'Hop Protocol', cost: 0.02, time: 3 },
                { from: 'Arbitrum', to: 'Optimism', method: 'Synapse Protocol', cost: 0.03, time: 4 },
                { from: 'Ethereum', to: 'BSC', method: 'Binance Bridge', cost: 0.08, time: 8 }
            ];

            let currentBridge = 0;
            let score = 0;
            let timeLeft = 60;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🌉 Bridge Master Game</h3>
                    <div id="bridge-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Connect different blockchains efficiently</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; color: var(--warning);">
                                Time Left: <span id="bridge-time-left">${timeLeft}</span>s
                            </div>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>Bridge from ${bridges[0].from} to ${bridges[0].to}</strong>
                            </div>
                            <div id="bridge-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${bridges.map((bridge, index) => 
                                    `<button class="btn" onclick="selectBridge(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${bridge.method} (${bridge.cost} ETH, ${bridge.time}min)</button>`
                                ).join('')}
                            </div>
                            <div id="bridge-score">Score: 0</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('bridge-time-left').textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endBridgeGame(score);
                }
            }, 1000);

            window.selectBridge = function(bridgeIndex) {
                const selectedBridge = bridges[bridgeIndex];
                const currentTarget = bridges[currentBridge];
                
                if (selectedBridge.from === currentTarget.from && selectedBridge.to === currentTarget.to) {
                    score++;
                    currentBridge = (currentBridge + 1) % bridges.length;
                    document.querySelector('#bridge-game-content strong').textContent = `Bridge from ${bridges[currentBridge].from} to ${bridges[currentBridge].to}`;
                    document.getElementById('bridge-score').textContent = `Score: ${score}`;
                    showToast('✅ Correct bridge!', 'success');
                } else {
                    showToast('❌ Wrong bridge!', 'error');
                }
            };

            function endBridgeGame(finalScore) {
                clearInterval(timer);
                const pointsEarned = Math.floor(finalScore * 25);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('bridge-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playBuilderGame() {
            if (gameState.points < 50) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 50;
            gameState.gamesPlayed++;
            updateStats();
            showBuilderGame();
        }

        function showBuilderGame() {
            const components = [
                { type: 'action', text: 'Swap', cost: 10 },
                { type: 'action', text: 'Bridge', cost: 15 },
                { type: 'action', text: 'Vote', cost: 5 },
                { type: 'action', text: 'Stake', cost: 20 },
                { type: 'token', text: 'ETH', cost: 5 },
                { type: 'token', text: 'USDC', cost: 5 },
                { type: 'token', text: 'USDT', cost: 5 },
                { type: 'amount', text: '1', cost: 2 },
                { type: 'amount', text: '100', cost: 2 },
                { type: 'amount', text: '1000', cost: 2 },
                { type: 'chain', text: 'Ethereum', cost: 8 },
                { type: 'chain', text: 'Polygon', cost: 8 },
                { type: 'chain', text: 'Arbitrum', cost: 8 }
            ];

            let budget = 50;
            let selectedComponents = [];
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 800px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Builder Game</h3>
                    <div id="builder-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Build complex intents with limited budget</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Budget: <span id="budget">${budget}</span> points</div>
                                <div>Score: <span id="builder-score">${score}</span></div>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                                <div>
                                    <h5>Available Components:</h5>
                                    <div id="components-list" style="display: grid; gap: 5px; max-height: 300px; overflow-y: auto;">
                                        ${components.map((comp, index) => 
                                            `<button class="btn" onclick="addComponent(${index})" style="font-size: 0.9rem; padding: 8px 12px; background: var(--surface); color: var(--text); border: 1px solid var(--border);">${comp.text} (${comp.cost})</button>`
                                        ).join('')}
                                    </div>
                                </div>
                                <div>
                                    <h5>Your Intent:</h5>
                                    <div id="intent-display" style="min-height: 200px; background: var(--bg); border: 2px solid var(--border); border-radius: 10px; padding: 15px; margin: 10px 0;">
                                        <div style="color: var(--muted); text-align: center;">No components selected</div>
                                    </div>
                                    <div style="margin: 10px 0;">
                                        <button class="btn" onclick="buildIntent()" style="background: var(--success);">Build Intent</button>
                                        <button class="btn" onclick="clearIntent()" style="background: var(--danger);">Clear</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.addComponent = function(index) {
                const component = components[index];
                if (budget >= component.cost) {
                    budget -= component.cost;
                    selectedComponents.push(component);
                    updateDisplay();
                } else {
                    showToast('Not enough budget!', 'error');
                }
            };

            window.buildIntent = function() {
                if (selectedComponents.length === 0) {
                    showToast('Select at least one component!', 'error');
                    return;
                }

                const intent = buildIntentText(selectedComponents);
                const points = calculateIntentScore(selectedComponents);
                score += points;
                
                showToast(`Intent built! +${points} points`, 'success');
                
                // Reset for next round
                budget = 50;
                selectedComponents = [];
                updateDisplay();
            };

            window.clearIntent = function() {
                budget = 50;
                selectedComponents = [];
                updateDisplay();
            };

            function updateDisplay() {
                document.getElementById('budget').textContent = budget;
                document.getElementById('builder-score').textContent = score;
                
                const intentDisplay = document.getElementById('intent-display');
                if (selectedComponents.length === 0) {
                    intentDisplay.innerHTML = '<div style="color: var(--muted); text-align: center;">No components selected</div>';
                } else {
                    intentDisplay.innerHTML = selectedComponents.map(comp => 
                        `<span style="background: var(--accent); color: white; padding: 4px 8px; border-radius: 4px; margin: 2px; display: inline-block;">${comp.text}</span>`
                    ).join('');
                }
            }

            function buildIntentText(components) {
                const actions = components.filter(c => c.type === 'action');
                const tokens = components.filter(c => c.type === 'token');
                const amounts = components.filter(c => c.type === 'amount');
                const chains = components.filter(c => c.type === 'chain');
                
                let intent = 'I want to ';
                if (actions.length > 0) {
                    intent += actions.map(a => a.text.toLowerCase()).join(' and ');
                }
                if (amounts.length > 0 && tokens.length > 0) {
                    intent += ` ${amounts[0].text} ${tokens[0].text}`;
                }
                if (chains.length > 0) {
                    intent += ` on ${chains[0].text}`;
                }
                
                return intent;
            }

            function calculateIntentScore(components) {
                let score = 0;
                const types = components.map(c => c.type);
                
                // Base score for each component
                score += components.length * 5;
                
                // Bonus for combinations
                if (types.includes('action') && types.includes('token')) score += 20;
                if (types.includes('action') && types.includes('chain')) score += 15;
                if (types.includes('amount') && types.includes('token')) score += 10;
                
                // Bonus for multiple actions
                const actionCount = types.filter(t => t === 'action').length;
                if (actionCount > 1) score += actionCount * 10;
                
                return score;
            }
        }

        function playTowerDefense() {
            if (gameState.points < 60) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 60;
            gameState.gamesPlayed++;
            updateStats();
            showTowerDefense();
        }

        function showTowerDefense() {
            let wave = 1;
            let score = 200;
            let health = 100;
            let towers = [];
            let enemies = [];
            let projectiles = [];
            let gameRunning = false;
            let selectedTower = null;
            let gameSpeed = 1;
            let enemySpawnTimer = 0;
            let waveEnemiesSpawned = 0;
            let waveEnemiesTotal = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 98%; max-width: 1200px; height: 90vh; overflow-y: auto;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎮 Intent Tower Defense - Defend Anoma!</h3>
                    <div id="tower-defense-content">
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent);">Wave ${wave}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Enemies: ${waveEnemiesSpawned}/${waveEnemiesTotal}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--danger);">❤️ ${health}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Health</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--success);">💰 ${score}</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Score</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--warning);">⚡ ${gameSpeed}x</div>
                                <div style="font-size: 0.9rem; color: var(--muted);">Speed</div>
                            </div>
                        </div>
                        
                        <div id="game-board" onclick="handleGameBoardClick(event)" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 3px solid var(--accent); border-radius: 15px; position: relative; overflow: hidden; cursor: crosshair; margin: 20px 0;">
                            <!-- Game path -->
                            <div id="path" style="position: absolute; top: 50%; left: 0; width: 100%; height: 40px; background: linear-gradient(90deg, rgba(0,212,255,0.3) 0%, rgba(0,212,255,0.1) 50%, rgba(0,212,255,0.3) 100%); transform: translateY(-50%); border-radius: 20px;"></div>
                            
                            <!-- Start and end points -->
                            <div style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--danger); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🚪</div>
                            <div style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🏠</div>
                            
                            <!-- Tower placement grid -->
                            <div id="tower-grid" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <h4>🛡️ Defense Tools - Click to select, then click on the field to place:</h4>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; padding: 15px; background: rgba(0, 0, 0, 0.05); border-radius: 10px;">
                                <button class="btn tower-btn" onclick="selectTower('ZK-Proof')" data-type="ZK-Proof" style="background: #10b981; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">🛡️</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">ZK-Proof</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 30 | Damage: 25 | Range: 80</div>
                                </button>
                                <button class="btn tower-btn" onclick="selectTower('Intent-Solver')" data-type="Intent-Solver" style="background: #3b82f6; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">⚡</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">Intent Solver</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 50 | Damage: 35 | Range: 100</div>
                                </button>
                                <button class="btn tower-btn" onclick="selectTower('Privacy-Guard')" data-type="Privacy-Guard" style="background: #f59e0b; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(245, 158, 11, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">🔐</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">Privacy Guard</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 40 | Damage: 30 | Range: 70</div>
                                </button>
                                <button class="btn tower-btn" onclick="selectTower('Cross-Chain')" data-type="Cross-Chain" style="background: #ef4444; color: white; border: 3px solid transparent; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);">
                                    <div style="font-size: 2rem; margin-bottom: 8px;">🌉</div>
                                    <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 5px;">Cross-Chain</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Cost: 60 | Damage: 45 | Range: 90</div>
                                </button>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 15px; margin: 25px 0; justify-content: center; flex-wrap: wrap; padding: 20px; background: rgba(0, 0, 0, 0.1); border-radius: 10px; min-height: 80px; align-items: center;">
                            <button class="btn" onclick="startWave()" id="wave-btn" style="background: #10b981; color: white; font-size: 1.3rem; padding: 18px 35px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 6px 12px rgba(16, 185, 129, 0.4); transition: all 0.3s ease; min-width: 180px;">🚀 Start Wave ${wave}</button>
                            <button class="btn" onclick="pauseGame()" id="pause-btn" style="background: #f59e0b; color: white; font-size: 1.3rem; padding: 18px 35px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 6px 12px rgba(245, 158, 11, 0.4); transition: all 0.3s ease; min-width: 150px;">⏸️ Pause</button>
                            <button class="btn" onclick="changeSpeed()" id="speed-btn" style="background: #3b82f6; color: white; font-size: 1.3rem; padding: 18px 35px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 6px 12px rgba(59, 130, 246, 0.4); transition: all 0.3s ease; min-width: 150px;">⚡ Speed ${gameSpeed}x</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Add hover effects for buttons
            setTimeout(() => {
                const buttons = modal.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    btn.addEventListener('mouseenter', function() {
                        this.style.transform = 'translateY(-2px)';
                        this.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3)';
                    });
                    btn.addEventListener('mouseleave', function() {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
                    });
                });
            }, 100);

            let gameInterval;
            let enemyInterval;

            // Tower selection and placement
            window.selectTower = function(type) {
                console.log('Selecting tower:', type);
                selectedTower = type;
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.style.border = '3px solid transparent';
                    btn.style.transform = 'scale(1)';
                });
                const selectedBtn = document.querySelector(`[data-type="${type}"]`);
                if (selectedBtn) {
                    selectedBtn.style.border = '3px solid #00ff88';
                    selectedBtn.style.transform = 'scale(1.05)';
                    selectedBtn.style.boxShadow = '0 8px 16px rgba(0, 255, 136, 0.4)';
                    console.log('Tower selected:', type);
                } else {
                    console.error('Tower button not found:', type);
                }
                soundSystem.playSound('click');
                showToast(`${type} selected! Click on the field to place.`, 'info');
            };

            // Click to place tower - bind after modal is added to DOM
            setTimeout(() => {
                const gameBoard = document.getElementById('game-board');
                if (gameBoard) {
                    // Remove any existing listeners
                    gameBoard.removeEventListener('click', handleGameBoardClick);
                    
                    // Add new listener
                    gameBoard.addEventListener('click', handleGameBoardClick);
                    console.log('Game board click listener bound');
                } else {
                    console.error('Game board element not found!');
                }
            }, 100);

            window.handleGameBoardClick = function(e) {
                console.log('Game board clicked, selectedTower:', selectedTower);
                if (!selectedTower) {
                    showToast('Please select a tower first!', 'error');
                    return;
                }
                
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                console.log('Click position:', x, y);
                
                // Check if position is valid (not on path)
                const pathY = rect.height / 2;
                const pathHeight = 40;
                if (Math.abs(y - pathY) < pathHeight / 2 + 30) {
                    showToast('Cannot place tower on the path!', 'error');
                    return;
                }
                
                // Check if position is too close to existing towers
                const minDistance = 60;
                const tooClose = towers.some(tower => {
                    const distance = Math.sqrt(Math.pow(tower.x - x, 2) + Math.pow(tower.y - y, 2));
                    return distance < minDistance;
                });
                
                if (tooClose) {
                    showToast('Too close to existing tower!', 'error');
                    return;
                }
                
                placeTower(selectedTower, x, y);
            };

            function placeTower(type, x, y) {
                console.log('Placing tower:', type, 'at position:', x, y);
                const cost = getTowerCost(type);
                if (score < cost) {
                    showToast('Not enough points!', 'error');
                    return;
                }
                
                const tower = {
                    type: type,
                    x: x,
                    y: y,
                    cost: cost,
                    damage: getTowerDamage(type),
                    range: getTowerRange(type),
                    lastShot: 0,
                    level: 1
                };
                
                towers.push(tower);
                score -= cost;
                selectedTower = null; // Reset selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.style.border = '2px solid transparent';
                });
                updateTowerDefenseDisplay();
                renderGame();
                soundSystem.playSound('success');
                showToast(`${type} tower placed!`, 'success');
            }

            window.startWave = function() {
                console.log('Starting wave...');
                if (!gameRunning) {
                    gameRunning = true;
                    startGameLoop();
                    soundSystem.playSound('gameStart');
                    console.log('Game loop started');
                }
                
                waveEnemiesTotal = 5 + wave * 2;
                waveEnemiesSpawned = 0;
                enemySpawnTimer = 0;
                
                document.getElementById('wave-btn').disabled = true;
                document.getElementById('wave-btn').textContent = `Wave ${wave} In Progress...`;
                showToast(`Wave ${wave} started! ${waveEnemiesTotal} enemies incoming!`, 'info');
                console.log(`Wave ${wave} started with ${waveEnemiesTotal} enemies`);
            };

            window.pauseGame = function() {
                gameRunning = !gameRunning;
                const btn = document.getElementById('pause-btn');
                btn.textContent = gameRunning ? '⏸️ Pause' : '▶️ Resume';
                btn.style.background = gameRunning ? 'var(--warning)' : 'var(--success)';
                soundSystem.playSound('click');
            };

            window.changeSpeed = function() {
                gameSpeed = gameSpeed >= 3 ? 1 : gameSpeed + 1;
                document.getElementById('speed-btn').textContent = `⚡ Speed ${gameSpeed}x`;
                soundSystem.playSound('click');
            };

            window.testPlaceTower = function() {
                console.log('Test place tower clicked');
                selectedTower = 'ZK-Proof';
                placeTower('ZK-Proof', 200, 100);
            };

            // Add click test to game board
            window.testGameBoardClick = function() {
                console.log('Testing game board click...');
                const gameBoard = document.getElementById('game-board');
                if (gameBoard) {
                    console.log('Game board found, adding test click');
                    gameBoard.style.border = '3px solid red';
                    setTimeout(() => {
                        gameBoard.style.border = '3px solid var(--accent)';
                    }, 1000);
                } else {
                    console.error('Game board not found!');
                }
            };

            function getTowerCost(type) {
                const costs = { 'ZK-Proof': 30, 'Intent-Solver': 50, 'Privacy-Guard': 40, 'Cross-Chain': 60 };
                return costs[type] || 30;
            }

            function getTowerDamage(type) {
                const damages = { 'ZK-Proof': 25, 'Intent-Solver': 35, 'Privacy-Guard': 30, 'Cross-Chain': 45 };
                return damages[type] || 25;
            }

            function getTowerRange(type) {
                const ranges = { 'ZK-Proof': 80, 'Intent-Solver': 100, 'Privacy-Guard': 70, 'Cross-Chain': 90 };
                return ranges[type] || 80;
            }

            function getTowerIcon(type) {
                const icons = { 'ZK-Proof': '🛡️', 'Intent-Solver': '⚡', 'Privacy-Guard': '🔐', 'Cross-Chain': '🌉' };
                return icons[type] || '🛡️';
            }

            function spawnEnemies() {
                if (waveEnemiesSpawned >= waveEnemiesTotal) return;
                
                const enemyTypes = [
                    { name: 'Malicious Intent', icon: '👹', health: 40, speed: 1.5, reward: 15, color: '#ff6b6b' },
                    { name: 'Privacy Breach', icon: '🕵️', health: 60, speed: 1.2, reward: 20, color: '#4ecdc4' },
                    { name: 'MEV Attack', icon: '💰', health: 80, speed: 1.0, reward: 25, color: '#ffe66d' },
                    { name: 'Front-running', icon: '🏃', health: 30, speed: 2.0, reward: 12, color: '#a8e6cf' },
                    { name: 'Sybil Attack', icon: '👥', health: 100, speed: 0.8, reward: 30, color: '#ff8b94' }
                ];
                
                const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const gameBoard = document.getElementById('game-board');
                const boardHeight = gameBoard ? gameBoard.offsetHeight : 500;
                const pathY = boardHeight / 2; // Center of the game board
                
                const enemy = {
                    type: enemyType.name,
                    icon: enemyType.icon,
                    x: -30,
                    y: pathY, // Center of path
                    health: enemyType.health + wave * 15,
                    maxHealth: enemyType.health + wave * 15,
                    speed: enemyType.speed + wave * 0.1,
                    reward: enemyType.reward + wave * 3,
                    color: enemyType.color,
                    id: Date.now() + Math.random()
                };
                
                enemies.push(enemy);
                waveEnemiesSpawned++;
                updateTowerDefenseDisplay();
                soundSystem.playSound('click');
            }

            function startGameLoop() {
                gameInterval = setInterval(() => {
                    if (!gameRunning) return;
                    
                    // Spawn enemies
                    enemySpawnTimer += gameSpeed;
                    if (enemySpawnTimer >= 60 && waveEnemiesSpawned < waveEnemiesTotal) {
                        spawnEnemies();
                        enemySpawnTimer = 0;
                    }
                    
                    // Move enemies
                    enemies.forEach((enemy, index) => {
                        enemy.x += enemy.speed * gameSpeed;
                        
                        if (enemy.x > 950) {
                            health -= Math.max(1, Math.floor(10 - wave * 0.5));
                            enemies.splice(index, 1);
                            soundSystem.playSound('error');
                            particleSystem.createExplosion(950, enemy.y, 20);
                            
                            if (health <= 0) {
                                endTowerDefense();
                            }
                        }
                    });

                    // Tower attacks
                    const currentTime = Date.now();
                    towers.forEach(tower => {
                        if (currentTime - tower.lastShot < 1000) return; // 1 second cooldown
                        
                        let target = null;
                        let minDistance = tower.range;
                        
                        enemies.forEach(enemy => {
                            const distance = Math.sqrt(Math.pow(tower.x - enemy.x, 2) + Math.pow(tower.y - enemy.y, 2));
                            if (distance <= tower.range && distance < minDistance) {
                                target = enemy;
                                minDistance = distance;
                            }
                        });
                        
                        if (target) {
                            tower.lastShot = currentTime;
                            createProjectile(tower, target);
                            soundSystem.playSound('click');
                        }
                    });

                    // Move projectiles
                    projectiles.forEach((projectile, index) => {
                        const dx = projectile.target.x - projectile.x;
                        const dy = projectile.target.y - projectile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // Hit target
                            projectile.target.health -= projectile.damage;
                            particleSystem.createExplosion(projectile.x, projectile.y, 15);
                            
                            if (projectile.target.health <= 0) {
                                score += projectile.target.reward;
                                enemies.splice(enemies.indexOf(projectile.target), 1);
                                soundSystem.playSound('collect');
                                particleSystem.createExplosion(projectile.target.x, projectile.target.y, 25);
                            }
                            
                            projectiles.splice(index, 1);
                        } else {
                            projectile.x += (dx / distance) * projectile.speed * gameSpeed;
                            projectile.y += (dy / distance) * projectile.speed * gameSpeed;
                        }
                    });

                    updateTowerDefenseDisplay();
                    renderGame();
                    
                    // Check wave complete
                    if (enemies.length === 0 && waveEnemiesSpawned >= waveEnemiesTotal) {
                        wave++;
                        if (wave <= 10) {
                            document.getElementById('wave-btn').disabled = false;
                            document.getElementById('wave-btn').textContent = `🚀 Start Wave ${wave}`;
                            showToast(`Wave ${wave - 1} complete! Get ready for Wave ${wave}!`, 'success');
                            soundSystem.playSound('success');
                        } else {
                            endTowerDefense();
                        }
                    }
                }, 1000 / 60); // 60 FPS
            }

            function createProjectile(tower, target) {
                const projectile = {
                    x: tower.x + 15,
                    y: tower.y + 15,
                    target: target,
                    damage: tower.damage,
                    speed: 8,
                    id: Date.now() + Math.random()
                };
                projectiles.push(projectile);
            }

            function renderGame() {
                const board = document.getElementById('game-board');
                board.innerHTML = `
                    <div id="path" style="position: absolute; top: 50%; left: 0; width: 100%; height: 40px; background: linear-gradient(90deg, rgba(0,212,255,0.3) 0%, rgba(0,212,255,0.1) 50%, rgba(0,212,255,0.3) 100%); transform: translateY(-50%); border-radius: 20px;"></div>
                    <div style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--danger); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🚪</div>
                    <div style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">🏠</div>
                `;
                
                // Render towers
                towers.forEach(tower => {
                    const towerEl = document.createElement('div');
                    towerEl.style.position = 'absolute';
                    towerEl.style.left = (tower.x - 20) + 'px';
                    towerEl.style.top = (tower.y - 20) + 'px';
                    towerEl.style.width = '40px';
                    towerEl.style.height = '40px';
                    towerEl.style.fontSize = '1.5rem';
                    towerEl.style.display = 'flex';
                    towerEl.style.alignItems = 'center';
                    towerEl.style.justifyContent = 'center';
                    towerEl.style.background = 'rgba(0, 212, 255, 0.2)';
                    towerEl.style.border = '2px solid var(--accent)';
                    towerEl.style.borderRadius = '50%';
                    towerEl.style.cursor = 'pointer';
                    towerEl.style.zIndex = '10';
                    towerEl.title = `${tower.type} - Level ${tower.level} - Range: ${tower.range}`;
                    towerEl.innerHTML = getTowerIcon(tower.type);
                    
                    // Range indicator
                    const rangeEl = document.createElement('div');
                    rangeEl.style.position = 'absolute';
                    rangeEl.style.left = '50%';
                    rangeEl.style.top = '50%';
                    rangeEl.style.transform = 'translate(-50%, -50%)';
                    rangeEl.style.width = (tower.range * 2) + 'px';
                    rangeEl.style.height = (tower.range * 2) + 'px';
                    rangeEl.style.border = '1px dashed rgba(0, 212, 255, 0.3)';
                    rangeEl.style.borderRadius = '50%';
                    rangeEl.style.pointerEvents = 'none';
                    rangeEl.style.display = 'none';
                    rangeEl.style.zIndex = '5';
                    towerEl.appendChild(rangeEl);
                    
                    towerEl.addEventListener('mouseenter', () => {
                        rangeEl.style.display = 'block';
                    });
                    
                    towerEl.addEventListener('mouseleave', () => {
                        rangeEl.style.display = 'none';
                    });
                    
                    board.appendChild(towerEl);
                });
                
                // Render enemies
                enemies.forEach(enemy => {
                    const enemyEl = document.createElement('div');
                    enemyEl.style.position = 'absolute';
                    enemyEl.style.left = (enemy.x - 15) + 'px';
                    enemyEl.style.top = (enemy.y - 15) + 'px';
                    enemyEl.style.width = '30px';
                    enemyEl.style.height = '30px';
                    enemyEl.style.fontSize = '1.2rem';
                    enemyEl.style.display = 'flex';
                    enemyEl.style.alignItems = 'center';
                    enemyEl.style.justifyContent = 'center';
                    enemyEl.style.background = enemy.color;
                    enemyEl.style.borderRadius = '50%';
                    enemyEl.style.border = '2px solid white';
                    enemyEl.style.animation = 'float 1s ease-in-out infinite';
                    enemyEl.style.zIndex = '8';
                    enemyEl.innerHTML = enemy.icon;
                    
                    // Health bar
                    const healthBar = document.createElement('div');
                    healthBar.style.position = 'absolute';
                    healthBar.style.top = '-8px';
                    healthBar.style.left = '0';
                    healthBar.style.width = '30px';
                    healthBar.style.height = '4px';
                    healthBar.style.background = 'rgba(0,0,0,0.3)';
                    healthBar.style.borderRadius = '2px';
                    healthBar.style.overflow = 'hidden';
                    
                    const healthFill = document.createElement('div');
                    healthFill.style.width = ((enemy.health / enemy.maxHealth) * 100) + '%';
                    healthFill.style.height = '100%';
                    healthFill.style.background = enemy.health > enemy.maxHealth * 0.5 ? '#4CAF50' : '#f44336';
                    healthFill.style.transition = 'width 0.3s ease';
                    
                    healthBar.appendChild(healthFill);
                    enemyEl.appendChild(healthBar);
                    
                    board.appendChild(enemyEl);
                });
                
                // Render projectiles
                projectiles.forEach(projectile => {
                    const projectileEl = document.createElement('div');
                    projectileEl.style.position = 'absolute';
                    projectileEl.style.left = (projectile.x - 3) + 'px';
                    projectileEl.style.top = (projectile.y - 3) + 'px';
                    projectileEl.style.width = '6px';
                    projectileEl.style.height = '6px';
                    projectileEl.style.background = 'var(--accent)';
                    projectileEl.style.borderRadius = '50%';
                    projectileEl.style.boxShadow = '0 0 10px var(--accent)';
                    projectileEl.style.animation = 'pulse 0.5s infinite';
                    projectileEl.style.zIndex = '15';
                    
                    board.appendChild(projectileEl);
                });
            }

            function updateTowerDefenseDisplay() {
                // Update the display elements in the modal
                const waveElement = document.querySelector('[style*="Wave"]');
                const healthElement = document.querySelector('[style*="❤️"]');
                const scoreElement = document.querySelector('[style*="💰"]');
                const waveInfo = document.querySelector('[style*="Enemies:"]');
                
                if (waveElement) {
                    waveElement.textContent = wave;
                }
                if (healthElement) {
                    healthElement.textContent = `❤️ ${health}`;
                }
                if (scoreElement) {
                    scoreElement.textContent = `💰 ${score}`;
                }
                if (waveInfo) {
                    waveInfo.textContent = `Enemies: ${waveEnemiesSpawned}/${waveEnemiesTotal}`;
                }
            }

            function endTowerDefense() {
                gameRunning = false;
                clearInterval(gameInterval);
                
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                gameState.gamesPlayed++;
                updateStats();
                checkAchievements();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">${health <= 0 ? '💀 Game Over!' : '🎉 Victory!'}</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Waves Survived: ${wave - 1}/10
                        </div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Towers Built: ${towers.length}
                        </div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Enemies Defeated: ${score / 20}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }

            function upgradeTower(tower) {
                if (score >= tower.cost) {
                    tower.damage += 5;
                    tower.range += 10;
                    score -= tower.cost;
                    updateTowerDefenseDisplay();
                    renderGame();
                    showToast('Tower upgraded!', 'success');
                } else {
                    showToast('Not enough points to upgrade!', 'error');
                }
            }
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPuzzleGame();
        }

        function showPuzzleGame() {
            const puzzlePieces = [
                { id: 1, text: 'Generate Proof', type: 'step', order: 1 },
                { id: 2, text: 'Verify Identity', type: 'step', order: 2 },
                { id: 3, text: 'Submit Transaction', type: 'step', order: 3 },
                { id: 4, text: 'Validate on Chain', type: 'step', order: 4 },
                { id: 5, text: 'Privacy Preserved', type: 'result', order: 5 }
            ];

            let score = 0;
            let timeLeft = 60;
            let currentPuzzle = 0;
            let selectedPieces = [];

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Privacy Puzzle Game</h3>
                    <div id="puzzle-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Arrange ZK-Proof flow correctly</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time Left: <span id="puzzle-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="puzzle-score">${score}</span></div>
                            </div>
                            <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Drop pieces here in correct order:</h5>
                                <div id="puzzle-area" style="min-height: 200px; border: 2px dashed var(--border); border-radius: 5px; padding: 10px; display: flex; flex-direction: column; gap: 5px;">
                                    <div style="color: var(--muted); text-align: center;">Drag pieces here</div>
                                </div>
                            </div>
                            <div style="background: var(--surface); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Available pieces:</h5>
                                <div id="pieces-container" style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                    ${puzzlePieces.map(piece => 
                                        `<div class="puzzle-piece" data-id="${piece.id}" data-order="${piece.order}" style="background: var(--accent); color: white; padding: 10px 15px; border-radius: 5px; cursor: grab; user-select: none;">${piece.text}</div>`
                                    ).join('')}
                                </div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="checkPuzzle()" style="background: var(--success);">Check Solution</button>
                                <button class="btn" onclick="resetPuzzle()" style="background: var(--warning);">Reset</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('puzzle-time').textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endPuzzleGame(score);
                }
            }, 1000);

            // Make pieces draggable
            const pieces = document.querySelectorAll('.puzzle-piece');
            pieces.forEach(piece => {
                piece.draggable = true;
                piece.addEventListener('dragstart', handleDragStart);
            });

            const puzzleArea = document.getElementById('puzzle-area');
            puzzleArea.addEventListener('dragover', handleDragOver);
            puzzleArea.addEventListener('drop', handleDrop);

            let draggedPiece = null;

            function handleDragStart(e) {
                draggedPiece = e.target;
                e.target.style.opacity = '0.5';
            }

            function handleDragOver(e) {
                e.preventDefault();
            }

            function handleDrop(e) {
                e.preventDefault();
                if (draggedPiece) {
                    const piece = {
                        id: parseInt(draggedPiece.dataset.id),
                        text: draggedPiece.textContent,
                        order: parseInt(draggedPiece.dataset.order)
                    };
                    
                    if (!selectedPieces.find(p => p.id === piece.id)) {
                        selectedPieces.push(piece);
                        renderPuzzleArea();
                        draggedPiece.style.display = 'none';
                    }
                    draggedPiece.style.opacity = '1';
                    draggedPiece = null;
                }
            }

            function renderPuzzleArea() {
                const area = document.getElementById('puzzle-area');
                if (selectedPieces.length === 0) {
                    area.innerHTML = '<div style="color: var(--muted); text-align: center;">Drag pieces here</div>';
                } else {
                    area.innerHTML = selectedPieces.map((piece, index) => 
                        `<div style="background: var(--accent); color: white; padding: 8px 12px; border-radius: 4px; margin: 2px; display: inline-block; cursor: pointer;" onclick="removePiece(${piece.id})">${index + 1}. ${piece.text}</div>`
                    ).join('');
                }
            }

            window.removePiece = function(id) {
                selectedPieces = selectedPieces.filter(p => p.id !== id);
                renderPuzzleArea();
                
                // Show the piece again
                const piece = document.querySelector(`[data-id="${id}"]`);
                if (piece) {
                    piece.style.display = 'block';
                }
            };

            window.checkPuzzle = function() {
                if (selectedPieces.length !== puzzlePieces.length) {
                    showToast('Complete the puzzle first!', 'error');
                    return;
                }

                let correct = 0;
                selectedPieces.forEach((piece, index) => {
                    if (piece.order === index + 1) {
                        correct++;
                    }
                });

                const points = Math.floor((correct / puzzlePieces.length) * 100);
                score += points;
                document.getElementById('puzzle-score').textContent = score;

                if (correct === puzzlePieces.length) {
                    showToast('🎉 Perfect! Puzzle solved!', 'success');
                    setTimeout(() => {
                        resetPuzzle();
                    }, 2000);
                } else {
                    showToast(`✅ ${correct}/${puzzlePieces.length} correct! Try again!`, 'warning');
                }
            };

            window.resetPuzzle = function() {
                selectedPieces = [];
                renderPuzzleArea();
                
                // Show all pieces again
                pieces.forEach(piece => {
                    piece.style.display = 'block';
                });
            };

            function endPuzzleGame(finalScore) {
                clearInterval(timer);
                const pointsEarned = Math.floor(finalScore / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('puzzle-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playRunnerGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showSimpleRunnerGame();
        }

        function showSimpleRunnerGame() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏃 Intent Runner</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                            <div>Score: <span id="runner-score">0</span></div>
                            <div>Status: <span id="jump-status">Ready</span></div>
                        </div>
                        <div id="runner-board" style="width: 100%; height: 300px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border: 2px solid var(--border); border-radius: 10px; position: relative; overflow: hidden;">
                            <div id="runner-player" style="position: absolute; left: 50px; bottom: 20px; width: 30px; height: 30px; background: var(--accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; z-index: 10;">🧙‍♂️</div>
                        </div>
                        <div style="margin: 20px 0;">
                            <p><strong>Controls:</strong> Press SPACE to jump!</p>
                            <p><strong>Goal:</strong> Jump over obstacles 🚫 on the ground and collect diamonds 💎 in the air!</p>
                        </div>
                        <div style="margin: 20px 0;">
                            <button class="btn" onclick="startSimpleRunner()" id="start-runner-btn">Start Game</button>
                            <button class="btn" onclick="testJump()" style="background: var(--accent);">Test Jump</button>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Game state variables
            let gameRunning = false;
            let score = 0;
            let obstacles = [];
            let collectibles = [];
            let gameInterval;
            let obstacleInterval;
            let player = document.getElementById('runner-player');
            let isJumping = false;
            let jumpHeight = 0;
            let jumpSpeed = 0;
            let gravity = 0.4; // 减少重力，让跳跃更高
            let jumpPower = 18; // 增加跳跃力度，确保能跳过Obstacles

            function startSimpleRunner() {
                console.log('Starting Intent Runner game...');
                gameRunning = true;
                score = 0;
                isJumping = false;
                obstacles = [];
                collectibles = [];
                jumpHeight = 0;
                jumpSpeed = 0;
                
                document.getElementById('start-runner-btn').disabled = true;
                document.getElementById('jump-status').textContent = 'Ready';
                
                // Reset player position
                player.style.bottom = '20px';
                
                // Start game loop
                gameInterval = setInterval(() => {
                    if (!gameRunning) return;
                    updateGame();
                    renderGame();
                }, 16); // 60 FPS
                
                // Start spawning obstacles
                obstacleInterval = setInterval(() => {
                    if (!gameRunning) return;
                    spawnObstacle();
                    if (Math.random() < 0.4) { // 增加Collect品生成概率
                        spawnCollectible();
                    }
                }, 1200); // 更频繁的Obstacles生成

                soundSystem.playSound('gameStart');
                showToast('Intent Runner started! Press SPACE to jump!', 'success');
            }

            function spawnObstacle() {
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                obstacle.style.position = 'absolute';
                obstacle.style.right = '-30px';
                obstacle.style.bottom = '20px'; // Obstacles在地面上
                obstacle.style.width = '30px';
                obstacle.style.height = '50px'; // 更高的Obstacles
                obstacle.style.background = 'var(--danger)';
                obstacle.style.borderRadius = '5px';
                obstacle.style.display = 'flex';
                obstacle.style.alignItems = 'center';
                obstacle.style.justifyContent = 'center';
                obstacle.style.fontSize = '20px';
                obstacle.style.zIndex = '5';
                obstacle.textContent = '🚫';
                
                document.getElementById('runner-board').appendChild(obstacle);
                
                obstacles.push({
                    element: obstacle,
                    x: 600,
                    speed: 4 // 更快的Move速度
                });
            }

            function spawnCollectible() {
                const collectible = document.createElement('div');
                collectible.className = 'collectible';
                collectible.style.position = 'absolute';
                collectible.style.right = '-30px';
                collectible.style.bottom = '120px'; // 在空中，需要跳跃才能Collect
                collectible.style.width = '25px';
                collectible.style.height = '25px';
                collectible.style.background = 'var(--success)';
                collectible.style.borderRadius = '50%';
                collectible.style.display = 'flex';
                collectible.style.alignItems = 'center';
                collectible.style.justifyContent = 'center';
                collectible.style.fontSize = '16px';
                collectible.style.zIndex = '5';
                collectible.textContent = '💎';
                
                document.getElementById('runner-board').appendChild(collectible);
                
                collectibles.push({
                    element: collectible,
                    x: 600,
                    speed: 4
                });
            }

            function updateGame() {
                // Update jump physics
                if (isJumping) {
                    jumpSpeed -= gravity;
                    jumpHeight += jumpSpeed;
                    
                    if (jumpHeight <= 0) {
                        jumpHeight = 0;
                        jumpSpeed = 0;
                        isJumping = false;
                        player.style.bottom = '20px';
                        document.getElementById('jump-status').textContent = 'Ready';
                    } else {
                        player.style.bottom = (20 + jumpHeight) + 'px';
                        document.getElementById('jump-status').textContent = 'Jumping!';
                    }
                }

                // Move obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= obstacle.speed;
                    obstacle.element.style.right = (600 - obstacle.x) + 'px';
                    
                    if (obstacle.x < -50) {
                        obstacle.element.remove();
                        obstacles.splice(index, 1);
                        score += 10;
                    }
                });

                // Move collectibles
                collectibles.forEach((collectible, index) => {
                    collectible.x -= collectible.speed;
                    collectible.element.style.right = (600 - collectible.x) + 'px';
                    
                    if (collectible.x < -50) {
                        collectible.element.remove();
                        collectibles.splice(index, 1);
                    }
                });

                // Check collisions
                checkCollisions();
            }

            function checkCollisions() {
                const playerRect = player.getBoundingClientRect();
                const boardRect = document.getElementById('runner-board').getBoundingClientRect();
                const playerX = playerRect.left - boardRect.left;
                const playerY = playerRect.top - boardRect.top;
                const playerWidth = 30;
                const playerHeight = 30;

                // Check obstacle collisions
                obstacles.forEach((obstacle, index) => {
                    const obstacleRect = obstacle.element.getBoundingClientRect();
                    const obstacleX = obstacleRect.left - boardRect.left;
                    const obstacleY = obstacleRect.top - boardRect.top;
                    const obstacleWidth = 30;
                    const obstacleHeight = 50;

                    // Simple collision detection: player and obstacles overlap
                    if (playerX < obstacleX + obstacleWidth &&
                        playerX + playerWidth > obstacleX &&
                        playerY < obstacleY + obstacleHeight &&
                        playerY + playerHeight > obstacleY) {
                        // Collision detected
                        endGame();
                        return;
                    }
                });

                // Check collectible collisions
                collectibles.forEach((collectible, index) => {
                    const collectibleRect = collectible.element.getBoundingClientRect();
                    const collectibleX = collectibleRect.left - boardRect.left;
                    const collectibleY = collectibleRect.top - boardRect.top;
                    const collectibleWidth = 20;
                    const collectibleHeight = 20;

                    if (playerX < collectibleX + collectibleWidth &&
                        playerX + playerWidth > collectibleX &&
                        playerY < collectibleY + collectibleHeight &&
                        playerY + playerHeight > collectibleY) {
                        // Item collected
                        collectible.element.remove();
                        collectibles.splice(index, 1);
                        score += 50;
                        soundSystem.playSound('collect');
                        particleSystem.createCollectEffect(collectibleX + collectibleWidth/2, collectibleY + collectibleHeight/2);
                        showToast('💎 Diamond collected!', 'success');
                    }
                });
            }

            function renderGame() {
                // Update score
                document.getElementById('runner-score').textContent = score;
                
                // Render ground line
                const board = document.getElementById('runner-board');
                const existingGround = document.getElementById('ground-line');
                if (existingGround) {
                    existingGround.remove();
                }
                
                const ground = document.createElement('div');
                ground.id = 'ground-line';
                ground.style.position = 'absolute';
                ground.style.left = '0px';
                ground.style.bottom = '20px';
                ground.style.width = '100%';
                ground.style.height = '3px';
                ground.style.background = 'var(--accent)';
                ground.style.zIndex = '1';
                board.appendChild(ground);
            }

            function jump() {
                console.log('Jump function called!');
                if (isJumping || !gameRunning) {
                    console.log('Jump blocked - isJumping:', isJumping, 'gameRunning:', gameRunning);
                    return;
                }
                
                isJumping = true;
                jumpSpeed = jumpPower;
                jumpHeight = 0;
                document.getElementById('jump-status').textContent = 'Jumping!';
                soundSystem.playSound('jump');
                particleSystem.createParticle(50 + 15, 20 + 15, 'jump');
                console.log('Jump started!');
            }

            function testJump() {
                if (!gameRunning) {
                    showToast('Please start the game first!', 'warning');
                    return;
                }
                jump();
            }

            // Make functions globally accessible
            window.jump = jump;
            window.testJump = testJump;

            function endGame() {
                gameRunning = false;
                clearInterval(gameInterval);
                clearInterval(obstacleInterval);
                
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                gameState.gamesPlayed++;
                updateStats();
                checkAchievements();
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(400, 150, 30);
                
                document.getElementById('runner-board').innerHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                        <h3 class="animated-bounce">🎉 Game Over!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                    </div>
                `;
            }

            window.startSimpleRunner = startSimpleRunner;
        }

        function playDiceGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showDiceGame();
        }

        function showArcheryGame() {
            if (gameState.points < 30) {
                showToast('Not enough points! Need 30 points to play.', 'error');
                return;
            }
            
            gameState.points -= 30;
            updateStats();
            
            let score = 0;
            let arrows = 10;
            let targetX = 400;
            let targetY = 200;
            let targetSize = 60;
            let gameRunning = true;
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Archery Game</h3>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Score: <span id="archery-score">0</span></div>
                        <div>Arrows: <span id="archery-arrows">10</span></div>
                        <div>Target: <span id="archery-target">🎯</span></div>
                    </div>
                    <div id="archery-game" style="width: 100%; height: 400px; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); border: 3px solid var(--accent); border-radius: 15px; position: relative; overflow: hidden; cursor: crosshair;">
                        <div id="archery-target" style="position: absolute; left: ${targetX}px; top: ${targetY}px; width: ${targetSize}px; height: ${targetSize}px; background: radial-gradient(circle, #ff6b6b 0%, #ee5a24 50%, #c23616 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2rem; animation: pulse 2s infinite; border: 3px solid white; box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);">
                            🎯
                        </div>
                        <div id="archery-arrow" style="position: absolute; left: 50px; top: 50%; transform: translateY(-50%); font-size: 3rem; transition: all 0.3s ease; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));">🏹</div>
                        <div id="crosshair" style="position: absolute; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; pointer-events: none; display: none;"></div>
                        <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 1.2rem; text-align: center;">
                            <div>🎯 Click to shoot! Aim for the moving target!</div>
                            <div style="font-size: 0.9rem; margin-top: 5px; opacity: 0.8;">Target moves every 1.5-3 seconds</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const gameArea = document.getElementById('archery-game');
            const target = document.getElementById('archery-target');
            
            // Move target randomly
            function moveTarget() {
                if (!gameRunning) return;
                
                targetX = 200 + Math.random() * 400;
                targetY = 100 + Math.random() * 200;
                target.style.left = targetX + 'px';
                target.style.top = targetY + 'px';
                
                setTimeout(moveTarget, 1500 + Math.random() * 1500);
            }
            
            // Start moving target immediately
            moveTarget();
            
            // Add crosshair following mouse
            gameArea.addEventListener('mousemove', function(e) {
                const rect = this.getBoundingClientRect();
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = (e.clientX - rect.left - 10) + 'px';
                crosshair.style.top = (e.clientY - rect.top - 10) + 'px';
                crosshair.style.display = 'block';
            });
            
            gameArea.addEventListener('mouseleave', function() {
                document.getElementById('crosshair').style.display = 'none';
            });
            
            gameArea.addEventListener('click', function(e) {
                if (!gameRunning || arrows <= 0) return;
                
                const rect = this.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Calculate distance from target center
                const distance = Math.sqrt(Math.pow(clickX - (targetX + targetSize/2), 2) + Math.pow(clickY - (targetY + targetSize/2), 2));
                
                let points = 0;
                let hitType = '';
                if (distance < targetSize/2) {
                    points = 100;
                    hitType = 'BULLSEYE!';
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(clickX, clickY, 30);
                    showToast('🎯 BULLSEYE! +100 points!', 'success');
                } else if (distance < targetSize) {
                    points = 50;
                    hitType = 'HIT!';
                    soundSystem.playSound('click');
                    particleSystem.createExplosion(clickX, clickY, 20);
                    showToast('🎯 HIT! +50 points!', 'success');
                } else if (distance < targetSize * 1.5) {
                    points = 25;
                    hitType = 'CLOSE!';
                    soundSystem.playSound('click');
                    showToast('🎯 Close! +25 points!', 'warning');
                } else {
                    hitType = 'MISS!';
                    soundSystem.playSound('error');
                    showToast('❌ Miss! Try again!', 'error');
                }
                
                score += points;
                arrows--;
                
                document.getElementById('archery-score').textContent = score;
                document.getElementById('archery-arrows').textContent = arrows;
                
                // Show arrow trajectory
                const arrow = document.getElementById('archery-arrow');
                arrow.style.left = clickX + 'px';
                arrow.style.top = clickY + 'px';
                arrow.style.transform = 'translate(-50%, -50%)';
                
                // Create trajectory line
                const trajectory = document.createElement('div');
                trajectory.style.position = 'absolute';
                trajectory.style.left = '50px';
                trajectory.style.top = '50%';
                trajectory.style.width = Math.sqrt(Math.pow(clickX - 50, 2) + Math.pow(clickY - 200, 2)) + 'px';
                trajectory.style.height = '2px';
                trajectory.style.background = 'linear-gradient(90deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.2) 100%)';
                trajectory.style.transformOrigin = '0 50%';
                trajectory.style.transform = `rotate(${Math.atan2(clickY - 200, clickX - 50)}rad)`;
                trajectory.style.pointerEvents = 'none';
                trajectory.style.zIndex = '1';
                gameArea.appendChild(trajectory);
                
                setTimeout(() => {
                    arrow.style.left = '50px';
                    arrow.style.top = '50%';
                    arrow.style.transform = 'translateY(-50%)';
                    trajectory.remove();
                }, 500);
                
                if (arrows <= 0) {
                    endArcheryGame();
                }
            });
            
            function endArcheryGame() {
                gameRunning = false;
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎯 Archery Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Accuracy: ${Math.round((score / 1000) * 100)}%
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function playRunnerGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showRunnerGame();
        }

        function showRunnerGame() {
            
            let score = 0;
            let timeLeft = 30;
            let gameRunning = true;
            let playerX = 50;
            let playerY = 200;
            let tokens = [];
            let obstacles = [];
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏃 Anoma Runner Game</h3>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Score: <span id="runner-score">0</span></div>
                        <div>Time: <span id="runner-time">30</span></div>
                        <div>Speed: <span id="runner-speed">1x</span></div>
                    </div>
                    <div id="runner-game" style="width: 100%; height: 400px; background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%); border: 3px solid var(--accent); border-radius: 15px; position: relative; overflow: hidden;">
                        <div id="runner-player" style="position: absolute; left: ${playerX}px; top: ${playerY}px; font-size: 3rem; z-index: 10;">🧙‍♂️</div>
                        <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 1.2rem;">
                            Use WASD or Arrow Keys to move! Collect Anoma tokens!
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const gameArea = document.getElementById('runner-game');
            const player = document.getElementById('runner-player');
            
            // Game loop
            const gameLoop = setInterval(() => {
                if (!gameRunning) return;
                
                // Move player
                player.style.left = playerX + 'px';
                player.style.top = playerY + 'px';
                
                // Spawn tokens
                if (Math.random() < 0.1) {
                    spawnToken();
                }
                
                // Spawn obstacles
                if (Math.random() < 0.05) {
                    spawnObstacle();
                }
                
                // Move tokens
                tokens.forEach((token, index) => {
                    token.x -= 3;
                    if (token.x < -50) {
                        tokens.splice(index, 1);
                    }
                });
                
                // Move obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 2;
                    if (obstacle.x < -50) {
                        obstacles.splice(index, 1);
                    }
                });
                
                // Check collisions
                checkCollisions();
                
                // Render
                renderRunnerGame();
                
            }, 1000 / 60);
            
            // Timer
            const timer = setInterval(() => {
                timeLeft--;
                document.getElementById('runner-time').textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    endRunnerGame();
                }
            }, 1000);
            
            // Controls
            document.addEventListener('keydown', function(e) {
                if (!gameRunning) return;
                
                const speed = 10;
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        playerY = Math.max(50, playerY - speed);
                        break;
                    case 's':
                    case 'arrowdown':
                        playerY = Math.min(350, playerY + speed);
                        break;
                    case 'a':
                    case 'arrowleft':
                        playerX = Math.max(50, playerX - speed);
                        break;
                    case 'd':
                    case 'arrowright':
                        playerX = Math.min(750, playerX + speed);
                        break;
                }
            });
            
            function spawnToken() {
                tokens.push({
                    x: 800,
                    y: 100 + Math.random() * 200,
                    type: Math.random() < 0.5 ? '🪙' : '💎',
                    value: Math.random() < 0.5 ? 10 : 20
                });
            }
            
            function spawnObstacle() {
                obstacles.push({
                    x: 800,
                    y: 100 + Math.random() * 200,
                    type: '🚫'
                });
            }
            
            function checkCollisions() {
                // Check token collisions
                tokens.forEach((token, index) => {
                    const distance = Math.sqrt(Math.pow(playerX - token.x, 2) + Math.pow(playerY - token.y, 2));
                    if (distance < 30) {
                        score += token.value;
                        tokens.splice(index, 1);
                        soundSystem.playSound('collect');
                        particleSystem.createExplosion(token.x, token.y, 20);
                    }
                });
                
                // Check obstacle collisions
                obstacles.forEach((obstacle, index) => {
                    const distance = Math.sqrt(Math.pow(playerX - obstacle.x, 2) + Math.pow(playerY - obstacle.y, 2));
                    if (distance < 30) {
                        score = Math.max(0, score - 50);
                        obstacles.splice(index, 1);
                        soundSystem.playSound('error');
                        particleSystem.createExplosion(obstacle.x, obstacle.y, 30);
                    }
                });
                
                document.getElementById('runner-score').textContent = score;
            }
            
            function renderRunnerGame() {
                // Clear previous elements
                const existingTokens = gameArea.querySelectorAll('.runner-token');
                const existingObstacles = gameArea.querySelectorAll('.runner-obstacle');
                existingTokens.forEach(el => el.remove());
                existingObstacles.forEach(el => el.remove());
                
                // Render tokens
                tokens.forEach(token => {
                    const tokenEl = document.createElement('div');
                    tokenEl.className = 'runner-token';
                    tokenEl.style.position = 'absolute';
                    tokenEl.style.left = token.x + 'px';
                    tokenEl.style.top = token.y + 'px';
                    tokenEl.style.fontSize = '2rem';
                    tokenEl.style.animation = 'float 1s ease-in-out infinite';
                    tokenEl.textContent = token.type;
                    gameArea.appendChild(tokenEl);
                });
                
                // Render obstacles
                obstacles.forEach(obstacle => {
                    const obstacleEl = document.createElement('div');
                    obstacleEl.className = 'runner-obstacle';
                    obstacleEl.style.position = 'absolute';
                    obstacleEl.style.left = obstacle.x + 'px';
                    obstacleEl.style.top = obstacle.y + 'px';
                    obstacleEl.style.fontSize = '2rem';
                    obstacleEl.style.animation = 'pulse 1s ease-in-out infinite';
                    obstacleEl.textContent = obstacle.type;
                    gameArea.appendChild(obstacleEl);
                });
            }
            
            function endRunnerGame() {
                gameRunning = false;
                clearInterval(gameLoop);
                clearInterval(timer);
                
                const pointsEarned = Math.floor(score / 5);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🏃 Runner Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Tokens Collected: ${Math.floor(score / 15)}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function showComingSoon() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <div style="font-size: 4rem; margin: 20px 0;">🚀</div>
                    <h2>More Games Coming Soon!</h2>
                    <h3>更多游戏敬请期待！</h3>
                    <div style="margin: 30px 0; padding: 20px; background: var(--surface); border-radius: 10px;">
                        <h4>🎮 Upcoming Games:</h4>
                        <ul style="text-align: left; margin: 20px 0;">
                            <li>🎯 Intent Battle Royale</li>
                            <li>🏆 Anoma Racing Championship</li>
                            <li>🧠 Memory Challenge</li>
                            <li>🎪 Intent Carnival</li>
                            <li>⚔️ Privacy Wars</li>
                            <li>🎨 Intent Art Studio</li>
                        </ul>
                    </div>
                    <p style="color: var(--muted); margin: 20px 0;">
                        We're working hard to bring you more exciting games that teach Anoma concepts!
                    </p>
                    <button class="btn" onclick="closeModal()" style="background: var(--accent);">Got it!</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showShrimpCollector() {
            if (gameState.points < 20) {
                showToast('Not enough points! Need 20 points to play.', 'error');
                return;
            }
            
            gameState.points -= 20;
            updateStats();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🦐 Shrimp Collector Game</h3>
                    <div id="shrimp-game-board" style="width: 500px; height: 300px; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); margin: 20px auto; position: relative; border-radius: 10px; overflow: hidden;">
                        <div id="shrimp-score" style="position: absolute; top: 10px; left: 10px; color: white; font-size: 1.2rem; font-weight: bold;">Score: 0</div>
                        <div id="shrimp-timer" style="position: absolute; top: 10px; right: 10px; color: white; font-size: 1.2rem; font-weight: bold;">Time: 30</div>
                        <div id="shrimp-instructions" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.1rem;">
                            Click the shrimps to collect them!<br>
                            <button class="btn" onclick="startShrimpGame()" style="margin-top: 10px;">Start Game</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function startShrimpGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = true;
            const board = document.getElementById('shrimp-game-board');
            const instructions = document.getElementById('shrimp-instructions');
            
            instructions.style.display = 'none';
            
            function createShrimp() {
                if (!gameRunning) return;
                
                const shrimp = document.createElement('div');
                shrimp.innerHTML = '🦐';
                shrimp.style.position = 'absolute';
                shrimp.style.fontSize = '2rem';
                shrimp.style.cursor = 'pointer';
                shrimp.style.left = Math.random() * 450 + 'px';
                shrimp.style.top = Math.random() * 250 + 'px';
                shrimp.style.animation = 'float 1s ease-in-out infinite';
                
                shrimp.onclick = function() {
                    score += 10;
                    document.getElementById('shrimp-score').textContent = 'Score: ' + score;
                    soundSystem.playSound('collect');
                    particleSystem.createExplosion(this.offsetLeft + 20, this.offsetTop + 20, 15);
                    this.remove();
                };
                
                board.appendChild(shrimp);
                
                setTimeout(() => {
                    if (shrimp.parentNode) {
                        shrimp.remove();
                    }
                }, 2000);
            }
            
            function updateTimer() {
                if (!gameRunning) return;
                
                timeLeft--;
                document.getElementById('shrimp-timer').textContent = 'Time: ' + timeLeft;
                
                if (timeLeft <= 0) {
                    gameRunning = false;
                    const pointsEarned = Math.floor(score / 10);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    board.innerHTML = `
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                            <h3 class="animated-bounce">🎉 Game Over!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Final Score: ${score}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        </div>
                    `;
                    soundSystem.playSound('gameEnd');
                    particleSystem.createExplosion(250, 150, 30);
                }
            }
            
            setInterval(createShrimp, 800);
            setInterval(updateTimer, 1000);
        }

        function showAnomaQuiz() {
            if (gameState.points < 50) {
                showToast('Not enough points! Need 50 points to play.', 'error');
                return;
            }
            
            gameState.points -= 50;
            updateStats();
            
            const questions = [
                {
                    question: "What is Anoma's core philosophy?",
                    options: ["Centralized control", "Intent-centric design", "Proof of work", "Mining rewards"],
                    correct: 1,
                    explanation: "Anoma is built around the concept of intents - what users want to achieve rather than how to achieve it."
                },
                {
                    question: "What does ZK stand for in Anoma?",
                    options: ["Zero Knowledge", "Zero Karma", "Zero Key", "Zero Kernel"],
                    correct: 0,
                    explanation: "ZK stands for Zero Knowledge, enabling privacy-preserving transactions."
                },
                {
                    question: "What is the main benefit of Anoma's intent system?",
                    options: ["Higher fees", "Better user experience", "More complexity", "Slower transactions"],
                    correct: 1,
                    explanation: "Intent systems abstract away complexity, making DeFi more accessible to users."
                },
                {
                    question: "How does Anoma ensure privacy?",
                    options: ["Public ledgers", "Zero-knowledge proofs", "Centralized servers", "Open source code"],
                    correct: 1,
                    explanation: "Anoma uses zero-knowledge proofs to enable private transactions while maintaining verifiability."
                },
                {
                    question: "What is cross-chain functionality in Anoma?",
                    options: ["Single chain only", "Multi-chain operations", "Chain isolation", "No interoperability"],
                    correct: 1,
                    explanation: "Anoma enables seamless operations across multiple blockchains through its intent system."
                }
            ];
            
            let currentQuestion = 0;
            let score = 0;
            
            function showQuestion() {
                if (currentQuestion >= questions.length) {
                    endQuiz();
                    return;
                }
                
                const q = questions[currentQuestion];
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; text-align: center;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3>🧠 Anoma Master Quiz</h3>
                        <div style="margin: 20px 0; font-size: 1.1rem;">
                            Question ${currentQuestion + 1} of ${questions.length}
                        </div>
                        <h4 style="margin: 20px 0;">${q.question}</h4>
                        <div style="display: grid; gap: 10px; margin: 20px 0;">
                            ${q.options.map((option, index) => `
                                <button class="btn" onclick="answerQuestion(${index})" style="text-align: left; padding: 15px;">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            window.answerQuestion = function(selectedIndex) {
                const q = questions[currentQuestion];
                const isCorrect = selectedIndex === q.correct;
                
                if (isCorrect) {
                    score += 20;
                    soundSystem.playSound('success');
                    showToast('Correct! +20 points', 'success');
                } else {
                    soundSystem.playSound('error');
                    showToast(`Wrong! The correct answer is: ${q.options[q.correct]}`, 'error');
                }
                
                closeModal();
                currentQuestion++;
                setTimeout(showQuestion, 1000);
            };
            
            function endQuiz() {
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px; text-align: center;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎉 Quiz Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Score: ${score}/${questions.length * 20}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Accuracy: ${Math.round((score / (questions.length * 20)) * 100)}%
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 40);
            }
            
            showQuestion();
        }

        function showMemoryGame() {
            if (gameState.points < 25) {
                showToast('Not enough points! Need 25 points to play.', 'error');
                return;
            }
            
            gameState.points -= 25;
            updateStats();
            
            const cards = [
                { id: 1, emoji: '🛡️', name: 'ZK-Proof' },
                { id: 2, emoji: '⚡', name: 'Intent Solver' },
                { id: 3, emoji: '🔐', name: 'Privacy Guard' },
                { id: 4, emoji: '🌉', name: 'Cross-Chain' },
                { id: 5, emoji: '🎯', name: 'Intent Matching' },
                { id: 6, emoji: '🔍', name: 'Intent Detective' },
                { id: 7, emoji: '🦐', name: 'Anoma Shrimp' },
                { id: 8, emoji: '🧙‍♂️', name: 'Anoma Wizard' }
            ];
            
            // Duplicate cards for matching
            const gameCards = [...cards, ...cards].sort(() => Math.random() - 0.5);
            
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let gameStartTime = Date.now();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧠 Anoma Memory Game</h3>
                    <div style="text-align: center; margin: 15px 0; color: var(--muted);">
                        Match Anoma concepts and characters! Find the pairs!
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Moves: <span id="memory-moves">0</span></div>
                        <div>Pairs: <span id="memory-pairs">0/8</span></div>
                        <div>Time: <span id="memory-time">0s</span></div>
                    </div>
                    <div id="memory-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;">
                        ${gameCards.map((card, index) => `
                            <div class="memory-card" data-index="${index}" data-id="${card.id}" onclick="flipCard(${index})" style="
                                width: 80px; height: 80px; background: var(--surface); border: 2px solid var(--border); 
                                border-radius: 10px; display: flex; align-items: center; justify-content: center; 
                                font-size: 2rem; cursor: pointer; transition: all 0.3s ease; user-select: none;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                            ">
                                <div class="card-back" style="font-size: 1.5rem; color: var(--accent);">❓</div>
                                <div class="card-front" style="display: none; font-size: 2.2rem; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));">${card.emoji}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div id="memory-message" style="font-size: 1.2rem; margin: 20px 0; min-height: 30px;"></div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Start timer
            const timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('memory-time').textContent = elapsed + 's';
            }, 1000);
            
            window.flipCard = function(index) {
                const card = document.querySelector(`[data-index="${index}"]`);
                if (!card || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                
                card.classList.add('flipped');
                card.querySelector('.card-back').style.display = 'none';
                card.querySelector('.card-front').style.display = 'flex';
                card.style.background = 'linear-gradient(135deg, var(--accent), var(--success))';
                card.style.transform = 'rotateY(180deg) scale(1.1)';
                card.style.boxShadow = '0 4px 15px rgba(0, 212, 255, 0.4)';
                
                flippedCards.push({ index, id: gameCards[index].id, element: card });
                moves++;
                document.getElementById('memory-moves').textContent = moves;
                
                if (flippedCards.length === 2) {
                    setTimeout(() => {
                        checkMatch();
                    }, 500);
                }
                
                soundSystem.playSound('click');
            };
            
            function checkMatch() {
                const [card1, card2] = flippedCards;
                
                if (card1.id === card2.id) {
                    // Match found
                    card1.element.classList.add('matched');
                    card2.element.classList.add('matched');
                    card1.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card2.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card1.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card2.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card1.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    card2.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    matchedPairs++;
                    document.getElementById('memory-pairs').textContent = `${matchedPairs}/8`;
                    
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(card1.element.offsetLeft + 40, card1.element.offsetTop + 40, 25);
                    showToast(`🎉 Match found! ${card1.element.querySelector('.card-front').textContent}`, 'success');
                    
                    if (matchedPairs === 8) {
                        endMemoryGame();
                    }
                } else {
                    // No match
                    setTimeout(() => {
                        card1.element.classList.remove('flipped');
                        card2.element.classList.remove('flipped');
                        card1.element.querySelector('.card-back').style.display = 'flex';
                        card1.element.querySelector('.card-front').style.display = 'none';
                        card2.element.querySelector('.card-back').style.display = 'flex';
                        card2.element.querySelector('.card-front').style.display = 'none';
                        card1.element.style.background = 'var(--surface)';
                        card2.element.style.background = 'var(--surface)';
                        card1.element.style.transform = 'rotateY(0deg)';
                        card2.element.style.transform = 'rotateY(0deg)';
                    }, 1000);
                    
                    soundSystem.playSound('error');
                }
                
                flippedCards = [];
            }
            
            function endMemoryGame() {
                clearInterval(timer);
                const timeElapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                const pointsEarned = Math.max(10, 100 - moves - timeElapsed);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎉 Memory Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Perfect Match!</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Time: ${timeElapsed}s | Moves: ${moves}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function playDiceGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showDiceGame();
        }

        function showDiceGame() {
            let score = 0;
            let rolls = 0;
            let maxRolls = 10;
            let dice = [0, 0, 0, 0, 0];

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎲 Intent Dice Game</h3>
                    <div id="dice-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Roll dice to build the best intent combinations</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Score: <span id="dice-score">${score}</span></div>
                                <div>Rolls Left: <span id="rolls-left">${maxRolls - rolls}</span></div>
                            </div>
                            <div id="dice-container" style="display: flex; justify-content: center; gap: 10px; margin: 20px 0;">
                                ${dice.map((value, index) => 
                                    `<div class="dice" onclick="holdDice(${index})" style="width: 60px; height: 60px; background: var(--surface); border: 2px solid var(--border); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: all 0.3s ease;">${value || '?'}</div>`
                                ).join('')}
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="rollDice()" id="roll-btn">Roll Dice</button>
                                <button class="btn" onclick="scoreDice()" id="score-btn" disabled>Score Intent</button>
                            </div>
                            <div id="dice-combinations" style="margin: 20px 0;">
                                <h5>Available Intent Combinations:</h5>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left;">
                                    <div>Swap + Token = 50 points</div>
                                    <div>Bridge + Chain = 40 points</div>
                                    <div>Vote + Privacy = 60 points</div>
                                    <div>Stake + Yield = 70 points</div>
                                    <div>Three of a kind = 30 points</div>
                                    <div>Full house = 100 points</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            const intentTypes = ['Swap', 'Bridge', 'Vote', 'Stake', 'Token', 'Chain', 'Privacy', 'Yield'];

            function updateDiceDisplay() {
                document.getElementById('dice-score').textContent = score;
                document.getElementById('rolls-left').textContent = maxRolls - rolls;
                
                dice.forEach((value, index) => {
                    const diceEl = document.querySelector(`.dice:nth-child(${index + 1})`);
                    if (diceEl) {
                        diceEl.textContent = value || '?';
                    }
                });
            }

            window.rollDice = function() {
                if (rolls >= maxRolls) return;
                
                dice = dice.map((value, index) => {
                    const diceEl = document.querySelector(`.dice:nth-child(${index + 1})`);
                    if (!diceEl.classList.contains('held')) {
                        return Math.floor(Math.random() * 8);
                    }
                    return value;
                });
                
                rolls++;
                updateDiceDisplay();
                
                if (rolls >= maxRolls) {
                    document.getElementById('roll-btn').disabled = true;
                }
                document.getElementById('score-btn').disabled = false;
            };

            window.holdDice = function(index) {
                const diceEl = document.querySelector(`.dice:nth-child(${index + 1})`);
                diceEl.classList.toggle('held');
                diceEl.style.background = diceEl.classList.contains('held') ? 'var(--accent)' : 'var(--surface)';
            };

            window.scoreDice = function() {
                const points = calculateScore();
                score += points;
                showToast(`Intent scored! +${points} points`, 'success');
                
                dice = [0, 0, 0, 0, 0];
                rolls = 0;
                
                document.querySelectorAll('.dice').forEach(el => {
                    el.classList.remove('held');
                    el.style.background = 'var(--surface)';
                });
                
                document.getElementById('roll-btn').disabled = false;
                document.getElementById('score-btn').disabled = true;
                updateDiceDisplay();
            };

            function calculateScore() {
                const types = dice.map(value => intentTypes[value]);
                
                // Check for specific combinations
                if (types.includes('Swap') && types.includes('Token')) return 50;
                if (types.includes('Bridge') && types.includes('Chain')) return 40;
                if (types.includes('Vote') && types.includes('Privacy')) return 60;
                if (types.includes('Stake') && types.includes('Yield')) return 70;
                
                // Check for dice combinations
                const counts = {};
                types.forEach(type => counts[type] = (counts[type] || 0) + 1);
                const values = Object.values(counts).sort((a, b) => b - a);
                
                if (values[0] === 5) return 200; // Five of a kind
                if (values[0] === 4) return 150; // Four of a kind
                if (values[0] === 3 && values[1] === 2) return 100; // Full house
                if (values[0] === 3) return 30; // Three of a kind
                if (values[0] === 2) return 10; // Pair
                
                return 0;
            }
        }

        // Close modal
        function closeModal() {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                // Clear timer if it exists
                if (modal.timerInterval) {
                    clearInterval(modal.timerInterval);
                }
                modal.remove();
            });
        }



        function playBuilderGame() {
            if (gameState.points < 50) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 50;
            gameState.gamesPlayed++;
            updateStats();
            showBuilderGame();
        }

        function showBuilderGame() {
            const components = [
                { name: 'Swap', type: 'action', cost: 10 },
                { name: 'Bridge', type: 'action', cost: 15 },
                { name: 'Stake', type: 'action', cost: 20 },
                { name: 'ETH', type: 'token', cost: 5 },
                { name: 'USDC', type: 'token', cost: 5 },
                { name: 'Ethereum', type: 'chain', cost: 8 },
                { name: 'Polygon', type: 'chain', cost: 8 },
                { name: 'Privacy', type: 'feature', cost: 12 }
            ];

            let selectedComponents = [];
            let budget = 100;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 800px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Builder Game</h3>
                    <div id="builder-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Build complex intents with available components</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Budget: <span id="builder-budget">${budget}</span> points</div>
                                <div>Score: <span id="builder-score">${score}</span></div>
                            </div>
                            <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Selected Components:</h5>
                                <div id="selected-components" style="min-height: 100px; border: 2px dashed var(--border); border-radius: 5px; padding: 10px; display: flex; flex-wrap: wrap; gap: 5px;">
                                    <div style="color: var(--muted); text-align: center; width: 100%;">No components selected</div>
                                </div>
                            </div>
                            <div style="background: var(--surface); border: 2px solid var(--border); border-radius: 10px; padding: 20px; margin: 20px 0;">
                                <h5>Available Components:</h5>
                                <div id="components-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                                    ${components.map((comp, index) => 
                                        `<div class="component" onclick="selectComponent(${index})" style="background: var(--accent); color: white; padding: 10px; border-radius: 5px; text-align: center; cursor: pointer; transition: all 0.3s ease;">
                                            <div style="font-weight: bold;">${comp.name}</div>
                                            <div style="font-size: 0.8rem;">${comp.type}</div>
                                            <div style="font-size: 0.8rem;">${comp.cost} pts</div>
                                        </div>`
                                    ).join('')}
                                </div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="buildIntent()" style="background: var(--success);">Build Intent</button>
                                <button class="btn" onclick="clearSelection()" style="background: var(--warning);">Clear</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectComponent = function(index) {
                const component = components[index];
                if (budget >= component.cost && !selectedComponents.includes(index)) {
                    selectedComponents.push(index);
                    budget -= component.cost;
                    updateBuilderDisplay();
                } else if (selectedComponents.includes(index)) {
                    selectedComponents = selectedComponents.filter(i => i !== index);
                    budget += component.cost;
                    updateBuilderDisplay();
                } else {
                    showToast('Not enough budget!', 'error');
                }
            };

            function updateBuilderDisplay() {
                document.getElementById('builder-budget').textContent = budget;
                
                const selectedEl = document.getElementById('selected-components');
                if (selectedComponents.length === 0) {
                    selectedEl.innerHTML = '<div style="color: var(--muted); text-align: center; width: 100%;">No components selected</div>';
                } else {
                    selectedEl.innerHTML = selectedComponents.map(index => {
                        const comp = components[index];
                        return `<div style="background: var(--accent); color: white; padding: 5px 10px; border-radius: 3px; display: inline-block; cursor: pointer;" onclick="selectComponent(${index})">${comp.name} (${comp.cost})</div>`;
                    }).join('');
                }
            }

            window.buildIntent = function() {
                if (selectedComponents.length === 0) {
                    showToast('Select at least one component!', 'error');
                    return;
                }

                const selectedComps = selectedComponents.map(i => components[i]);
                const points = calculateIntentScore(selectedComps);
                score += points;
                
                showToast(`Intent built! +${points} points`, 'success');
                
                // Reset for next intent
                selectedComponents = [];
                budget = 100;
                updateBuilderDisplay();
                document.getElementById('builder-score').textContent = score;
            };

            window.clearSelection = function() {
                selectedComponents = [];
                budget = 100;
                updateBuilderDisplay();
            };

            function calculateIntentScore(components) {
                let score = 0;
                const types = components.map(c => c.type);
                
                // Base score for each component
                score += components.length * 5;
                
                // Bonus for combinations
                if (types.includes('action') && types.includes('token')) score += 20;
                if (types.includes('action') && types.includes('chain')) score += 15;
                if (types.includes('amount') && types.includes('token')) score += 10;
                
                // Bonus for multiple actions
                const actionCount = types.filter(t => t === 'action').length;
                if (actionCount > 1) score += actionCount * 10;
                
                return score;
            }
        }

        function playShrimpJumpGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showShrimpJumpGame();
        }

        function showShrimpJumpGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let isJumping = false;
            let obstacles = [];
            let gameLoop = null;
            let obstacleSpawnInterval = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🦐 大虾跳跃游戏</h3>
                    <div id="shrimp-jump-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Control大虾跳跃AvoidObstacles！</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="shrimp-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="shrimp-score">${score}</span></div>
                            </div>
                            <div id="shrimp-game-area" style="width: 100%; height: 300px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden;">
                                <div id="shrimp-player" style="position: absolute; bottom: 20px; left: 50px; width: 40px; height: 40px; font-size: 2rem; transition: all 0.3s ease;">🦐</div>
                                <div id="shrimp-obstacles" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startShrimpJumpGame()" id="start-shrimp-jump-btn" style="background: var(--success);">Start Game</button>
                                <button class="btn" onclick="shrimpJump()" id="shrimp-jump-btn" disabled style="background: var(--accent);">Jump (Space)</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                Use space key or click jump button to control shrimp and avoid obstacles!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startShrimpJumpGame = function() {
                console.log('Starting shrimp jump game...');
                gameRunning = true;
                document.getElementById('start-shrimp-jump-btn').disabled = true;
                document.getElementById('shrimp-jump-btn').disabled = false;
                
                // 重置Time
                timeLeft = 30;
                document.getElementById('shrimp-time').textContent = timeLeft;
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('shrimp-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endShrimpJumpGame(score);
                    }
                }, 1000);

                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    
                    moveShrimpObstacles();
                    checkShrimpCollisions();
                }, 50);

                // Spawn obstacles
                obstacleSpawnInterval = setInterval(() => {
                    if (!gameRunning) return;
                    spawnShrimpObstacle();
                }, 2500);

                // Keyboard controls
                document.addEventListener('keydown', handleShrimpKeyPress);
            };

            function handleShrimpKeyPress(e) {
                if (e.code === 'Space' && gameRunning) {
                    e.preventDefault();
                    shrimpJump();
                }
            }

            window.shrimpJump = function() {
                if (!gameRunning || isJumping) return;
                
                isJumping = true;
                const player = document.getElementById('shrimp-player');
                player.style.bottom = '120px';
                player.style.transform = 'rotate(-20deg)';
                
                setTimeout(() => {
                    player.style.bottom = '20px';
                    player.style.transform = 'rotate(0deg)';
                    isJumping = false;
                }, 600);
            };

            function spawnShrimpObstacle() {
                const obstaclesContainer = document.getElementById('shrimp-obstacles');
                const obstacle = document.createElement('div');
                obstacle.style.position = 'absolute';
                obstacle.style.right = '-40px';
                obstacle.style.top = '220px';
                obstacle.style.width = '30px';
                obstacle.style.height = '30px';
                obstacle.style.fontSize = '1.5rem';
                obstacle.style.textAlign = 'center';
                obstacle.style.lineHeight = '30px';
                obstacle.style.background = 'var(--danger)';
                obstacle.style.borderRadius = '50%';
                obstacle.style.animation = 'moveLeft 4s linear forwards';
                obstacle.textContent = '🪨';
                
                obstaclesContainer.appendChild(obstacle);
                
                obstacles.push({
                    element: obstacle,
                    x: 650,
                    y: 220,
                    width: 30,
                    height: 30
                });
                
                setTimeout(() => {
                    if (obstacle.parentNode) {
                        obstacle.remove();
                        obstacles = obstacles.filter(obs => obs.element !== obstacle);
                    }
                }, 4000);
            }

            function moveShrimpObstacles() {
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 2;
                    obstacle.element.style.right = (600 - obstacle.x) + 'px';
                    
                    if (obstacle.x < -50) {
                        obstacle.element.remove();
                        obstacles.splice(index, 1);
                    }
                });
            }

            function checkShrimpCollisions() {
                const player = document.getElementById('shrimp-player');
                const playerRect = player.getBoundingClientRect();
                const gameAreaRect = document.getElementById('shrimp-game-area').getBoundingClientRect();
                
                const playerX = playerRect.left - gameAreaRect.left;
                const playerY = playerRect.top - gameAreaRect.top;
                const playerWidth = 40;
                const playerHeight = 40;
                
                // 增加Score（每帧+1分）
                score += 1;
                document.getElementById('shrimp-score').textContent = score;
                
                obstacles.forEach((obstacle, index) => {
                    // Use实际的Obstacles位置而不是计算位置
                    const obstacleRect = obstacle.element.getBoundingClientRect();
                    const obstacleX = obstacleRect.left - gameAreaRect.left;
                    const obstacleY = obstacleRect.top - gameAreaRect.top;
                    const obstacleWidth = 30;
                    const obstacleHeight = 30;
                    
                    // 只有当Obstacles在玩家附近时才检测碰撞
                    if (obstacleX < playerX + playerWidth + 20 && 
                        obstacleX + obstacleWidth > playerX - 20) {
                        
                        if (playerY < obstacleY + obstacleHeight &&
                            playerY + playerHeight > obstacleY) {
                            // Collision - game over
                            console.log('Collision detected!');
                            gameRunning = false;
                            endShrimpJumpGame(score);
                        }
                    }
                });
            }

            function endShrimpJumpGame(finalScore) {
                gameRunning = false;
                if (gameLoop) clearInterval(gameLoop);
                if (obstacleSpawnInterval) clearInterval(obstacleSpawnInterval);
                if (timer) clearInterval(timer); // 确保清理计时器
                
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('shrimp-jump-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 游戏结束！</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">最终Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playShrimpCollector() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showShrimpCollector();
        }

        function showShrimpCollector() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let timer = null;
            let spawnInterval = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🦐 Shrimp Collector Game</h3>
                    <div id="shrimp-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Collect Anoma shrimps!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="shrimp-time">${timeLeft}</span>s</div>
                                <div>Shrimps: <span id="shrimp-score">${score}</span></div>
                            </div>
                            <div id="shrimp-area" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden; cursor: crosshair;">
                                <div style="color: var(--muted); text-align: center; margin-top: 180px;">Click on shrimps to collect them!</div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startShrimpGame()" id="start-shrimp-btn" style="background: var(--success);">Start Game</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startShrimpGame = function() {
                gameRunning = true;
                document.getElementById('start-shrimp-btn').disabled = true;
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('shrimp-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endShrimpGame(score);
                    }
                }, 1000);

                // Spawn shrimps
                spawnInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(spawnInterval);
                        return;
                    }
                    spawnShrimp();
                }, 1000);

                // Click handler
                const shrimpArea = document.getElementById('shrimp-area');
                shrimpArea.addEventListener('click', handleShrimpClick);
            };

            function spawnShrimp() {
                const shrimpArea = document.getElementById('shrimp-area');
                const shrimp = document.createElement('div');
                shrimp.className = 'shrimp';
                shrimp.innerHTML = '🦐';
                shrimp.style.position = 'absolute';
                shrimp.style.left = Math.random() * (shrimpArea.offsetWidth - 30) + 'px';
                shrimp.style.top = Math.random() * (shrimpArea.offsetHeight - 30) + 'px';
                shrimp.style.fontSize = '24px';
                shrimp.style.cursor = 'pointer';
                shrimp.style.animation = 'float 2s ease-in-out infinite';
                
                shrimpArea.appendChild(shrimp);
                
                setTimeout(() => {
                    if (shrimp.parentNode) {
                        shrimp.remove();
                    }
                }, 3000);
            }

            function handleShrimpClick(e) {
                if (e.target.classList.contains('shrimp')) {
                    e.target.remove();
                    score++;
                    document.getElementById('shrimp-score').textContent = score;
                    showToast('Shrimp collected!', 'success');
                }
            }

            function endShrimpGame(finalScore) {
                gameRunning = false;
                if (timer) clearInterval(timer);
                if (spawnInterval) clearInterval(spawnInterval);
                
                const pointsEarned = Math.floor(finalScore * 3);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('shrimp-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Shrimps Collected: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playAnomaQuiz() {
            if (gameState.points < 50) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 50;
            gameState.gamesPlayed++;
            updateStats();
            showAnomaQuiz();
        }

        function showAnomaQuiz() {
            
            const questions = [
                {
                    question: "What is Anoma's core innovation?",
                    options: ["Faster transactions", "Intent-centric architecture", "Lower fees", "Better UI"],
                    correct: 1,
                    explanation: "Anoma's core innovation is intent-centric architecture that allows users to express what they want rather than how to do it."
                },
                {
                    question: "How does Anoma protect user privacy?",
                    options: ["Encryption", "Zero-knowledge proofs", "Private keys", "VPN"],
                    correct: 1,
                    explanation: "Anoma uses zero-knowledge proofs to protect user privacy while maintaining security."
                },
                {
                    question: "What makes Anoma different from other blockchains?",
                    options: ["Speed", "Intent system", "Fees", "Consensus"],
                    correct: 1,
                    explanation: "Anoma's intent system allows users to express their goals rather than specific transactions."
                }
            ];

            let currentQuestion = 0;
            let score = 0;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧠 Anoma Master Quiz</h3>
                    <div id="quiz-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Question ${currentQuestion + 1}/${questions.length}</h4>
                            <div style="font-size: 1.2rem; margin: 20px 0; padding: 20px; background: var(--bg); border-radius: 10px;">
                                <strong>${questions[0].question}</strong>
                            </div>
                            <div id="quiz-options" style="display: grid; gap: 10px; margin: 20px 0;">
                                ${questions[0].options.map((option, index) => 
                                    `<button class="btn" onclick="selectQuizOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                                ).join('')}
                            </div>
                            <div id="quiz-score">Score: 0/${questions.length}</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.selectQuizOption = function(selectedIndex) {
                const correct = questions[currentQuestion].correct;
                if (selectedIndex === correct) {
                    score++;
                    showToast('✅ Correct!', 'success');
                } else {
                    showToast('❌ Wrong!', 'error');
                }

                currentQuestion++;
                if (currentQuestion < questions.length) {
                    document.querySelector('h4').textContent = `Question ${currentQuestion + 1}/${questions.length}`;
                    document.querySelector('#quiz-content strong').textContent = questions[currentQuestion].question;
                    document.getElementById('quiz-options').innerHTML = questions[currentQuestion].options.map((option, index) => 
                        `<button class="btn" onclick="selectQuizOption(${index})" style="background: var(--surface); color: var(--text); border: 1px solid var(--border);">${option}</button>`
                    ).join('');
                    document.getElementById('quiz-score').textContent = `Score: ${score}/${currentQuestion}`;
                } else {
                    // Quiz finished
                    const finalScore = score;
                    const pointsEarned = Math.floor(finalScore * 25);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('quiz-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Quiz Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}/${questions.length}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
            };
        }

        function playMemoryGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showMemoryGame();
        }

        function showMemoryGame() {
            const cards = [
                { id: 1, emoji: '🛡️', name: 'ZK-Proof' },
                { id: 2, emoji: '⚡', name: 'Intent Solver' },
                { id: 3, emoji: '🔐', name: 'Privacy Guard' },
                { id: 4, emoji: '🌉', name: 'Cross-Chain' },
                { id: 5, emoji: '🎯', name: 'Intent Matching' },
                { id: 6, emoji: '🔍', name: 'Intent Detective' },
                { id: 7, emoji: '🦐', name: 'Anoma Shrimp' },
                { id: 8, emoji: '🧙‍♂️', name: 'Anoma Wizard' }
            ];
            
            // Duplicate cards for matching
            const gameCards = [...cards, ...cards].sort(() => Math.random() - 0.5);
            
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let gameStartTime = Date.now();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; text-align: center;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧠 Anoma Memory Game</h3>
                    <div style="text-align: center; margin: 15px 0; color: var(--muted);">
                        Match Anoma concepts and characters! Find the pairs!
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 20px 0; padding: 15px; background: var(--surface); border-radius: 10px;">
                        <div>Moves: <span id="memory-moves">0</span></div>
                        <div>Pairs: <span id="memory-pairs">0/8</span></div>
                        <div>Time: <span id="memory-time">0s</span></div>
                    </div>
                    <div id="memory-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;">
                        ${gameCards.map((card, index) => `
                            <div class="memory-card" data-index="${index}" data-id="${card.id}" onclick="flipCard(${index})" style="
                                width: 80px; height: 80px; background: var(--surface); border: 2px solid var(--border); 
                                border-radius: 10px; display: flex; align-items: center; justify-content: center; 
                                font-size: 2rem; cursor: pointer; transition: all 0.3s ease; user-select: none;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                            ">
                                <div class="card-back" style="font-size: 1.5rem; color: var(--accent);">❓</div>
                                <div class="card-front" style="display: none; font-size: 2.2rem; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));">${card.emoji}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div id="memory-message" style="font-size: 1.2rem; margin: 20px 0; min-height: 30px;"></div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Start timer
            const timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                document.getElementById('memory-time').textContent = elapsed + 's';
            }, 1000);
            
            window.flipCard = function(index) {
                const card = document.querySelector(`[data-index="${index}"]`);
                if (!card || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                
                card.classList.add('flipped');
                card.querySelector('.card-back').style.display = 'none';
                card.querySelector('.card-front').style.display = 'flex';
                card.style.background = 'linear-gradient(135deg, var(--accent), var(--success))';
                card.style.transform = 'rotateY(180deg) scale(1.1)';
                card.style.boxShadow = '0 4px 15px rgba(0, 212, 255, 0.4)';
                
                flippedCards.push({ index, id: gameCards[index].id, element: card });
                moves++;
                document.getElementById('memory-moves').textContent = moves;
                
                if (flippedCards.length === 2) {
                    setTimeout(() => {
                        checkMatch();
                    }, 500);
                }
                
                soundSystem.playSound('click');
            };
            
            function checkMatch() {
                const [card1, card2] = flippedCards;
                
                if (card1.id === card2.id) {
                    // Match found
                    card1.element.classList.add('matched');
                    card2.element.classList.add('matched');
                    card1.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card2.element.style.background = 'linear-gradient(135deg, var(--success), #10b981)';
                    card1.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card2.element.style.transform = 'rotateY(180deg) scale(1.2)';
                    card1.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    card2.element.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
                    matchedPairs++;
                    document.getElementById('memory-pairs').textContent = `${matchedPairs}/8`;
                    
                    soundSystem.playSound('success');
                    particleSystem.createExplosion(card1.element.offsetLeft + 40, card1.element.offsetTop + 40, 25);
                    showToast(`🎉 Match found! ${card1.element.querySelector('.card-front').textContent}`, 'success');
                    
                    if (matchedPairs === 8) {
                        endMemoryGame();
                    }
                } else {
                    // No match
                    setTimeout(() => {
                        card1.element.classList.remove('flipped');
                        card2.element.classList.remove('flipped');
                        card1.element.querySelector('.card-back').style.display = 'flex';
                        card1.element.querySelector('.card-front').style.display = 'none';
                        card2.element.querySelector('.card-back').style.display = 'flex';
                        card2.element.querySelector('.card-front').style.display = 'none';
                        card1.element.style.background = 'var(--surface)';
                        card2.element.style.background = 'var(--surface)';
                        card1.element.style.transform = 'rotateY(0deg)';
                        card2.element.style.transform = 'rotateY(0deg)';
                    }, 1000);
                    
                    soundSystem.playSound('error');
                }
                
                flippedCards = [];
            }
            
            function endMemoryGame() {
                clearInterval(timer);
                const timeElapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                const pointsEarned = Math.max(10, 100 - moves - timeElapsed);
                gameState.points += pointsEarned;
                updateStats();
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; max-width: 500px;">
                        <button class="close-btn" onclick="closeModal()">&times;</button>
                        <h3 class="animated-bounce">🎉 Memory Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;" class="animated-rainbow">Perfect Match!</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;" class="animated-glow">Points Earned: ${pointsEarned}</div>
                        <div style="font-size: 1rem; margin: 20px 0;">
                            Time: ${timeElapsed}s | Moves: ${moves}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 50);
            }
        }

        function playArcheryGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showArcheryGame();
        }

        function showArcheryGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let arrows = [];
            let targets = [];
            let arrowCount = 50; // 大幅增加箭的数量
            let mouseX = 0;
            let mouseY = 0;
            let timer = null;
            let spawnInterval = null;
            let gameLoop = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 700px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🎯 Intent Archery Game</h3>
                    <div id="archery-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Shoot arrows at targets! Use mouse to aim and click to shoot!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="archery-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="archery-score">${score}</span></div>
                                <div>Arrows: <span id="archery-arrows">${arrowCount}</span></div>
                            </div>
                            <div id="archery-area" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden; cursor: crosshair;">
                                <div id="bow" style="position: absolute; left: 50px; top: 50%; transform: translateY(-50%); font-size: 40px; z-index: 10;">🏹</div>
                                <div id="crosshair" style="position: absolute; width: 20px; height: 20px; border: 2px solid var(--accent); border-radius: 50%; pointer-events: none; z-index: 5;"></div>
                                <div style="color: var(--muted); text-align: center; margin-top: 180px; position: absolute; left: 50%; transform: translateX(-50%);">Move mouse to aim, click to shoot!</div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startArcheryGame()" id="start-archery-btn" style="background: var(--success);">Start Game</button>
                                <button class="btn" onclick="shootArrow()" id="shoot-btn" disabled style="background: var(--accent);">Shoot Arrow (Space)</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                Use mouse to aim and click or press Space to shoot arrows at targets!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startArcheryGame = function() {
                gameRunning = true;
                document.getElementById('start-archery-btn').disabled = true;
                document.getElementById('shoot-btn').disabled = false;
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('archery-time').textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        endArcheryGame(score);
                    }
                }, 1000);

                // Spawn targets
                spawnInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(spawnInterval);
                        return;
                    }
                    spawnTarget();
                }, 1500);

                // Mouse tracking
                const archeryArea = document.getElementById('archery-area');
                archeryArea.addEventListener('mousemove', handleMouseMove);
                archeryArea.addEventListener('click', handleArcheryClick);
                document.addEventListener('keydown', handleKeyPress);

                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    updateArrows();
                    checkCollisions();
                }, 16);
            };

            function handleMouseMove(e) {
                const rect = e.currentTarget.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                
                // Update crosshair position
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = (mouseX - 10) + 'px';
                crosshair.style.top = (mouseY - 10) + 'px';
                
                // Update bow direction
                const bow = document.getElementById('bow');
                const dx = mouseX - 50;
                const dy = mouseY - 200; // Center of game area
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                bow.style.transform = `translateY(-50%) rotate(${angle}deg)`;
            }

            function handleKeyPress(e) {
                if (e.code === 'Space' && gameRunning && arrowCount > 0) {
                    e.preventDefault();
                    shootArrow();
                }
            }

            function handleArcheryClick(e) {
                if (gameRunning && arrowCount > 0) {
                    shootArrow();
                }
            }

            window.shootArrow = function() {
                if (!gameRunning || arrowCount <= 0) return;
                
                arrowCount--;
                document.getElementById('archery-arrows').textContent = arrowCount;
                
                const archeryArea = document.getElementById('archery-area');
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.innerHTML = '🏹';
                arrow.style.position = 'absolute';
                arrow.style.left = '50px';
                arrow.style.top = '50%';
                arrow.style.fontSize = '20px';
                arrow.style.zIndex = '15';
                
                // Calculate direction
                const dx = mouseX - 50;
                const dy = mouseY - 200; // Center of game area
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                arrow.style.transform = `translateY(-50%) rotate(${angle}deg)`;
                
                archeryArea.appendChild(arrow);
                
                // Add arrow to tracking array
                arrows.push({
                    element: arrow,
                    x: 50,
                    y: 200,
                    targetX: mouseX,
                    targetY: mouseY,
                    angle: angle,
                    speed: 12 // Increase arrow speed
                });
                
                if (arrowCount <= 0) {
                    document.getElementById('shoot-btn').disabled = true;
                }
            };

            function spawnTarget() {
                const archeryArea = document.getElementById('archery-area');
                const target = document.createElement('div');
                target.className = 'target';
                target.innerHTML = '🎯';
                target.style.position = 'absolute';
                
                // Ensure target is within game area
                const x = Math.random() * (archeryArea.offsetWidth - 60) + 30;
                const y = Math.random() * (archeryArea.offsetHeight - 60) + 30;
                
                target.style.left = x + 'px';
                target.style.top = y + 'px';
                target.style.fontSize = '30px';
                target.style.cursor = 'pointer';
                target.style.animation = 'pulse 1s ease-in-out infinite';
                target.style.zIndex = '5';
                target.style.width = '30px';
                target.style.height = '30px';
                
                archeryArea.appendChild(target);
                
                targets.push({
                    element: target,
                    x: x,
                    y: y,
                    width: 30,
                    height: 30
                });
                
                setTimeout(() => {
                    if (target.parentNode) {
                        target.remove();
                        targets = targets.filter(t => t.element !== target);
                    }
                }, 4000);
            }

            function updateArrows() {
                // Traverse from back to front to avoid index confusion when deleting elements
                for (let index = arrows.length - 1; index >= 0; index--) {
                    const arrow = arrows[index];
                    const dx = arrow.targetX - arrow.x;
                    const dy = arrow.targetY - arrow.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 10) {
                        // Arrow reached target position
                        if (arrow.element && arrow.element.parentNode) {
                            arrow.element.remove();
                        }
                        arrows.splice(index, 1);
                    } else {
                        // Move arrow towards target
                        arrow.x += (dx / distance) * arrow.speed;
                        arrow.y += (dy / distance) * arrow.speed;
                        
                        // Check if arrow is out of bounds
                        if (arrow.x < 0 || arrow.x > 800 || arrow.y < 0 || arrow.y > 400) {
                            if (arrow.element && arrow.element.parentNode) {
                                arrow.element.remove();
                            }
                            arrows.splice(index, 1);
                            continue;
                        }
                        
                        // Update arrow position
                        if (arrow.element) {
                            arrow.element.style.left = arrow.x + 'px';
                            arrow.element.style.top = arrow.y + 'px';
                            arrow.element.style.transform = `translate(-50%, -50%) rotate(${arrow.angle}deg)`;
                        }
                    }
                }
            }

            function checkCollisions() {
                // Traverse from back to front to avoid index confusion when deleting elements
                for (let arrowIndex = arrows.length - 1; arrowIndex >= 0; arrowIndex--) {
                    const arrow = arrows[arrowIndex];
                    
                    for (let targetIndex = targets.length - 1; targetIndex >= 0; targetIndex--) {
                        const target = targets[targetIndex];
                        
                        // Calculate distance from arrow center to target center
                        const arrowCenterX = arrow.x;
                        const arrowCenterY = arrow.y;
                        const targetCenterX = target.x + 15; // Half of target width
                        const targetCenterY = target.y + 15; // Half of target height
                        
                        const distance = Math.sqrt(
                            Math.pow(arrowCenterX - targetCenterX, 2) + 
                            Math.pow(arrowCenterY - targetCenterY, 2)
                        );
                        
                        if (distance < 30) { // Increase collision detection range
                            // Hit!
                            console.log('Target hit! Distance:', distance);
                            
                            // Remove target
                            if (target.element && target.element.parentNode) {
                                target.element.remove();
                            }
                            targets.splice(targetIndex, 1);
                            
                            // Remove arrow
                            if (arrow.element && arrow.element.parentNode) {
                                arrow.element.remove();
                            }
                            arrows.splice(arrowIndex, 1);
                            
                            score += 10;
                            document.getElementById('archery-score').textContent = score;
                            showToast('🎯 Target hit! +10 points', 'success');
                            soundSystem.playSound('success');
                            
                            // Create explosion effect
                            particleSystem.createExplosion(targetCenterX, targetCenterY, 20);
                            
                            break; // Break inner loop after arrow hits target
                        }
                    }
                }
            }

            function endArcheryGame(finalScore) {
                gameRunning = false;
                if (timer) clearInterval(timer);
                if (spawnInterval) clearInterval(spawnInterval);
                if (gameLoop) clearInterval(gameLoop);
                
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('archery-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Archery Game Complete!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function showWizardCoinGame() {
            let score = 0;
            let timeLeft = 30;
            let gameRunning = false;
            let coins = [];
            let timer = null;
            let gameLoop = null;
            let coinSpawnInterval = null;
            let wizardX = 200; // Initial wizard position

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 800px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧙 Wizard Coin Game</h3>
                    <div id="wizard-coin-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Control the wizard to catch falling coins!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Time: <span id="wizard-time">${timeLeft}</span>s</div>
                                <div>Score: <span id="wizard-score">${score}</span></div>
                                <div>Coins: <span id="coin-count">0</span></div>
                            </div>
                            <div id="wizard-game-area" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); border: 2px solid var(--accent); border-radius: 10px; position: relative; overflow: hidden;">
                                <div id="wizard-player" style="position: absolute; left: ${wizardX}px; bottom: 20px; width: 50px; height: 50px; font-size: 2.5rem; transition: all 0.1s ease;">🧙</div>
                                <div id="wizard-coins" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startWizardCoinGame()" id="start-wizard-btn" style="background: var(--success);">Start Game</button>
                                <button class="btn" onclick="moveWizardLeft()" id="wizard-left-btn" disabled style="background: var(--accent);">← Left</button>
                                <button class="btn" onclick="moveWizardRight()" id="wizard-right-btn" disabled style="background: var(--accent);">Right →</button>
                            </div>
                            <div style="color: var(--muted); font-size: 0.9rem;">
                                Use Left/Right arrow keys or click buttons to control wizard movement and catch coins!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startWizardCoinGame = function() {
                console.log('Starting wizard coin game...');
                gameRunning = true;
                score = 0;
                coins = [];
                wizardX = 200;
                
                // 重置Time
                timeLeft = 30;
                document.getElementById('wizard-time').textContent = timeLeft;
                
                document.getElementById('start-wizard-btn').disabled = true;
                document.getElementById('wizard-left-btn').disabled = false;
                document.getElementById('wizard-right-btn').disabled = false;
                
                // Reset wizard position
                const wizard = document.getElementById('wizard-player');
                wizard.style.left = wizardX + 'px';
                
                // Timer
                timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('wizard-time').textContent = timeLeft;
                    
                    if (timeLeft <= 0) {
                        endWizardCoinGame(score);
                    }
                }, 1000);

                // Spawn coins
                coinSpawnInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(coinSpawnInterval);
                        return;
                    }
                    spawnWizardCoin();
                }, 1500);

                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(gameLoop);
                        return;
                    }
                    
                    moveWizardCoins();
                    checkWizardCollisions();
                }, 16); // 60 FPS

                // Keyboard controls
                document.addEventListener('keydown', handleWizardKeyPress);
                
                soundSystem.playSound('gameStart');
                showToast('Wizard Coin Game Started! Use Left/Right arrow keys to move!', 'success');
            };

            function handleWizardKeyPress(e) {
                if (!gameRunning) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveWizardLeft();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveWizardRight();
                        break;
                }
            }

            window.moveWizardLeft = function() {
                if (!gameRunning) return;
                wizardX = Math.max(0, wizardX - 30);
                document.getElementById('wizard-player').style.left = wizardX + 'px';
            };

            window.moveWizardRight = function() {
                if (!gameRunning) return;
                const gameArea = document.getElementById('wizard-game-area');
                const maxX = gameArea.offsetWidth - 50;
                wizardX = Math.min(maxX, wizardX + 30);
                document.getElementById('wizard-player').style.left = wizardX + 'px';
            };

            function spawnWizardCoin() {
                const coinsContainer = document.getElementById('wizard-coins');
                const coin = document.createElement('div');
                coin.style.position = 'absolute';
                coin.style.left = Math.random() * 700 + 'px';
                coin.style.top = '0px';
                coin.style.width = '30px';
                coin.style.height = '30px';
                coin.style.fontSize = '1.5rem';
                coin.style.textAlign = 'center';
                coin.style.lineHeight = '30px';
                coin.style.background = 'var(--success)';
                coin.style.borderRadius = '50%';
                coin.style.animation = 'fallDown 3s linear forwards';
                coin.textContent = '🪙';
                
                coinsContainer.appendChild(coin);
                
                coins.push({
                    element: coin,
                    x: parseInt(coin.style.left),
                    y: 0,
                    width: 30,
                    height: 30,
                    speed: 2
                });
                
                setTimeout(() => {
                    if (coin.parentNode) {
                        coin.remove();
                        coins = coins.filter(c => c.element !== coin);
                    }
                }, 3000);
            }

            function moveWizardCoins() {
                coins.forEach((coin, index) => {
                    coin.y += coin.speed;
                    coin.element.style.top = coin.y + 'px';
                    
                    if (coin.y > 350) {
                        coin.element.remove();
                        coins.splice(index, 1);
                    }
                });
            }

            function checkWizardCollisions() {
                const wizard = document.getElementById('wizard-player');
                const wizardRect = wizard.getBoundingClientRect();
                const gameAreaRect = document.getElementById('wizard-game-area').getBoundingClientRect();
                
                const wizardX = wizardRect.left - gameAreaRect.left;
                const wizardY = wizardRect.top - gameAreaRect.top;
                const wizardWidth = 50;
                const wizardHeight = 50;
                
                coins.forEach((coin, index) => {
                    const coinX = coin.x;
                    const coinY = coin.y;
                    
                    if (wizardX < coinX + coin.width &&
                        wizardX + wizardWidth > coinX &&
                        wizardY < coinY + coin.height &&
                        wizardY + wizardHeight > coinY) {
                        // Coin collected
                        coin.element.remove();
                        coins.splice(index, 1);
                        score += 10;
                        document.getElementById('wizard-score').textContent = score;
                        document.getElementById('coin-count').textContent = Math.floor(score / 10);
                        soundSystem.playSound('collect');
                        particleSystem.createCollectEffect(coinX + coin.width/2, coinY + coin.height/2);
                        showToast('🪙 CoinsCollect成功！+10分', 'success');
                    }
                });
            }

            function endWizardCoinGame(finalScore) {
                gameRunning = false;
                if (timer) clearInterval(timer);
                if (gameLoop) clearInterval(gameLoop);
                if (coinSpawnInterval) clearInterval(coinSpawnInterval);
                
                const pointsEarned = Math.floor(finalScore / 2);
                gameState.points += pointsEarned;
                updateStats();
                
                soundSystem.playSound('gameEnd');
                particleSystem.createExplosion(400, 200, 30);
                
                document.getElementById('wizard-coin-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Wizard Coin Game Over!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${finalScore}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Coins Collected: ${Math.floor(finalScore / 10)}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }
        }

        function playRacingGame() {
            if (gameState.points < 40) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 40;
            gameState.gamesPlayed++;
            updateStats();
            showRacingGame();
        }

        function playComingSoon() {
            if (gameState.points < 10) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 10;
            gameState.gamesPlayed++;
            updateStats();
            showComingSoon();
        }

        function showComingSoon() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🚧 Coming Soon!</h3>
                    <div style="margin: 30px 0;">
                        <div style="font-size: 4rem; margin: 20px 0;">🚀</div>
                        <h4>New Games in Development!</h4>
                        <p style="color: var(--muted); margin: 20px 0;">
                            We're working hard to bring you more exciting Anoma games!
                        </p>
                        <div style="background: var(--surface); padding: 20px; border-radius: 10px; margin: 20px 0;">
                            <h5>Upcoming Features:</h5>
                            <ul style="text-align: left; margin: 10px 0;">
                                <li>🎮 Multiplayer Intent Battles</li>
                                <li>🧩 Advanced Privacy Puzzles</li>
                                <li>🏆 Tournament Mode</li>
                                <li>🎨 Custom Intent Builder</li>
                                <li>🌐 Cross-Chain Adventures</li>
                            </ul>
                        </div>
                        <div style="font-size: 1.2rem; margin: 20px 0; color: var(--accent);">
                            Stay tuned for updates!
                        </div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            soundSystem.playSound('success');
            particleSystem.createExplosion(window.innerWidth/2, window.innerHeight/2, 30);
        }

        // Add CSS for animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes moveLeft {
                from { right: -30px; }
                to { right: 100%; }
            }
            @keyframes fallDown {
                from { top: 0px; }
                to { top: 400px; }
            }
        `;
        document.head.appendChild(style);

        // Show toast
        function showToast(message, type) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            // Add animation based on type
            if (type === 'success') {
                toast.classList.add('animated-bounce');
                particleSystem.createParticle(window.innerWidth/2, 50, 'success');
            } else if (type === 'error') {
                toast.classList.add('animated-shake');
            }
            
            setTimeout(() => {
                toast.classList.remove('show');
                toast.classList.remove('animated-bounce');
                toast.classList.remove('animated-shake');
            }, 4000);
        }

        // Make Anoma Runner functions globally accessible
        window.startAnomaRunner = function() {
            // This will be set when showAnomaRunner is called
        };
        window.testAnomaJump = function() {
            // This will be set when showAnomaRunner is called
        };

        // Missing play functions
        function playShrimpCollector() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showShrimpCollector();
        }

        function playArcheryGame() {
            if (gameState.points < 30) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showArcheryGame();
        }

        function playWizardCoinGame() {
            if (gameState.points < 20) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 20;
            gameState.gamesPlayed++;
            updateStats();
            showWizardCoinGame();
        }

        function playSnakeGame() {
            if (gameState.points < 25) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 25;
            gameState.gamesPlayed++;
            updateStats();
            showSnakeGame();
        }

        function playPuzzleGame() {
            if (gameState.points < 35) {
                showToast('Not enough points!', 'error');
                return;
            }
            gameState.points -= 35;
            gameState.gamesPlayed++;
            updateStats();
            showPuzzleGame();
        }

        function showSnakeGame() {
            let score = 0;
            let gameRunning = false;
            let snake = [{x: 10, y: 10}];
            let direction = {x: 0, y: 0};
            let food = {x: 15, y: 15};
            let gameLoop = null;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🐍 Intent Snake Game</h3>
                    <div id="snake-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Control the snake to collect Anoma shrimps!</h4>
                            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                                <div>Score: <span id="snake-score">${score}</div>
                                <div>Length: <span id="snake-length">1</span></div>
                            </div>
                            <div id="snake-game-area" style="width: 400px; height: 400px; background: #000; border: 2px solid var(--accent); border-radius: 10px; position: relative; margin: 0 auto; display: grid; grid-template-columns: repeat(20, 1fr); grid-template-rows: repeat(20, 1fr);">
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                                    <h4>🐍 Intent Snake</h4>
                                    <p>Use arrow keys to control the snake!</p>
                                    <button class="btn" onclick="startSnakeGame()" style="margin-top: 10px;">Start Game</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startSnakeGame = function() {
                gameRunning = true;
                document.querySelector('#snake-game-area > div').style.display = 'none';
                
                // Reset game state
                snake = [{x: 10, y: 10}];
                direction = {x: 0, y: 0};
                score = 0;
                document.getElementById('snake-score').textContent = score;
                document.getElementById('snake-length').textContent = snake.length;
                
                const gameArea = document.getElementById('snake-game-area');
                
                function drawGame() {
                    gameArea.innerHTML = '';
                    
                    // Draw snake
                    snake.forEach((segment, index) => {
                        const cell = document.createElement('div');
                        cell.style.gridColumn = segment.x + 1;
                        cell.style.gridRow = segment.y + 1;
                        cell.style.background = index === 0 ? '#00ff88' : '#00d4ff';
                        cell.style.border = '1px solid #333';
                        cell.style.borderRadius = '2px';
                        gameArea.appendChild(cell);
                    });
                    
                    // Draw food
                    const foodCell = document.createElement('div');
                    foodCell.style.gridColumn = food.x + 1;
                    foodCell.style.gridRow = food.y + 1;
                    foodCell.style.background = '#ff6b6b';
                    foodCell.style.border = '1px solid #333';
                    foodCell.style.borderRadius = '50%';
                    foodCell.innerHTML = '🦐';
                    foodCell.style.display = 'flex';
                    foodCell.style.alignItems = 'center';
                    foodCell.style.justifyContent = 'center';
                    gameArea.appendChild(foodCell);
                }
                
                function moveSnake() {
                    if (!gameRunning) return;
                    
                    // Don't move if no direction is set
                    if (direction.x === 0 && direction.y === 0) {
                        drawGame();
                        return;
                    }
                    
                    const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
                    
                    // Check wall collision
                    if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20) {
                        endSnakeGame();
                        return;
                    }
                    
                    // Check self collision
                    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                        endSnakeGame();
                        return;
                    }
                    
                    snake.unshift(head);
                    
                    // Check food collision
                    if (head.x === food.x && head.y === food.y) {
                        score += 10;
                        document.getElementById('snake-score').textContent = score;
                        document.getElementById('snake-length').textContent = snake.length;
                        
                        // Generate new food
                        do {
                            food.x = Math.floor(Math.random() * 20);
                            food.y = Math.floor(Math.random() * 20);
                        } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
                    } else {
                        snake.pop();
                    }
                    
                    drawGame();
                }
                
                function endSnakeGame() {
                    gameRunning = false;
                    if (gameLoop) clearInterval(gameLoop);
                    
                    const pointsEarned = Math.floor(score / 5);
                    gameState.points += pointsEarned;
                    updateStats();
                    
                    document.getElementById('snake-game-content').innerHTML = `
                        <div style="text-align: center;">
                            <h3>🎉 Snake Game Complete!</h3>
                            <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${score}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Snake Length: ${snake.length}</div>
                            <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                            <button class="btn" onclick="closeModal()">Close</button>
                        </div>
                    `;
                }
                
                // Add keydown listener
                const keyHandler = function(e) {
                    if (!gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            if (direction.y !== 1) direction = {x: 0, y: -1};
                            break;
                        case 'ArrowDown':
                            if (direction.y !== -1) direction = {x: 0, y: 1};
                            break;
                        case 'ArrowLeft':
                            if (direction.x !== 1) direction = {x: -1, y: 0};
                            break;
                        case 'ArrowRight':
                            if (direction.x !== -1) direction = {x: 1, y: 0};
                            break;
                    }
                };
                
                document.addEventListener('keydown', keyHandler);
                
                drawGame();
                gameLoop = setInterval(moveSnake, 200);
            };
        }

        function playRacingGame() {
            if (gameState.points < 40) {
                showToast('Not enough points! Need 40 points to play Racing Game.', 'error');
                return;
            }
            
            gameState.points -= 40;
            gameState.gamesPlayed++;
            updateStats();
            showRacingGame();
        }

        // 俄罗斯方块游戏
        function playTetrisGame() {
            if (gameState.points < 30) {
                showToast('Not enough points! Need 30 points to play Tetris.', 'error');
                return;
            }
            
            gameState.points -= 30;
            gameState.gamesPlayed++;
            updateStats();
            showTetrisGame();
        }

        function showTetrisGame() {
            let score = 0;
            let gameRunning = false;
            let gameLoop;
            let board = [];
            let currentPiece = null;
            let pieceX = 0;
            let pieceY = 0;
            
            // 初始化游戏板
            for (let i = 0; i < 200; i++) {
                board[i] = 0;
            }

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 500px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🧩 Anoma Tetris</h3>
                    <div id="tetris-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Classic Tetris with Anoma-themed blocks!</h4>
                            <p style="color: var(--muted); margin: 10px 0; font-size: 0.9rem;">
                                UseArrow KeysControl方块，空格键旋转，下键快速下降！
                            </p>
                            <div style="margin: 20px 0;">
                                <div>Score: <span id="tetris-score">${score}</div>
                            </div>
                            <div id="tetris-board" style="width: 200px; height: 400px; background: #1a1a1a; border: 2px solid var(--accent); border-radius: 10px; position: relative; margin: 0 auto; display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(20, 1fr); gap: 1px; padding: 5px;"></div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startTetrisGame()">Start Game</button>
                                    </div>
                                </div>
                                    </div>
                                </div>
            `;
            document.body.appendChild(modal);

            window.startTetrisGame = function() {
                gameRunning = true;
                score = 0;
                
                document.getElementById('tetris-score').textContent = score;
                
                // 添加键盘Control
                const keyHandler = function(e) {
                    if (!gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            if (canMovePiece(-1, 0)) pieceX--;
                            break;
                        case 'ArrowRight':
                            if (canMovePiece(1, 0)) pieceX++;
                            break;
                        case 'ArrowDown':
                            if (canMovePiece(0, 1)) pieceY++;
                            break;
                        case ' ':
                            e.preventDefault();
                            rotatePiece();
                            break;
                    }
                    drawBoard();
                };
                
                document.addEventListener('keydown', keyHandler);
                
                // 生成第一个方块
                spawnNewPiece();
                drawBoard();
                
                // 游戏循环
                gameLoop = setInterval(() => {
                    if (!gameRunning) return;
                    
                    if (canMovePiece(0, 1)) {
                        pieceY++;
                    } else {
                        // 方块落地，固定到板上
                        placePiece();
                        clearLines();
                        spawnNewPiece();
                        
                        if (!canMovePiece(0, 0)) {
                            endTetrisGame();
                            return;
                        }
                    }
                    
                    drawBoard();
                }, 500);
            };

            function spawnNewPiece() {
                const pieces = [
                    { shape: [[1,1,1,1]], color: '#00d4ff' }, // I
                    { shape: [[1,1],[1,1]], color: '#10b981' }, // O
                    { shape: [[1,1,1],[0,1,0]], color: '#f59e0b' }, // T
                    { shape: [[1,1,1],[1,0,0]], color: '#ef4444' }, // L
                    { shape: [[1,1,1],[0,0,1]], color: '#8b5cf6' }, // J
                    { shape: [[0,1,1],[1,1,0]], color: '#ec4899' }, // S
                    { shape: [[1,1,0],[0,1,1]], color: '#06b6d4' }  // Z
                ];
                
                currentPiece = pieces[Math.floor(Math.random() * pieces.length)];
                pieceX = 4;
                pieceY = 0;
            }

            function canMovePiece(dx, dy) {
                if (!currentPiece) return false;
                
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const newX = pieceX + x + dx;
                            const newY = pieceY + y + dy;
                            
                            if (newX < 0 || newX >= 10 || newY >= 20) return false;
                            if (newY >= 0 && board[newY * 10 + newX]) return false;
                        }
                    }
                }
                return true;
            }

            function placePiece() {
                if (!currentPiece) return;
                
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardX = pieceX + x;
                            const boardY = pieceY + y;
                            if (boardY >= 0) {
                                board[boardY * 10 + boardX] = currentPiece.color;
                            }
                        }
                    }
                }
            }

            function clearLines() {
                let linesCleared = 0;
                
                for (let y = 19; y >= 0; y--) {
                    let isFull = true;
                    for (let x = 0; x < 10; x++) {
                        if (!board[y * 10 + x]) {
                            isFull = false;
                            break;
                        }
                    }
                    
                    if (isFull) {
                        linesCleared++;
                        for (let moveY = y; moveY > 0; moveY--) {
                            for (let x = 0; x < 10; x++) {
                                board[moveY * 10 + x] = board[(moveY - 1) * 10 + x];
                            }
                        }
                        for (let x = 0; x < 10; x++) {
                            board[x] = 0;
                        }
                        y++; // Re-check this row
                    }
                }
                
                if (linesCleared > 0) {
                    score += linesCleared * 100;
                    document.getElementById('tetris-score').textContent = score;
                }
            }

            function rotatePiece() {
                if (!currentPiece) return;
                
                const rotated = [];
                const rows = currentPiece.shape.length;
                const cols = currentPiece.shape[0].length;
                
                for (let i = 0; i < cols; i++) {
                    rotated[i] = [];
                    for (let j = 0; j < rows; j++) {
                        rotated[i][j] = currentPiece.shape[rows - 1 - j][i];
                    }
                }
                
                const originalShape = currentPiece.shape;
                currentPiece.shape = rotated;
                
                if (!canMovePiece(0, 0)) {
                    currentPiece.shape = originalShape;
                }
            }

            function drawBoard() {
                const boardElement = document.getElementById('tetris-board');
                boardElement.innerHTML = '';
                
                // Draw background
                for (let i = 0; i < 200; i++) {
                    const cell = document.createElement('div');
                    cell.style.background = board[i] || '#333';
                    cell.style.border = '1px solid #555';
                    cell.style.borderRadius = '2px';
                    boardElement.appendChild(cell);
                }
                
                // Draw current piece
                if (currentPiece) {
                    for (let y = 0; y < currentPiece.shape.length; y++) {
                        for (let x = 0; x < currentPiece.shape[y].length; x++) {
                            if (currentPiece.shape[y][x]) {
                                const cellIndex = (pieceY + y) * 10 + (pieceX + x);
                                if (cellIndex >= 0 && cellIndex < 200) {
                                    const cell = boardElement.children[cellIndex];
                                    if (cell) {
                                        cell.style.background = currentPiece.color;
                                        cell.style.border = '2px solid #fff';
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function endTetrisGame() {
                gameRunning = false;
                if (gameLoop) clearInterval(gameLoop);
                
                const pointsEarned = Math.floor(score / 50);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('tetris-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎮 Tetris Game Over!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                            </div>
                `;
            }
        }

        function showRacingGame() {
            let score = 0;
            let gameRunning = false;
            let carX = 200;
            let carY = 300;
            let obstacles = [];
            let tokens = [];
            let gameLoop;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="width: 90%; max-width: 600px;">
                    <button class="close-btn" onclick="closeModal()">&times;</button>
                    <h3>🏎️ Anoma Racing Game</h3>
                    <div id="racing-game-content">
                        <div style="text-align: center; margin: 20px 0;">
                            <h4>Race through Anoma's blockchain network and collect tokens!</h4>
                            <p style="color: var(--muted); margin: 10px 0; font-size: 0.9rem;">
                                Use arrow keys to control the car, avoid obstacles, and collect tokens!
                            </p>
                            <div style="margin: 20px 0;">
                                <div>Score: <span id="racing-score">${score}</span></div>
                                <div>Tokens: <span id="token-count">0</span></div>
                            </div>
                            <div id="racing-track" style="width: 500px; height: 400px; background: linear-gradient(90deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%); border: 3px solid var(--accent); border-radius: 10px; position: relative; margin: 0 auto; overflow: hidden;">
                                <div id="racing-car" style="position: absolute; width: 50px; height: 30px; background: linear-gradient(135deg, #00d4ff, #10b981); border-radius: 8px; left: ${carX}px; top: ${carY}px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; box-shadow: 0 2px 4px rgba(0,0,0,0.3); position: relative;">
                                    <div style="position: absolute; top: -5px; left: 50%; transform: translateX(-50%); font-size: 0.8rem;">🧙‍♂️</div>
                                    <div style="font-size: 1rem;">🚗</div>
                        </div>
                                <div id="racing-obstacles" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                                <div id="racing-tokens" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            </div>
                            <div style="margin: 20px 0;">
                                <button class="btn" onclick="startRacingGame()">Start Race</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            window.startRacingGame = function() {
                gameRunning = true;
                score = 0;
                carX = 200;
                carY = 300;
                obstacles = [];
                tokens = [];
                
                document.getElementById('racing-score').textContent = score;
                document.getElementById('token-count').textContent = 0;
                
                // Add keyboard controls
                const keyHandler = function(e) {
                    if (!gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            carY = Math.max(50, carY - 20);
                            break;
                        case 'ArrowDown':
                            carY = Math.min(350, carY + 20);
                            break;
                        case 'ArrowLeft':
                            carX = Math.max(50, carX - 20);
                            break;
                        case 'ArrowRight':
                            carX = Math.min(410, carX + 20);
                            break;
                    }
                    
                    document.getElementById('racing-car').style.left = carX + 'px';
                    document.getElementById('racing-car').style.top = carY + 'px';
                };
                
                document.addEventListener('keydown', keyHandler);
                
                // Game loop
                gameLoop = setInterval(() => {
                    if (!gameRunning) return;
                    
                    // Generate obstacles
                    if (Math.random() < 0.02) {
                        const obstacle = document.createElement('div');
                        obstacle.style.position = 'absolute';
                        obstacle.style.left = '500px';
                        obstacle.style.top = Math.random() * 300 + 'px';
                        obstacle.style.width = '30px';
                        obstacle.style.height = '30px';
                        obstacle.style.background = 'var(--danger)';
                        obstacle.style.borderRadius = '50%';
                        obstacle.style.display = 'flex';
                        obstacle.style.alignItems = 'center';
                        obstacle.style.justifyContent = 'center';
                        obstacle.style.fontSize = '1.2rem';
                        obstacle.textContent = '🪨';
                        
                        document.getElementById('racing-obstacles').appendChild(obstacle);
                        obstacles.push({
                            element: obstacle,
                            x: 500,
                            y: parseInt(obstacle.style.top)
                        });
                    }
                    
                    // Generate tokens
                    if (Math.random() < 0.03) {
                        const token = document.createElement('div');
                        token.style.position = 'absolute';
                        token.style.left = '500px';
                        token.style.top = Math.random() * 300 + 'px';
                        token.style.width = '25px';
                        token.style.height = '25px';
                        token.style.background = 'var(--warning)';
                        token.style.borderRadius = '50%';
                        token.style.display = 'flex';
                        token.style.alignItems = 'center';
                        token.style.justifyContent = 'center';
                        token.style.fontSize = '1rem';
                        token.textContent = '🪙';
                        
                        document.getElementById('racing-tokens').appendChild(token);
                        tokens.push({
                            element: token,
                            x: 500,
                            y: parseInt(token.style.top)
                        });
                    }
                    
                    // Move obstacles and tokens
                    obstacles.forEach((obstacle, index) => {
                        obstacle.x -= 3;
                        obstacle.element.style.left = obstacle.x + 'px';
                        
                        if (obstacle.x < -50) {
                            obstacle.element.remove();
                            obstacles.splice(index, 1);
                        }
                        
                        // Check collision
                        if (Math.abs(carX - obstacle.x) < 30 && Math.abs(carY - obstacle.y) < 30) {
                            endRacingGame();
                        }
                    });
                    
                    tokens.forEach((token, index) => {
                        token.x -= 2;
                        token.element.style.left = token.x + 'px';
                        
                        if (token.x < -50) {
                            token.element.remove();
                            tokens.splice(index, 1);
                        }
                        
                        // Check collection
                        if (Math.abs(carX - token.x) < 25 && Math.abs(carY - token.y) < 25) {
                            token.element.remove();
                            tokens.splice(index, 1);
                            score += 10;
                            document.getElementById('racing-score').textContent = score;
                            document.getElementById('token-count').textContent = Math.floor(score / 10);
                        }
                    });
                    
                    score += 1;
                    document.getElementById('racing-score').textContent = score;
                    
                }, 50);
            };

            function endRacingGame() {
                gameRunning = false;
                if (gameLoop) clearInterval(gameLoop);
                
                const pointsEarned = Math.floor(score / 10);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('racing-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🏁 Racing Game Over!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Final Score: ${score}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Tokens Collected: ${Math.floor(score / 10)}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }

            function drawPuzzle() {
                const board = document.getElementById('puzzle-board');
                board.innerHTML = '';
                
                puzzle.forEach((value, index) => {
                    const cell = document.createElement('div');
                    cell.style.background = value === 0 ? '#555' : 'linear-gradient(135deg, #00d4ff, #10b981)';
                    cell.style.color = 'white';
                    cell.style.display = 'flex';
                    cell.style.alignItems = 'center';
                    cell.style.justifyContent = 'center';
                    cell.style.fontSize = '2rem';
                    cell.style.fontWeight = 'bold';
                    cell.style.borderRadius = '5px';
                    cell.style.cursor = value === 0 ? 'default' : 'pointer';
                    cell.textContent = value === 0 ? '' : value;
                    
                    if (value !== 0) {
                        cell.onclick = () => movePiece(index);
                    }
                    
                    board.appendChild(cell);
                });
            }

            function movePiece(index) {
                if (!gameRunning) return;
                
                const emptyIndex = puzzle.indexOf(0);
                const row = Math.floor(index / 4);
                const col = index % 4;
                const emptyRow = Math.floor(emptyIndex / 4);
                const emptyCol = emptyIndex % 4;
                
                // Check if the clicked piece is adjacent to the empty space
                if ((Math.abs(row - emptyRow) === 1 && col === emptyCol) ||
                    (Math.abs(col - emptyCol) === 1 && row === emptyRow)) {
                    
                    // Swap the pieces
                    [puzzle[index], puzzle[emptyIndex]] = [puzzle[emptyIndex], puzzle[index]];
                    moves++;
                document.getElementById('puzzle-moves').textContent = moves;
                    
                drawPuzzle();
                    
                    // Check if puzzle is solved
                    if (isSolved()) {
                        endPuzzleGame();
                    }
                }
            }

            function isSolved() {
                for (let i = 0; i < puzzle.length - 1; i++) {
                    if (puzzle[i] !== i + 1) return false;
                }
                return puzzle[puzzle.length - 1] === 0;
            }

            function endPuzzleGame() {
                gameRunning = false;
                
                const pointsEarned = Math.max(10, 50 - moves);
                gameState.points += pointsEarned;
                updateStats();
                
                document.getElementById('puzzle-game-content').innerHTML = `
                    <div style="text-align: center;">
                        <h3>🎉 Puzzle Solved!</h3>
                        <div style="font-size: 2rem; margin: 20px 0;">Moves: ${moves}</div>
                        <div style="font-size: 1.2rem; margin: 20px 0;">Points Earned: ${pointsEarned}</div>
                        <button class="btn" onclick="closeModal()">Close</button>
                    </div>
                `;
            }

            // Initialize with shuffled puzzle
            shufflePuzzle();
        }

        // Page initialization
        document.addEventListener('DOMContentLoaded', function() {
            // Load language settings from local storage
            const savedLanguage = localStorage.getItem('language');
            if (savedLanguage) {
                currentLanguage = savedLanguage;
            }
            
            // Initialize language
            updatePageContent();
            
            // Update button text
            const langText = document.getElementById('lang-text');
            const themeText = document.getElementById('theme-text');
            if (langText) langText.textContent = translations[currentLanguage]['lang-text'];
            if (themeText) themeText.textContent = translations[currentLanguage]['theme-text'];
        });
    </script>
    
    <!-- Author Information -->
    <div class="author-info">
        <h3 data-translate="development-team">Development Team</h3>
        <div class="author-links">
            <a href="https://twitter.com/251262871Com" target="_blank" class="author-btn">🐦 Twitter: @251262871Com</a>
            <a href="https://twitter.com/Kivendeen_eth" target="_blank" class="author-btn">🐦 Twitter: @Kivendeen_eth</a>
            <a href="https://discord.com/users/More2591" target="_blank" class="author-btn">💬 Discord: More2591</a>
            <a href="https://discord.com/users/luxurious.m" target="_blank" class="author-btn">💬 Discord: luxurious.m</a>
        </div>
    </div>
</body>
</html>